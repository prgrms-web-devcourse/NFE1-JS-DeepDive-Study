# 25장 클래스



# 25.1 클래스는 프로토타입의 문법적 설탕인가?

<aside>
🍀

**문법적 설탕** : 요약 문법과 의미를 바꾸지 않으면서도 새로운 기능을 기존에 있는 기능으로 표현함으로써 언어에 추가하는 것

</aside>

자바스크립트는 프로토타입 기반의 객체지향 언어.

본래는 클래스가 필요 없는 (Class free) 객체지향 프로그래밍 언어.

```tsx
// ES5 생성자 함수
var Person = (function () {
  // 생성자 함수
  function Person(name) {
    this.name = name;
  }

  // 프로토타입 메서드
  Person.prototype.sayHi = function () {
    console.log('Hi! My name is ' + this.name);
  };

  // 생성자 함수 반환
  return Person;
}());

// 인스턴스 생성
var me = new Person('Lee');
me.sayHi(); // Hi! My name is Lee
```

하지만 클래스 기반 언어가 익숙한 프로그래머들에게 혼란을 야기하므로 ES6에서는 클래스 기반 객체지향 프로그래밍 언어와 매우 흡사한 새로운 객체 생성 메커니즘을 제시했다.

그렇다고 기존의 객체지향 모델을 폐지한 것은 아니고 사실 클래스는 함수이며 기존 프로토타입 기반 패턴을 클래스 기반 패턴처럼 사용할 수 있도록 하는 문법적 설탕이라고 볼 수도 있다.

> 사실 클래스는 함수.
> 
> 
> 기존 프로토타입 기반 패턴을 클래스 기반 패턴처럼 사용할 수 있는 **문법적 설탕 (Syntactic sugar)**
> 

## 클래스와 생성자 함수의 차이점

1. 클래스는 new 연산자 없이 호출하면 에러 발생. 생성자 함수는 new 연산자 없이 호출하면 일반 함수로서 호출.
2. 클래스는 extends와 super 키워드로 상속 가능. 생성자 함수는 불가능.
3. 클래스는 호이스팅이 발생하지 않는 것처럼 동작. 생성자 함수는 호이스팅이 발생.
4. 클래스 내부에는 자동으로 strict mode가 지정되며 해제할 수 없다. 생성자 함수는 그렇지 않다.
5. 클래스의 constructor, 프로토타입 메서드, 정적 메서드는 모두 열거 불가능. (`[[Enumerable]]` ⇒ `false`)

# 25.2 클래스 정의

`class` 키워드를 사용하여 정의 가능.

클래스 이름은 **파스칼 케이스**를 사용하는 것이 일반적. (사용하지 않는다고 에러가 발생하진 않는다.)

```tsx
// 클래스 선언문
class Person {}
```

```tsx
// 익명 클래스 표현식
const Person = class {};

// 기명 클래스 표현식
const Person = class MyClass {};
```

클래스는 표현식으로 정의 가능하며 값으로 사용할 수 있는 **일급 객체.**

다음과 같은 특징을 갖는다.

- 무명 리터럴로 생성 가능. 즉, 런타임에 생성이 가능.
- 변수나 자료 구조에 저장 가능.
- 함수의 매개변수에게 전달 가능.
- 함수의 반환값으로 사용 가능.

클래스 몸체에는 0개 이상의 메서드만 정의할 수 있다. 
메서드는 **constructor(생성자), 프로토타입 메서드, 정적 메서드**의 세 가지가 있다.

```tsx
// 클래스 선언문
class Person {
  // 생성자
  constructor(name) {
    // 인스턴스 생성 및 초기화
    this.name = name; // name 프로퍼티는 public하다.
  }

  // 프로토타입 메서드
  sayHi() {
    console.log(`Hi! My name is ${this.name}`);
  }

  // 정적 메서드
  static sayHello() {
    console.log('Hello!');
  }
}

// 인스턴스 생성
const me = new Person('Lee');

// 인스턴스의 프로퍼티 참조
console.log(me.name); // Lee
// 프로토타입 메서드 호출
me.sayHi(); // Hi! My name is Lee
// 정적 메서드 호출
Person.sayHello(); // Hello!
```

## 클래스의 정의 방식 vs 생성자 함수의 정의 방식

```tsx
// 생성자 함수
var person = (function() {
	function Person(name) {
		this.name = name;
	}
...

// 클래스의 생성자
class Person {
	constructor(name) {
		this.name = name;
	}
...
```

```tsx
// 생성자 함수 프로토타입 메서드
...
	Person.prototype.sayHi = function() {
		console.log('Hi! My name is ' + this.name);
	};
...

// 클래스의 프로토타입 메서드
...
sayHi() {
	console.log('Hi! My name is ' + this.name);
};
...
```

```tsx
// 생성자 함수의 정적 메서드 및 함수 반환
...
	Person.sayHello = function() {
		console.log('Hello!');
	};

	return Person;
}());

// 클래스의 정적 메서드
...
static sayHello() {
	console.log('Hello!');
}
...
```

클래스와 생성자 함수의 정의 방식은 형태적인 면에서 매우 유사
![image](https://github.com/user-attachments/assets/8d1d0711-0a0c-4863-b16e-e9ccc3a2d0fa)

# 25.3 클래스 호이스팅

클래스는 함수로 평가된다.

```tsx
// 클래스 선언문
class Person {}

console.log(typeof Person); // function
```

클래스 선언문으로 정의된 클래스는 런타임 이전에 먼저 평가되어 함수 객체를 생성.

이때 생성되는 함수 객체는 contructor 생성자 함수.

프로토타입과 생성자 함수는 단독으로 존재할 수 없고 언제나 쌍으로 존재하기 때문에 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성된다.

단, 클래스는 클래스 정의 이전에 참조할 수 없다.

```tsx
console.log(Person);
// ReferenceError: Cannot access 'Person' before initialization

// 클래스 선언문
class Person {}
```

클래스 선언문은 호이스팅이 발생하지 않는 것처럼 보이나 그렇지 않다.

```tsx
const Person = '';

{
  // 호이스팅이 발생하지 않는다면 ''이 출력되어야 한다.
  console.log(Person);
  // ReferenceError: Cannot access 'Person' before initialization

  // 클래스 선언문
  class Person {}
}
```

클래스는 let, const 변수처럼 호이스팅이 발생.

따라서 선언문 이전에 TDZ에 들어가서 접근이 불가능.

var, let, const, function, function*, class 키워드로 선언된 모든 식별자는 런타임 이전에 실행되기 때문에 호이스팅된다.

# 25.4 인스턴스 생성

클래스는 인스턴스를 생성하는 것이 유일한 존재 이유이므로 반드시 new 연산자와 함께 호출해야 한다.

```tsx
class Person {}

// 인스턴스 생성
const me = new Person();
console.log(me); // Person {}
```

클래스의 유일한 존재 이유는 인스턴스를 생성하는 것.

따라서 new 연산자와 함께 호출해야 한다.

```tsx
class Person {}

// 클래스를 new 연산자 없이 호출하면 타입 에러가 발생한다.
const me = Person();
// TypeError: Class constructor Person cannot be invoked without 'new'
```

클래스 표현식으로 정의된 클래스의 경우 다음 예제와 같이 클래스를 가리키는 식별자(Person)를 사용해 인스턴스를 생성하지 않고 기명 클래스 표현식의 클래스 이름(MyClass)을 사용해 인스턴스를 생성하면 에러가 발생한다.

```tsx
const Person = class MyClass {};

// 함수 표현식과 마찬가지로 클래스를 가리키는 식별자로 인스턴스를 생성해야 한다.
const me = new Person();

// 클래스 이름 MyClass는 함수와 동일하게 클래스 몸체 내부에서만 유효한 식별자다.
console.log(MyClass); // ReferenceError: MyClass is not defined

const you = new MyClass(); // ReferenceError: MyClass is not defined
```

# 25.5 메서드

클래스의 몸체에는 0개 이상의 메서드만 선언 가능.

클래스 몸체에서 정의할 수 있는 메서드는 constructor, 프로토타입 메서드, 정적 메서드.

## 25.5.1 constructor

인스턴스를 생성하고 초기화하기 위한 특수한 메서드.

constructor는 이름을 변경할 수 없다.

```tsx
class Person {
  // 생성자
  constructor(name) {
    // 인스턴스 생성 및 초기화
    this.name = name;
  }
}
```

생성자 함수인 클래스의 내부를 들여다보기 위해 크롬 브라우저의 개발자 도구에서 실행

![image](https://github.com/user-attachments/assets/d3b52e45-4568-4c83-8489-a7eb58a226ce)

이처럼 클래스도 함수 객체 고유의 프로퍼티를 모두 갖고 있다. 함수와 동일하게 프로토타입과 연결되어 있으며 자신의 스코프체인을 구성한다.

모든 함수 객체가 가지고 있는 prototype 프로퍼티가 가리키는 프로토타입 객체의 constructor 프로퍼티는 클래스 자신을 가리키고 있다.
이는 인스턴스를 생성하는 생성자 함수이며 new 연산자와 함께 클래스를 호출하여 인스턴스를 생성한다는 의미이다.

```tsx
// 클래스는 함수다.
console.log(typeof Person); // function
console.dir(Person);
```

클래스 역시 함수와 동일하게 프로토타입과 연결.

자신의 스코프 체인을 구성.

모든 함수 객체가 갖고 있는 prototype 프로퍼티가 가리키는 프로토타입 객체의 constructor 프로퍼티는 클래스 자신.

클래스가 생성한 인스턴스의 내부

```tsx
// 인스턴스 생성
const me = new Person('Lee');
console.log(me);
```
![image](https://github.com/user-attachments/assets/54d2f4e1-aae8-48b5-b3b0-3d9f0ba27971)

Person 클래스의 constructor 내부에서 this에 추가한 name 프로퍼티가 클래스가 생성한 인스턴스의 프로퍼티로 추가된 것을 확인할 수 있다.

→ constructor 내부에서 this에 추가한 프로퍼티는 인스턴스 프로퍼티가 된다.

```tsx
// 클래스
class Person {
  // 생성자
  constructor(name) {
    // 인스턴스 생성 및 초기화
    this.name = name;
  }
}

// 생성자 함수
function Person(name) {
  // 인스턴스 생성 및 초기화
  this.name = name;
}
```

constructor는 하나의 메서드로 해석되는 것이 아니라, 클래스가 평가되어 생성한 함수 객체 코드의 일부가 된다.

클래스 정의가 평가되면 constructor의 기술된 동작을 하는 함수 객체가 생성.

1. constructor는 클래스 내에 최대 한 개만 존재.

```tsx
class Person {
  constructor() {}
  constructor() {}
}
// SyntaxError: A class may only have one constructor
```

1. constructor는 생략할 수 있다. constructor를 생략하면 클래스에 다음과 같이 빈 constructor가 암묵적으로 정의된다.

```tsx
class Person {}
```

```tsx
class Person {
  // constructor를 생략하면 다음과 같이 빈 constructor가 암묵적으로 정의된다.
  constructor() {}
}

// 빈 객체가 생성된다.
const me = new Person();
console.log(me); // Person {}
```

1. 프로퍼티가 추가되어 초기화된 인스턴스를 생성하려면 constructor 내부에서 this 인스턴스 프로퍼티를 추가한다.

```tsx
class Person {
  constructor() {
    // 고정값으로 인스턴스 초기화
    this.name = 'Lee';
    this.address = 'Seoul';
  }
}

// 인스턴스 프로퍼티가 추가된다.
const me = new Person();
console.log(me); // Person {name: "Lee", address: "Seoul"}
```

1. 인스턴스를 생성할 때 클래스 외부에서 인스턴스 프로퍼티의 초기값을 전달하려면 다음과 같이 constructor에 매개변수를 선언하고 인스턴스를 생성할 때 초기값을 전달한다. 이때 초기값은 constructor의 매개변수에게 전달된다

```tsx
class Person {
  constructor(name, address) {
    // 인수로 인스턴스 초기화
    this.name = name;
    this.address = address;
  }
}

// 인수로 초기값을 전달한다. 초기값은 constructor에 전달된다.
const me = new Person('Lee', 'Seoul');
console.log(me); // Person {name: "Lee", address: "Seoul"}
```

1. 인스턴스를 초기화 하려면 constructor을 생략해서는 안된다.

또한 new 연산자와 함께 클래스가 호출되면 생성자 함수와 동일하게 암묵적으로 this, 즉 인스턴스를 반환하기 때문에 constructor는 별도의 반환문을 갖지 않아야 한다.

만약 this가 아닌 다른 객체를 명시적으로 반환하면 인스턴스가 반환되지 못하고 return 문에 명시한 객체가 반환된다.

```tsx
class Person {
  constructor(name) {
    this.name = name;

    // 명시적으로 객체를 반환하면 암묵적인 this 반환이 무시된다.
    return {};
  }
}

// constructor에서 명시적으로 반환한 빈 객체가 반환된다.
const me = new Person('Lee');
console.log(me); // {}
```

하지만 명시적으로 원시값을 반환하면 원시값 반환은 무시되고 암묵적으로 this가 반환된다.

```tsx
class Person {
  constructor(name) {
    this.name = name;

    // 명시적으로 원시값을 반환하면 원시값 반환은 무시되고 암묵적으로 this가 반환된다.
    return 100;
  }
}

const me = new Person('Lee');
console.log(me); // Person { name: "Lee" }
```

> 클래스에서 this가 아닌 다른 값을 반환하는 것은 클래스의 기본 동작을 해치는 행위.
> 

## 25.5.2 프로토타입 메서드

클래스의 prototype 프로퍼티에 메서드를 추가하지 않아도 기본적으로 프로토타입 메서드가 된다.

```tsx
class Person {
  // 생성자
  constructor(name) {
    // 인스턴스 생성 및 초기화
    this.name = name;
  }

  // 프로토타입 메서드
  sayHi() {
    console.log(`Hi! My name is ${this.name}`);
  }
}

const me = new Person('Lee');
me.sayHi(); // Hi! My name is Lee
```

클래스가 생성한 인스턴스는 프로토타입 체인의 일원이 된다.

```tsx
// me 객체의 프로토타입은 Person.prototype이다.
Object.getPrototypeOf(me) === Person.prototype; // -> true
me instanceof Person; // -> true

// Person.prototype의 프로토타입은 Object.prototype이다.
Object.getPrototypeOf(Person.prototype) === Object.prototype; // -> true
me instanceof Object; // -> true

// me 객체의 constructor는 Person 클래스다.
me.constructor === Person; // -> true
```

프로토타입 체인은 클래스에 의해 생성된 인스턴스에도 동일하게 적용.

![image](https://github.com/user-attachments/assets/909c5c9e-9cf0-4444-821c-248c73f852c1)

이처럼 인스턴스는 프로토타입 메서드를 상속받아 사용할 수 있다.

프로토타입 체인은 모든 객체 생성 방식(객체 리터럴, 생성자 함수, Object.create 메서드 등)뿐만 아니라 클래스에 의해 생성된 인스턴스에도 동일하게 적용된다.

> 결국 클래스는 인스턴스를 생성하는 생성자 함수라고 볼 수 있고 클래스는 프로토타입 기반의 객체 생성 메커니즘이다.
> 

## 25.5.3 정적 메서드

> **정적 (Static) 메서드**
> 
> 
> 인스턴스를 생성하지 않아도 호출할 수 있는 메서드.
> 

```tsx

// 생성자 함수
function Person(name) {
  this.name = name;
}

// 정적 메서드
Person.sayHi = function () {
  console.log('Hi!');
};

// 정적 메서드 호출
Person.sayHi(); // Hi!
```

static 키워드를 붙이면 정적 메서드를 선언 가능.

```tsx
class Person {
  // 생성자
  constructor(name) {
    // 인스턴스 생성 및 초기화
    this.name = name;
  }

  // 정적 메서드
  static sayHi() {
    console.log('Hi!');
  }
}
```

![image](https://github.com/user-attachments/assets/09cd530c-10cb-4b2e-966b-5f2d32d0c251)


정적 메서드는 클래스에 바인딩된 메서드가 된다.

정적 메서드는 클래스 정의 이후 인스턴스를 생성하지 않아도 호출할 수 있다.

프로토타입 메서드처럼 인스턴스로 호출하지 않고 클래스로 호출 가능.

```tsx
// 정적 메서드는 클래스로 호출한다.
// 정적 메서드는 인스턴스 없이도 호출할 수 있다.
Person.sayHi(); // Hi!
```

```tsx
// 인스턴스 생성
const me = new Person('Lee');
me.sayHi(); // TypeError: me.sayHi is not a function
```

인스턴스의 프로토타입 체인 상에는 클래스가 존재하지 않기 때문에 인스턴스로 클래스의 메서드를 상속받을 수 없다.

## 25.5.4 정적 메서드와 프로토타입 메서드의 차이

1. 정적 메서드와 프로토타입 메서드는 프로토타입 체인이 다르다.
2. 정적 메서드는 클래스로 호출하고 프로토타입 메서드는 인스턴스로 호출.
3. 정적 메서드는 인스턴스 프로퍼티 참조 불가능. 프로토타입 메서든느 가능.

```tsx
class Square {
  // 정적 메서드
  static area(width, height) {
    return width * height;
  }
}

console.log(Square.area(10, 10)); // 100
```

```tsx
class Square {
  constructor(width, height) {
    this.width = width;
    this.height = height;
  }

  // 프로토타입 메서드
  area() {
    return this.width * this.height;
  }
}

const square = new Square(10, 10);
console.log(square.area()); // 100
```

메서드 내부의 this는 메서드를 호출한 객체에 바인딩.

따라서 프로토타입 메서드 내부의 this는 프로토타입 메서드를 호출한 인스턴스에 바인딩.

정적 메서드 내부의 this는 클래스에 바인딩.

> this를 사용하지 않는 메서드는 정적 메서드로 정의하는 것이 좋다.
> 

```tsx
// 표준 빌트인 객체의 정적 메서드
Math.max(1, 2, 3);          // -> 3
Number.isNaN(NaN);          // -> true
JSON.stringify({ a: 1 });   // -> "{"a":1}"
Object.is({}, {});          // -> false
Reflect.has({ a: 1 }, 'a'); // -> true
```

## 25.5.5 클래스에서 정의한 메서드의 특징

1. function 키워드를 생략한 메서드 축약 표현 사용.
2. 클래스에서 메서드를 정의할 때는 콤마가 불필요.
3. 암묵적으로 strict mode로 실행.
4. `for … in` 또는 `Object.keys` 로 열거 불가능.
5. 내부 메서드 `[[Contructor]]`를 갖지 않는 non-constructor. new 연산자와 함께 호출 불가능.

# 25.6 클래스의 인스턴스 생성 과정

new 연산자와 함께 클래스를 호출하면 생성자 함수와 마찬가지로 클래스의 내부 메서드 [[Construct]]가 호출되면서 다음과 같은 과정을 거쳐 인스턴스가 생성된다.

**1. 인스턴스 생성과 this 바인딩**

new 연산자와 함께 호출하면 먼저 암묵적으로 빈 객체가 인스턴스로 생성된다.

이 인스턴스의 프로토타입은 클래스의 prototype 프로퍼티가 가리키는 객체로 설정된다.

즉, 인스턴스는 this에 바인딩.

**2. 인스턴스 초기화**

constructor 내부 코드가 실행되어 this에 바인딩되어 있는 인스턴스를 초기화.

this에 바인딩되어 있는 인스턴스에 프로퍼티 추가.

constructor에 인수로 전달된 초기값으로 인스턴스 프로퍼티를 초기화.

**3. 인스턴스 반환**

완성된 인스턴스가 바인딩된 this가 암묵적으로 반환.

```jsx
class Person {
  // 생성자
  constructor(name) {
    // 1. 암묵적으로 인스턴스가 생성되고 this에 바인딩된다.
    console.log(this); // Person {}
    console.log(Object.getPrototypeOf(this) === Person.prototype); // true

    // 2. this에 바인딩되어 있는 인스턴스를 초기화한다.
    this.name = name;

    // 3. 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다.
  }
}
```

# 25.7 프로퍼티

## 25.7.1 인스턴스 프로퍼티

인스턴스 프로퍼티는 constructor 내부에서 정의.

```jsx
class Person {
  constructor(name) {
    // 인스턴스 프로퍼티
    this.name = name;
  }
}

const me = new Person('Lee');
console.log(me); // Person {name: "Lee"}
```

constructor 코드가 실행되기 전에는 암묵적으로 생성된 빈 객체가 인스턴스로써 존재.

constructor 코드가 실행되어 인스턴스에 프로퍼티를 추가하면서 초기화.

```jsx
class Person {
  constructor(name) {
    // 인스턴스 프로퍼티
    this.name = name; // name 프로퍼티는 public하다.
  }
}

const me = new Person('Lee');

// name은 public하다.
console.log(me.name); // Lee
```

## 25.7.2 접근자 프로퍼티

접근자 프로퍼티는 자체적으로는 값([[Value]] 내부 슬롯)을 갖지 않는다.

다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수로 구성된 프로퍼티.

```jsx
const person = {
  // 데이터 프로퍼티
  firstName: 'Ungmo',
  lastName: 'Lee',

  // fullName은 접근자 함수로 구성된 접근자 프로퍼티다.
  // getter 함수
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  },
  // setter 함수
  set fullName(name) {
    // 배열 디스트럭처링 할당: "36.1. 배열 디스트럭처링 할당" 참고
    [this.firstName, this.lastName] = name.split(' ');
  }
};

// 데이터 프로퍼티를 통한 프로퍼티 값의 참조.
console.log(`${person.firstName} ${person.lastName}`); // Ungmo Lee

// 접근자 프로퍼티를 통한 프로퍼티 값의 저장
// 접근자 프로퍼티 fullName에 값을 저장하면 setter 함수가 호출된다.
person.fullName = 'Heegun Lee';
console.log(person); // {firstName: "Heegun", lastName: "Lee"}

// 접근자 프로퍼티를 통한 프로퍼티 값의 참조
// 접근자 프로퍼티 fullName에 접근하면 getter 함수가 호출된다.
console.log(person.fullName); // Heegun Lee

// fullName은 접근자 프로퍼티다.
// 접근자 프로퍼티는 get, set, enumerable, configurable 프로퍼티 어트리뷰트를 갖는다.
console.log(Object.getOwnPropertyDescriptor(person, 'fullName'));
// {get: ƒ, set: ƒ, enumerable: true, configurable: true}
```

```jsx
class Person {
  constructor(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
  }

  // fullName은 접근자 함수로 구성된 접근자 프로퍼티다.
  // getter 함수
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }

  // setter 함수
  set fullName(name) {
    [this.firstName, this.lastName] = name.split(' ');
  }
}

const me = new Person('Ungmo', 'Lee');

// 데이터 프로퍼티를 통한 프로퍼티 값의 참조.
console.log(`${me.firstName} ${me.lastName}`); // Ungmo Lee

// 접근자 프로퍼티를 통한 프로퍼티 값의 저장
// 접근자 프로퍼티 fullName에 값을 저장하면 setter 함수가 호출된다.
me.fullName = 'Heegun Lee';
console.log(me); // {firstName: "Heegun", lastName: "Lee"}

// 접근자 프로퍼티를 통한 프로퍼티 값의 참조
// 접근자 프로퍼티 fullName에 접근하면 getter 함수가 호출된다.
console.log(me.fullName); // Heegun Lee

// fullName은 접근자 프로퍼티다.
// 접근자 프로퍼티는 get, set, enumerable, configurable 프로퍼티 어트리뷰트를 갖는다.
console.log(Object.getOwnPropertyDescriptor(Person.prototype, 'fullName'));
// {get: ƒ, set: ƒ, enumerable: false, configurable: true}
```

- getter : 인스턴스 프로퍼티에 접근할 때마다 프로퍼티 값을 조작하거나 별도의 행위가 필요할 때 사용.
- setter : 인스턴스 프로퍼티에 값을 할당할 때마다 프로퍼티 값을 조작하거나 별도의 행위가 필요할 때 사용.

## 25.7.3 클래스 필드 정의 제안

> **클래스 필드 (class field)**
> 
> 
> 클래스 기반 객체지향 언어에서 클래스가 생성할 인스턴스의 프로퍼티.
> 

클래스 기반 객체지향 언어(ex. Java)의 클래스는 어떨까?

클래스 기반 객체지향 언어의 this는 언제나 클래스가 생성할 인스턴스를 가리키고 주로 클래스 필드가 생성자 또는 메서드의 매개변수 이름과 동일할 때 클래스 필드임을 명확히 하기 위해 사용된다.

자바스크립트의 클래스 몸체에는 메서드만 선언할 수 있다. 따라서 클래스 몸체에 자바와 유사하게 클래스 필드를 선언하면 문법 에러(SyntaxError)가 발생한다.

그렇다면 아래의 예제는 어떨까?

this는 constructor와 메서드 내에서만 유효.

```jsx
class Person {
  // this에 클래스 필드를 바인딩해서는 안된다.
  this.name = ''; // SyntaxError: Unexpected token '.'
}
```

this를 반드시 사용해야한다.

```jsx
class Person {
  // 클래스 필드
  name = 'Lee';

  constructor() {
    console.log(name); // ReferenceError: name is not defined
  }
}

new Person();
```

초기값을 할당하지 않으면 undefined.

```jsx
class Person {
  // 클래스 필드를 초기화하지 않으면 undefined를 갖는다.
  name;
}

const me = new Person();
console.log(me); // Person {name: undefined}
```

constructor 내부에서만 초기화해야 한다.

```jsx
class Person {
  name;

  constructor(name) {
    // 클래스 필드 초기화.
    this.name = name;
  }
}

const me = new Person('Lee');
console.log(me); // Person {name: "Lee"}
```

클래스 필드에 함수를 할당하면 인스턴스의 메서드가 된다.

모든 클래스 필드는 인스턴스 프로퍼티이기 때문.

따라서 클래스 필드에 함수 할당은 비권장사항이다.

```jsx
<!DOCTYPE html>
<html>
<body>
  <button class="btn">0</button>
  <script>
    class App {
      constructor() {
        this.$button = document.querySelector('.btn');
        this.count = 0;

        // increase 메서드를 이벤트 핸들러로 등록
        // 이벤트 핸들러 increase 내부의 this는 DOM 요소(this.$button)를 가리킨다.
        // 하지만 increase는 화살표 함수로 정의되어 있으므로
        // increase 내부의 this는 인스턴스를 가리킨다.
        this.$button.onclick = this.increase;

        // 만약 increase가 화살표 함수가 아니라면 bind 메서드를 사용해야 한다.
        // $button.onclick = this.increase.bind(this);
      }

      // 인스턴스 메서드
      // 화살표 함수 내부의 this는 언제나 상위 컨텍스트의 this를 가리킨다.
      increase = () => this.$button.textContent = ++this.count;
    }
    new App();
  </script>
</body>
</html>
```

## 25.7.4 private 필드 정의 제안

인스턴스 프로퍼티는 클래스 외부에서 접근이 가능한 public.

```jsx
class Person {
  constructor(name) {
    this.name = name; // 인스턴스 프로퍼티는 기본적으로 public하다.
  }
}

// 인스턴스 생성
const me = new Person('Lee');
console.log(me.name); // Lee
```

public 필드는 참조할 수 있지만 private 필드는 클래스 내부에서만 참조할 수 있다.

| 접근 가능성 | public | private |
| --- | --- | --- |
| 클래스 내부 | O | O |
| 자식 클래스 내부 | O | X |
| 클래스 인스턴스를 통한 접근 | O | X |

이처럼 클래스 외부에서 private 필드에 직접 접근할 수는 없지만 접근자 프로퍼티를 통해 간접적으로 접근하는 방법은 유효하다.

#을 사용하여 private을 정의할 수 있는 표준 사양이 TC39 프로세스의 stage 3에서 제안되었다.

```jsx
class Person {
  // private 필드 정의
  #name = '';

  constructor(name) {
    // private 필드 참조
    this.#name = name;
  }
}

const me = new Person('Lee');

// private 필드 #name은 클래스 외부에서 참조할 수 없다.
console.log(me.#name);
// SyntaxError: Private field '#name' must be declared in an enclosing class
```

## 25.7.5 static 필드 정의 제안

TC39 프로세스의 stage 3에서 “Static class features”가 제안되었다.

static public 필드, static private 필드, static private 메서드를 정의할 수 있다.

```jsx
class MyMath {
  // static public 필드 정의
  static PI = 22 / 7;

  // static private 필드 정의
  static #num = 10;

  // static 메서드
  static increment() {
    return ++MyMath.#num;
  }
}

console.log(MyMath.PI); // 3.142857142857143
console.log(MyMath.increment()); // 11
```

# 25.8 상속에 의한 클래스 확장

## 25.8.1 클래스 상속과 생성자 함수 상속

프로토타입 기반 상속은 프로토타입 체인을 통해 다른 객체의 자산을 상속받는 개념이지만 ***상속에 의한 클래스 확장은 기존 클래스를 상속받아 새로운 클래스를 확장하여 정의***하는 것

![image](https://github.com/user-attachments/assets/78f70bdc-ffa6-428a-9912-16c95ac6f14d)


래스는 상속을 통해 기존 클래스를 확장할 수 있는 문법이 기본적으로 제공되지만 생성자 함수는 그렇지 않다. 이런 상속을 통해 클래스의 속성을 그대로 사용하면서 자신만의 고유한 속성만 추가하여 확장할 수 있다.

![image](https://github.com/user-attachments/assets/365e1a12-0ea8-4d02-a4d5-7a9c8e074585)


클래스 확장은 코드 재사용 관점에서 매우 유용하다.

```jsx
class Animal {
  constructor(age, weight) {
    this.age = age;
    this.weight = weight;
  }

  eat() { return 'eat'; }

  move() { return 'move'; }
}

// 상속을 통해 Animal 클래스를 확장한 Bird 클래스
class Bird extends Animal {
  fly() { return 'fly'; }
}

const bird = new Bird(1, 5);

console.log(bird); // Bird {age: 1, weight: 5}
console.log(bird instanceof Bird); // true
console.log(bird instanceof Animal); // true

console.log(bird.eat());  // eat
console.log(bird.move()); // move
console.log(bird.fly());  // fly
```

![image](https://github.com/user-attachments/assets/0fc6b070-ee5e-4f7a-8004-41fe4e6f5bdc)


extends 키워드를 사용한 클래스 확장은 간편하고 직관적이다. 하지만 생성자 함수는 클래스와 같이 상속을 통해 다른 생성자 함수를 확장할 수 있는 문법이 제공되지 않는다.

자바스크립트는 클래스 기반 언어가 아니므로 생성자 함수를 사용하여 클래스를 흉내 내려는 시도를 권장하지는 않지만 의사 클래스 상속(pseudo classical inheritance)패턴을 사용하여 상속에 의한 클래스 확장을 흉내 내기도 했다.

(지금은 클래스의 등장으로 의사 클래스 상속 패턴은 필요하지 않으니 참고로만 알고있기)

## 25.8.2 extends 키워드

> **서브 클래스 (subclass)**
> 
> 
> 상속을 통해 확장된 클래스.
> 
> 파생 클래스 또는 자식 클래스라고도 한다.
> 

> **수퍼 클래스 (super-class)**
> 
> 
> 서브 클래스에게 상속된 클래스.
> 
> 베이스 클래스 또는 부모 클래스라고도 한다.
> 

```jsx
// 수퍼(베이스/부모)클래스
class Base {}

// 서브(파생/자식)클래스
class Derived extends Base {}
```

extends 키워드의 역할은 수퍼클래스와 서브클래스 간의 상속 관계를 설정하는 것이다. 클래스도 프로토타입을 통해 상속 관계를 구현한다.

![image](https://github.com/user-attachments/assets/0fc6b070-ee5e-4f7a-8004-41fe4e6f5bdc)


수퍼클래스와 서브클래스는 인스턴스의 프로토타입 체인뿐 아니라 클래스 간의 프로토타입 체인도 생성한다. 이를 통해 프로토타입 메서드, 정적 메서드 모두 상속이 가능하다.

## 25.8.3 동적 상속

extends 키워드 앞에는 반드시 클래스가 와야한다.

```jsx
// 생성자 함수
function Base(a) {
  this.a = a;
}

// 생성자 함수를 상속받는 서브클래스
class Derived extends Base {}

const derived = new Derived(1);
console.log(derived); // Derived {a: 1}
```

extends 키워드 다음에는 클래스 뿐만 아니라 [[Constructor]] 내부 메서드를 갖는 함수 객체로 평가될 수 있는 모든 표현식이 올 수 있다.

```jsx
function Base1() {}

class Base2 {}

let condition = true;

// 조건에 따라 동적으로 상속 대상을 결정하는 서브클래스
class Derived extends (condition ? Base1 : Base2) {}

const derived = new Derived();
console.log(derived); // Derived {}

console.log(derived instanceof Base1); // true
console.log(derived instanceof Base2); // false
```

## 25.8.4 서브클래스의 constructor

서브클래스의 constructor 역시 생략하면 빈 객체가 생성된다.

프로퍼티가 있는 인스턴스를 생성하려면 서브클래스 내부의 constructor에서 프로퍼티를 추가해야 한다.

클래스에서 constructor를 생략하면 클래스에 비어있는 constructor가 암묵적으로 정의된다.

서브클래스에서 constructor를 생략하면 클래스에 다음과 같은 constructor가 암묵적으로 정의된다. args는 new 연산자와 함께 클래스를 호출할 때 전달한 인수의 리스트다.

```
constructor(...args) { super(...args); }
```

super()는 수퍼클래스의 constructor(super-constructor)를 호출하여 인스턴스를 생성한다.

다음 예제를 살펴보자. 수퍼클래스와 서브클래스 모두 constructor를 생략했다.

```jsx
// 수퍼클래스
class Base {}

// 서브클래스
class Derived extends Base {}
```

위 예제의 클래스에는 다음과 같이 암묵적으로 constructor가 정의된다.

```jsx
// 수퍼클래스
class Base {
	constructor() {}
}

// 서브클래스
class Derived extends Base {
	constructor(...args) { super(...args); }
}

const derived = new Derived();
console.log(derived);	// Derived {}
```

위 예제와 같이 수퍼클래스와 서브클래스 모두 constructor를 생략하면 빈 객체가 생성된다. 프로퍼티를 소유하는 인스턴스를 생성하려면 constructor 내부에서 인스턴스에 프로퍼티를 추가해야 한다.

## 25.8.5 super 키워드

> **super 호출**
> 
> 
> super 호출 시 수퍼클래스의 constructor (super-constructor)를 호출한다. super를 참조하면 수퍼클래스의 메서드를 호출할 수 있다.
> 

```jsx
// 수퍼클래스
class Base {
  constructor(a, b) {
    this.a = a;
    this.b = b;
  }
}

// 서브클래스
class Derived extends Base {
  // 다음과 같이 암묵적으로 constructor가 정의된다.
  // constructor(...args) { super(...args); }
}

const derived = new Derived(1, 2);
console.log(derived); // Derived {a: 1, b: 2}
```

서브 클래스에서 constructor를 사용하려면 반드시 super를 호출해야 한다.

```jsx
class Base {}

class Derived extends Base {
  constructor() {
    // ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor
    console.log('constructor call');
  }
}

const derived = new Derived();
```

서브 클래스의 constructor에서 super를 호출하기 이전에는 this를 참조할 수 없다.

```jsx
class Base {}

class Derived extends Base {
  constructor() {
    // ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor
    this.a = 1;
    super();
  }
}

const derived = new Derived(1);
```

super는 반드시 서브 클래스의 constructor에서만 호출한다.

```jsx
class Base {
  constructor() {
    super(); // SyntaxError: 'super' keyword unexpected here
  }
}

function Foo() {
  super(); // SyntaxError: 'super' keyword unexpected here
}
```

> super 참조
> 
> 
> 메서드 내에서 super를 참조하면 수퍼클래스의 메서드를 호출할 수 있다.
> 

super 참조를 통해 수퍼클래스의 메서드를 참조하려면 super가 수퍼 클래스의 prototype 프로퍼티에 바인딩된 프로토타입을 참조할 수 있어야 한다.

```jsx
// 수퍼클래스
class Base {
  constructor(name) {
    this.name = name;
  }

  sayHi() {
    return `Hi! ${this.name}`;
  }
}

class Derived extends Base {
  sayHi() {
    // __super는 Base.prototype을 가리킨다.
    const __super = Object.getPrototypeOf(Derived.prototype);
    return `${__super.sayHi.call(this)} how are you doing?`;
  }
}
```

```jsx
/*
[[HomeObject]]는 메서드 자신을 바인딩하고 있는 객체를 가리킨다.
[[HomeObject]]를 통해 메서드 자신을 바인딩하고 있는 객체의 프로토타입을 찾을 수 있다.
예를 들어, Derived 클래스의 sayHi 메서드는 Derived.prototype에 바인딩되어 있다.
따라서 Derived 클래스의 sayHi 메서드의 [[HomeObject]]는 Derived.prototype이고
이를 통해 Derived 클래스의 sayHi 메서드 내부의 super 참조가 Base.prototype으로 결정된다.
따라서 super.sayHi는 Base.prototype.sayHi를 가리키게 된다.
*/
super = Object.getPrototypeOf([[HomeObject]])
```

ES6의 메서드 축약 표현으로 정의된 함수만이 super 참조가 가능하다.

```jsx
const obj = {
  // foo는 ES6의 메서드 축약 표현으로 정의한 메서드다. 따라서 [[HomeObject]]를 갖는다.
  foo() {},
  // bar는 ES6의 메서드 축약 표현으로 정의한 메서드가 아니라 일반 함수다.
  // 따라서 [[HomeObject]]를 갖지 않는다.
  bar: function () {}
};
```

```jsx
const base = {
  name: 'Lee',
  sayHi() {
    return `Hi! ${this.name}`;
  }
};

const derived = {
  __proto__: base,
  // ES6 메서드 축약 표현으로 정의한 메서드다. 따라서 [[HomeObject]]를 갖는다.
  sayHi() {
    return `${super.sayHi()}. how are you doing?`;
  }
};

console.log(derived.sayHi()); // Hi! Lee. how are you doing?
```

```jsx
// 수퍼클래스
class Base {
  static sayHi() {
    return 'Hi!';
  }
}

// 서브클래스
class Derived extends Base {
  static sayHi() {
    // super.sayHi는 수퍼클래스의 정적 메서드를 가리킨다.
    return `${super.sayHi()} how are you doing?`;
  }
}

console.log(Derived.sayHi()); // Hi! how are you doing?
```

## 25.8.6 상속 클래스의 인스턴스 생성 과정

1. 서브 클래스의 super 호출
    
    자바스크립트 엔진은 수퍼 클래스와 서브 클래스 구분을 위해 내부 슬롯 `[[ConstructorKind]]`를 갖는다.
    
    아무것도 상속받지 않는 클래스는 “base”로, 상속을 받는 클래스는 “derived”로 설정된다.
    
2. 수퍼클래스의 인스턴스 생성과 this 바인딩
    
    super를 통해 수퍼 클래스의 인스턴스가 생성되지만, new 연산자와 함께 호출된 클래스는 서브 클래스이다. 따라서 인스턴스는 서브 클래스가 생성한 것으로 처리된다.
    
    ```jsx
    // 수퍼클래스
    class Rectangle {
      constructor(width, height) {
        // 암묵적으로 빈 객체, 즉 인스턴스가 생성되고 this에 바인딩된다.
        console.log(this); // ColorRectangle {}
        // new 연산자와 함께 호출된 함수, 즉 new.target은 ColorRectangle이다.
        console.log(new.target); // ColorRectangle
    ...
    ```
    
    ```jsx
    // 수퍼클래스
    class Rectangle {
      constructor(width, height) {
        // 암묵적으로 빈 객체, 즉 인스턴스가 생성되고 this에 바인딩된다.
        console.log(this); // ColorRectangle {}
        // new 연산자와 함께 호출된 함수, 즉 new.target은 ColorRectangle이다.
        console.log(new.target); // ColorRectangle
    
        // 생성된 인스턴스의 프로토타입으로 ColorRectangle.prototype이 설정된다.
        console.log(Object.getPrototypeOf(this) === ColorRectangle.prototype); // true
        console.log(this instanceof ColorRectangle); // true
        console.log(this instanceof Rectangle); // true
    ...
    ```
    
3. 수퍼클래스의 인스턴스 초기화
    
    수퍼클래스의 constructor가 실행되어 this에 바인딩되어있는 인스턴스 프로퍼티를 초기화한다.
    
    ```jsx
    // 수퍼클래스
    class Rectangle {
      constructor(width, height) {
        // 암묵적으로 빈 객체, 즉 인스턴스가 생성되고 this에 바인딩된다.
        console.log(this); // ColorRectangle {}
        // new 연산자와 함께 호출된 함수, 즉 new.target은 ColorRectangle이다.
        console.log(new.target); // ColorRectangle
    
        // 생성된 인스턴스의 프로토타입으로 ColorRectangle.prototype이 설정된다.
        console.log(Object.getPrototypeOf(this) === ColorRectangle.prototype); // true
        console.log(this instanceof ColorRectangle); // true
        console.log(this instanceof Rectangle); // true
    
        // 인스턴스 초기화
        this.width = width;
        this.height = height;
    
        console.log(this); // ColorRectangle {width: 2, height: 4}
      }
    ...
    ```
    
4. 서브클래스 constructor로의 복귀와 this 바인딩
    
    super가 반환한 인스턴스가 this에 바인딩되고 서브클래스는 이를 그대로 사용한다.
    
    ```jsx
    // 서브클래스
    class ColorRectangle extends Rectangle {
      constructor(width, height, color) {
        super(width, height);
    
        // super가 반환한 인스턴스가 this에 바인딩된다.
        console.log(this); // ColorRectangle {width: 2, height: 4}
    ...
    ```
    
    즉, super가 호출되지 않으면 this 바인딩이 불가능하다.
    
5. 서브클래스의 인스턴스 초기화
    
    super 호출 이후 서브클래스의 constructor 쪽의 인스턴스가 초기화된다.
    
6. 인스턴스 반환
    
    모든 처리가 끝난 후 인스턴스가 바인딩된 this가 암묵적으로 반환된다.
    
    ```jsx
    // 서브클래스
    class ColorRectangle extends Rectangle {
      constructor(width, height, color) {
        super(width, height);
    
        // super가 반환한 인스턴스가 this에 바인딩된다.
        console.log(this); // ColorRectangle {width: 2, height: 4}
    
        // 인스턴스 초기화
        this.color = color;
    
        // 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다.
        console.log(this); // ColorRectangle {width: 2, height: 4, color: "red"}
      }
    ...
    ```
    

## 25.8.7 표준 빌트인 생성자 함수 확장

String, Number, Array와 같은 표준 빌트인 객체 역시 [[Construct]] 내부 메서드를 갖는 생성자 함수.

따라서 extends 키워드를 통한 확장이 가능하다.

```jsx
// Array 생성자 함수를 상속받아 확장한 MyArray
class MyArray extends Array {
  // 중복된 배열 요소를 제거하고 반환한다: [1, 1, 2, 3] => [1, 2, 3]
  uniq() {
    return this.filter((v, i, self) => self.indexOf(v) === i);
  }

  // 모든 배열 요소의 평균을 구한다: [1, 2, 3] => 2
  average() {
    return this.reduce((pre, cur) => pre + cur, 0) / this.length;
  }
}

const myArray = new MyArray(1, 1, 2, 3);
console.log(myArray); // MyArray(4) [1, 1, 2, 3]

// MyArray.prototype.uniq 호출
console.log(myArray.uniq()); // MyArray(3) [1, 2, 3]
// MyArray.prototype.average 호출
console.log(myArray.average()); // 1.75
```

Array 생성자 함수를 상속받아 확장한 MyArray 클래스가 생성한 인스턴스 Array.prototype과 MyArray.prototype의 모든 메서드를 사용할 수 있다.

이때 주의할 것은 Array.prototype의 메서드 중에서 map, filter와 같이 새로운 배열을 반환하는 메서드가 MyArray 클래스의 인스턴스를 반환한다는 것이다.

```jsx
console.log(myArray.filter(v => v % 2) instanceof MyArray);	// true
```

만약 새로운 배열을 반환하는 메서드가 MyArray 클래스의 인스턴스를 반환하지 않고 Array의 인스턴스를 반환하면 MyArray 클래스의 메서드와 메서드 체이닝(method chaining)이 불가능하다.

```jsx
// 메서드 체이닝
// [1, 1, 2, 3] => [ 1, 1, 3 ] => [ 1, 3 ] => 2
console.log(myArray.filter(v => v % 2).uniq().average());	// 2
```

myArray.filter가 반환하는 인스턴스는 MyArray 클래스가 생성한 인스턴스로 uniq 메서드를 연이어 호출(메서드 체이닝)할 수 있다.

uniq 메서드가 반환하는 인스턴스는 Array.prototype.filter에 의해 생성되었기 때문에 Array 생성자 함수가 생성한 인스턴스로 생각할 수도 있겠다. 하지만 uniq 메서드가 반환하는 인스턴스도 MyArray 타입이다. 따라서 uniq 메서드가 반환하는 인스턴스로 average 메서드를 연이어 호출(메서드 체이닝)할 수 있다.

만약 MyArray 클래스의 uniq 메서드가 MyArray 클래스가 생성한 인스턴스가 아닌 Array가 생성한 인스턴스를 반환하게 하려면 다음과 같이 Symbol.species를 사용하여 정적 접근자 프로퍼티를 추가한다.

```jsx
// Array 생성자 함수를 상속받아 확장한 MyArray
class MyArray extends Array {
  	// 모든 메서드가 Array 타입의 인스턴스를 반환하도록 한다.
  	static get [Symbol.species]() { return Array; }

    // 중복된 배열 요소를 제거하고 반환한다: [1, 1, 2, 3] => [1, 2, 3]
    uniq() {
        return this.filter((v, i, self) => self.indexOf(v) === i);
    }

    // 모든 배열 요소의 평균을 구한다: [1, 2, 3] => 2
    average() {
        return this.reduce((per, cur) => pre + cur, 0) / this.length;
    }
}

const myArray = new MyArray(1, 1, 2, 3);

console.log(myArray.uniq() instanceof MyArray);	// false
console.log(myArray.uniq() instanceof Array);	// true

// 메서드 체이닝
// uniq 메서드는 Array 인스턴스를 반환하므로 average 메서드를 호출할 수 없다.
console.log(myArray.uniq().average());
// TypeError: myArray.uniq( ... ).average is not a function
```

# 26장 **ES6 함수의 추가 기능**

# 26.1 함수의 구분

ES6 이전까지 자바스크립트의 함수는 별다른 구분 없이 다양한 목적으로 사용되었다.

ES6 이전의 함수는 다음과 같이 활용될 수 있었다.

- 자바스크립트의 함수는 일반적인 함수로서 호출할 수 있다.
- new 연산자와 함께 호출하여 인스턴스를 생성할 수 있는 생성자 함수로서 호출할 수 있다.
- 객체에 바인딩되어 메서드로서 호출할 수도 있다.

ES6 이전의 함수는 동일한 함수라도 다양한 형태로 호출할 수 있다.

```tsx
var foo = function () {
  return 1;
};

// 일반적인 함수로서 호출
foo(); // -> 1

// 생성자 함수로서 호출
new foo(); // -> foo {}

// 메서드로서 호출
var obj = { foo: foo };
obj.foo(); // -> 1
```

즉, callable (호출할 수 있는 함수 객체)이면서 동시에 constructor (인스턴스를 생성할 수 있는 함수 객체) 이다.

```tsx
var foo = function () {};

// ES6 이전의 모든 함수는 callable이면서 constructor다.
foo(); // -> undefined
new foo(); // -> foo {}
```

메서드 (객체에 바인딩된 함수) 역시 callable 이며 동시에 constructor이다.

```tsx
// 프로퍼티 f에 바인딩된 함수는 callable이며 constructor다.
var obj = {
  x: 10,
  f: function () { return this.x; }
};

// 프로퍼티 f에 바인딩된 함수를 메서드로서 호출
console.log(obj.f()); // 10

// 프로퍼티 f에 바인딩된 함수를 일반 함수로서 호출
var bar = obj.f;
console.log(bar()); // undefined

// 프로퍼티 f에 바인딩된 함수를 생성자 함수로서 호출
console.log(new obj.f()); // f {}
```

이러한 특성은 문법적으로도 성능면에서도 문제가 있다.

생성자 함수로 호출하지 않아도 프로토타입 객체를 생성하기 때문에 실수를 유발할 수도 있고 성능면에서도 좋지 않다.

ES6 이전의 모든 함수는 callable 이면서 constructor 이다.

- **callable** : 호출할 수 있는 함수 객체
- **constructor** : 인스턴스를 생성할 수 있는 함수 객체

이는 편리해 보이지만 실수를 유발시킬 수 있으며 성능 면에서도 문제가 있다.

객체에 바인딩된 함수가 constructor라는 것은 객체에 바인딩된 함수가 prototype 프로퍼티를 가지며, 프로토타입 객체도 생성한다는 것을 의미하기 때문이다.

함수에 전달되어 보조 함수의 역할을 수행하는 콜백 함수도 마찬가지다. 콜백함수도 constructor이기 때문에 불필요한 프로토타입 객체를 생성한다.

이러한 문제를 해결하기 위해 ES6에서는 함수를 사용 목적에 따라 세 가지 종류로 명확히 구분했다.

| ES6 함수의 구분 | constructor | prototype | super | argument |
| --- | --- | --- | --- | --- |
| 일반 함수
: 함수의 선언문이나 함수 표현식으로 정의한 함수 | O | O | X | O |
| 메서드 | X | X | O | O |
| 화살표 함수 | X | X | X | X |

# 26.2 메서드

ES6 부터 메서드는 메서드 축약 표현으로 정의된 함수만을 의미한다.

```tsx
const obj = {
  x: 1,
  // foo는 메서드이다.
  foo() { return this.x; },
  // bar에 바인딩된 함수는 메서드가 아닌 일반 함수이다.
  bar: function() { return this.x; }
};

console.log(obj.foo()); // 1
console.log(obj.bar()); // 1
```

ES6 메서드는 인스턴스를 생성할 수 없는 non-constructor이다.

```tsx
new obj.foo(); // -> TypeError: obj.foo is not a constructor
new obj.bar(); // -> bar {}
```

```tsx
// obj.foo는 constructor가 아닌 ES6 메서드이므로 prototype 프로퍼티가 없다.
obj.foo.hasOwnProperty('prototype'); // -> false

// obj.bar는 constructor인 일반 함수이므로 prototype 프로퍼티가 있다.
obj.bar.hasOwnProperty('prototype'); // -> true
```

표준 빌트인 객체가 제공하는 프로토타입 메서드 및 정적 메서드 역시 non-constructor이다.

인스턴스를 생성할 수 없으므로 prototype 프로퍼티가 없고 프로토타입도 생성하지 않는다.
ES6 메서드는 자신을 바인딩한 객체를 가리키는 내부 슬롯 [[ HomeObject ]]를 갖는다.
super 참조는 내부 슬롯 [[ HomeObject ]]를 사용하여 수퍼클래스의 메서드를 참조하므로 내부 슬롯 [[ HomeObject ]]를 갖는 ES6 메서드는 super 키워드를 사용할 수 있다.

```tsx
String.prototype.toUpperCase.prototype; // -> undefined
String.fromCharCode.prototype           // -> undefined

Number.prototype.toFixed.prototype; // -> undefined
Number.isFinite.prototype;          // -> undefined

Array.prototype.map.prototype; // -> undefined
Array.from.prototype;          // -> undefined
```

ES6 메서드는 자신을 바인딩한 객체를 가리키는 `[[HomeObject]]` 내부 슬롯을 갖는다. super 참조는 이 내부 슬롯을 사용하여 수퍼 클래스의 메소드를 참조한다. 따라서 이 내부 슬롯을 갖는 ES6 메서드는 super 키워드를 사용할 수 있다.

```tsx
const base = {
  name: 'Lee',
  sayHi() {
    return `Hi! ${this.name}`;
  }
};

const derived = {
  __proto__: base,
  // sayHi는 ES6 메서드다. ES6 메서드는 [[HomeObject]]를 갖는다.
  // sayHi의 [[HomeObject]]는 sayHi가 바인딩된 객체인 derived를 가리키고
  // super는 sayHi의 [[HomeObject]]의 프로토타입인 base를 가리킨다.
  sayHi() {
    return `${super.sayHi()}. how are you doing?`;
  }
};

console.log(derived.sayHi()); // Hi! Lee. how are you doing?
```

```tsx
const derived = {
  __proto__: base,
  // sayHi는 ES6 메서드가 아니다.
  // 따라서 sayHi는 [[HomeObject]]를 갖지 않으므로 super 키워드를 사용할 수 없다.
  sayHi: function () {
    // SyntaxError: 'super' keyword unexpected here
    return `${super.sayHi()}. how are you doing?`;
  }
};
```

# 26.3 화살표 함수

**화살표 함수란?**

function 키워드 대신 화살표를 사용하고 기존 함수보다 간단하게 동작하는 함수.

콜백 함수 내부에서 this가 전역 객체를 가리키는 문제의 대안으로 유용.

## 26.3.1 화살표 함수 정의

**함수 정의**

함수 표현식으로만 정의해야 한다.

```jsx
const multiply = (x, y) => x * y;
multiply(2, 3); // -> 6
```

**매개변수 선언**

매개변수가 여러 개인 경우 소괄호 () 안에 매개변수를 사용한다

```jsx
const arrow = (x, y) => { ... };
const arrow = x => { ... };
const arrow = () => { ... };
```

**함수 몸체 정의**

함수 몸체가 하나의 문으로 구성된다면 몸체를 감싸는 중괄호를 생략할 수 있다.

```jsx
// concise body
const power = x => x ** 2;
power(2); // -> 4

// 위 표현은 다음과 동일하다.
// block body
const power = x => { return x ** 2; };
```

표현식이 아닌데 중괄호를 생략하면 에러 발생.

```jsx
const arrow = () => const x = 1; // SyntaxError: Unexpected token 'const'

// 위 표현은 다음과 같이 해석된다.
const arrow = () => { return const x = 1; };
```

```jsx
const arrow = () => { const x = 1; };
```

객체 리터럴 반환 시 소괄호로 감싸줘야 한다.

```jsx
const create = (id, content) => ({ id, content });
create(1, 'JavaScript'); // -> {id: 1, content: "JavaScript"}

// 위 표현은 다음과 동일하다.
const create = (id, content) => { return { id, content }; };
```

```jsx
// { id, content }를 함수 몸체 내의 쉼표 연산자문으로 해석한다.
const create = (id, content) => { id, content };
create(1, 'JavaScript'); // -> undefined
```

함수 몸체가 여러개라면 중괄호를 생략할 수 없다.

```jsx
const sum = (a, b) => {
  const result = a + b;
  return result;
};
```

즉시 실행 함수로 사용 가능.

```jsx
const person = (name => ({
  sayHi() { return `Hi? My name is ${name}.`; }
}))('Lee');

console.log(person.sayHi()); // Hi? My name is Lee.
```

고차 함수 (`Array.prototype.map` 등)에 인수로 전달 가능.

```jsx
// ES5
[1, 2, 3].map(function (v) {
  return v * 2;
});

// ES6
[1, 2, 3].map(v => v * 2); // -> [ 2, 4, 6 ]
```

## 26.3.2 화살표 함수와 일반 함수의 차이

1. **화살표 함수는 인스턴스를 생성할 수 없는 non-constructor.**
    
    ```jsx
    const Foo = () => {};
    // 화살표 함수는 생성자 함수로서 호출할 수 없다.
    new Foo(); // TypeError: Foo is not a constructor
    ```
    
    ```jsx
    // 화살표 함수는 인스턴스를 생성할 수 없으므로 prototype 프로퍼티가 없고 프로토타입도 생성하지 않는다.
    const Foo = () => {};
    
    Foo.hasOwnProperty('prototype'); // -> false
    ```
    
2. **중복된 매개변수 이름 선언 불가능.**
    
    ```jsx
    function normal(a, a) { return a + a; }
    console.log(normal(1, 2)); // 4
    ```
    
    ```jsx
    //strict mode
    'use strict';
    
    function normal(a, a) { return a + a; }
    // SyntaxError: Duplicate parameter name not allowed in this context
    ```
    
    ```jsx
    const arrow = (a, a) => a + a;
    // SyntaxError: Duplicate parameter name not allowed in this context
    ```
    
3. 화살표 함수는 함수 자체의 this, arguments, super, [new.target](http://new.target/) 바인딩이 없다.
    
    상위 스코프의 그것들을 따라서 참조한다.
    

## 26.3.3 this

일반 함수로서 호출되는 모든 함수 내부의 this는 전역 객체를 가리킨다.

동일한 조건에서 strict mode일 경우 내부의 this에는 undefined가 바인딩된다.

반면 화살표 함수는 함수 자체의 this 바인딩이 없고, 상위 스코프의 this를 그대로 참조한다. **(lexical this)**

```jsx
// 화살표 함수는 상위 스코프의 this를 참조한다.
() => this.x;

// 익명 함수에 상위 스코프의 this를 주입한다. 위 화살표 함수와 동일하게 동작한다.
(function () { return this.x; }).bind(this);
```

```jsx
// 중첩 함수 foo의 상위 스코프는 즉시 실행 함수다.
// 따라서 화살표 함수 foo의 this는 상위 스코프인 즉시 실행 함수의 this를 가리킨다.
(function () {
  const foo = () => console.log(this);
  foo();
}).call({ a: 1 }); // { a: 1 }

// bar 함수는 화살표 함수를 반환한다.
// bar 함수가 반환한 화살표 함수의 상위 스코프는 화살표 함수 bar다.
// 하지만 화살표 함수는 함수 자체의 this 바인딩을 갖지 않으므로 bar 함수가 반환한
// 화살표 함수 내부에서 참조하는 this는 화살표 함수가 아닌 즉시 실행 함수의 this를 가리킨다.
(function () {
  const bar = () => () => console.log(this);
  bar()();
}).call({ a: 1 }); // { a: 1 }
```

화살표 함수가 전역 함수라면 this는 전역 객체를 가리킨다.

```jsx
// 전역 함수 foo의 상위 스코프는 전역이므로 화살표 함수 foo의 this는 전역 객체를 가리킨다.
const foo = () => console.log(this);
foo(); // window
```

```jsx
// increase 프로퍼티에 할당한 화살표 함수의 상위 스코프는 전역이다.
// 따라서 increase 프로퍼티에 할당한 화살표 함수의 this는 전역 객체를 가리킨다.
const counter = {
  num: 1,
  increase: () => ++this.num
};

console.log(counter.increase()); // NaN
```

```jsx
window.x = 1;

const normal = function () { return this.x; };
const arrow = () => this.x;

console.log(normal.call({ x: 10 })); // 10
console.log(arrow.call({ x: 10 }));  // 1
```

화살표 함수의 this는 call, apply, bind로 교체할 수 없고 언제나 상위 스코프의 this를 가리킨다.

```jsx
const add = (a, b) => a + b;

console.log(add.call(null, 1, 2));    // 3
console.log(add.apply(null, [1, 2])); // 3
console.log(add.bind(null, 1, 2)());  // 3
```

메서드로 사용할 때 역시 화살표 함수의 this는 상위 스코프를 가리키므로 사용하지 않는 것이 좋다.

대신 ES6 메서드 축약 표현을 사용하는 것이 좋다.

```jsx
// Good
const person = {
  name: 'Lee',
  sayHi() {
    console.log(`Hi ${this.name}`);
  }
};

person.sayHi(); // Hi Lee
```

```jsx
// Bad
function Person(name) {
  this.name = name;
}

Person.prototype.sayHi = () => console.log(`Hi ${this.name}`);

const person = new Person('Lee');
// 이 예제를 브라우저에서 실행하면 this.name은 빈 문자열을 갖는 window.name과 같다.
person.sayHi(); // Hi
```

프로퍼티를 동적으로 추가할 경우는 ES6 메서드 정의를 사용할 수 없으므로 일반 함수를 사용한다.

```jsx
// Good
function Person(name) {
  this.name = name;
}

Person.prototype.sayHi = function () { console.log(`Hi ${this.name}`); };

const person = new Person('Lee');
person.sayHi(); // Hi Lee
```

클래스 필드에서 화살표 함수를 할당하면 프로토타입 메서드가 아닌 인스턴스 메서드가 되므로 ES6 메서드를 사용하는 것이 좋다.

```jsx
// Good
class Person {
  // 클래스 필드 정의
  name = 'Lee';

  sayHi() { console.log(`Hi ${this.name}`); }
}
const person = new Person();
person.sayHi(); // Hi Lee
```

## 26.3.4 super

화살표 함수의 super는 this와 마찬가지로 상위 스코프의 super를 참조한다.

```jsx
class Base {
  constructor(name) {
    this.name = name;
  }

  sayHi() {
    return `Hi! ${this.name}`;
  }
}

class Derived extends Base {
  // 화살표 함수의 super는 상위 스코프인 constructor의 super를 가리킨다.
  sayHi = () => `${super.sayHi()} how are you doing?`;
}

const derived = new Derived('Lee');
console.log(derived.sayHi()); // Hi! Lee how are you doing?
```

## 26.3.5 arguments

화살표 함수의 arguments 역시 상위 스코프의 arguments를 참조한다.

```jsx
(function () {
  // 화살표 함수 foo의 arguments는 상위 스코프인 즉시 실행 함수의 arguments를 가리킨다.
  const foo = () => console.log(arguments); // [Arguments] { '0': 1, '1': 2 }
  foo(3, 4);
}(1, 2));

// 화살표 함수 foo의 arguments는 상위 스코프인 전역의 arguments를 가리킨다.
// 하지만 전역에는 arguments 객체가 존재하지 않는다. arguments 객체는 함수 내부에서만 유효하다.
const foo = () => console.log(arguments);
foo(1, 2); // ReferenceError: arguments is not defined
```

# 26.4 Rest 파라미터

## 26.4.1 기본 문법

Rest 파라미터는 매개변수 이름 앞에 세개의 점 …을 붙여서 정의한 매개변수를 의미한다

함수에 전달된 인수들의 목록을 배열로 전달받는다.

```jsx
function foo(...rest) {
  // 매개변수 rest는 인수들의 목록을 배열로 전달받는 Rest 파라미터다.
  console.log(rest); // [ 1, 2, 3, 4, 5 ]
}

foo(1, 2, 3, 4, 5);
```

일반 매개변수와 같이 사용할 수 있다.

```jsx
function foo(param, ...rest) {
  console.log(param); // 1
  console.log(rest);  // [ 2, 3, 4, 5 ]
}

foo(1, 2, 3, 4, 5);

function bar(param1, param2, ...rest) {
  console.log(param1); // 1
  console.log(param2); // 2
  console.log(rest);   // [ 3, 4, 5 ]
}

bar(1, 2, 3, 4, 5);
```

먼저 선언된 매개변수에 할당된 인수를 제외한 나머지 인수들이 들어온다.

따라서 제일 마지막에 선언되어야한다.

```jsx
function foo(...rest) {}
console.log(foo.length); // 0

function bar(x, ...rest) {}
console.log(bar.length); // 1

function baz(x, y, ...rest) {}
console.log(baz.length); // 2
```

## 26.4.2 Rest 파라미터와 arguments 객체

arguments 객체는 함수 호출 시 전달된 인수들의 정보가 담겨있는 유사 배열 객체.

함수 내부에서 지역 변수처럼 사용 가능.

```jsx
// 매개변수의 개수를 사전에 알 수 없는 가변 인자 함수
function sum() {
  // 가변 인자 함수는 arguments 객체를 통해 인수를 전달받는다.
  console.log(arguments);
}

sum(1, 2); // {length: 2, '0': 1, '1': 2}
```

Rest 파라미터는 가변 인자 함수의 인수 목록을 배열로 직접 전달 가능.

```jsx
function sum(...args) {
  // Rest 파라미터 args에는 배열 [1, 2, 3, 4, 5]가 할당된다.
  return args.reduce((pre, cur) => pre + cur, 0);
}
console.log(sum(1, 2, 3, 4, 5)); // 15
```

화살표 함수는 함수 자체의 arguments가 없으므로 반드시 Rest 파라미터를 사용.

# 26.5 매개변수 기본값

함수를 호출할 때 매개변수의 개수만큼 인수를 전달하는 것이 바람직하지만 그렇지 않은 경우에도 에러가 발생하지 않는다. 

이는 자바스크립트 엔진이 매개변수의 개수와 인수의 개수를 체크하지 않기 때문이다.인수가 전달되지 않은 매개변수의 값은 undefined다. 이를 방치하면 의도치 않은 결과가 나올 수 있다

```jsx
function sum(x, y) {
	return x + y;
}

console.log(sum(1)); // NaN
```

따라서 인수가 전달되지 않은 경우 매개변수에 기본값을 할당할 필요가 있다.

```jsx
	function sum(x, y) {
	// 인수가 전달되지 않아 매개변수의 값이 undefined인 경우 기본값을 할당한다.
	x = x || 0;
	y = y || 0;

	return x + y;
}

console.log(sum(1, 2)); // 3
console.log(sum(1)); // 1
```

ES6에서 도입된 매개변수 기본값을 사용하면 함수 내에서 수행하던 인수 체크 및 초기화를 간소화할 수 있다.

ES6에서 도입.

매개 변수에 기본값을 설정해서 별도로 할당되지 않아도 에러 없이 사용 가능.

```jsx
function sum(x = 0, y = 0) {
  return x + y;
}

console.log(sum(1, 2)); // 3
console.log(sum(1));    // 1
```

매개변수에 인수를 전달하지 않았을 경우와 undefined를 전달한 경우에만 유효.

```jsx
function logName(name = 'Lee') {
  console.log(name);
}

logName();          // Lee
logName(undefined); // Lee
logName(null);      // null
```

Rest 파라미터는 기본값 지정이 불가능.

```jsx
function foo(...rest = []) {
  console.log(rest);
}
// SyntaxError: Rest parameter may not have a default initializer
```

매개변수 기본값은 함수 객체의 length 프로퍼티와 arguments 객체에 아무런 영향이 없다.

```jsx
function sum(x, y = 0) {
  console.log(arguments);
}

console.log(sum.length); // 1

sum(1);    // Arguments { '0': 1 }
sum(1, 2); // Arguments { '0': 1, '1': 2 }
```

# CH27 배열

# 27.1 배열이란?

> 여러 개의 값을 순차적으로 나열한 자료구조.
> 

사용 빈도가 매우 높은 가장 기본적인 자료구조.

다음은 자바스크립트에서 배열 리터럴을 통해 생성한 배열

```jsx
const arr = ['apple', 'banana', 'orange'];
```

**요소 (Element)**

배열이 가지고 있는 값.

**인덱스 (Index)**

배열에서 배열의 요소의 위치 (0 이상의 정수)

대괄호 표기법을 통해 요소에 접근.

```jsx
arr[0] // -> 'apple'
arr[1] // -> 'banana'
arr[2] // -> 'orange'
```

**length 프로퍼티**

배열의 길이를 나타내는 프로퍼티.

```jsx
arr.length // -> 3
```

```jsx
// 배열의 순회
for (let i = 0; i < arr.length; i++) {
  console.log(arr[i]); // 'apple' 'banana' 'orange'
}
```

배열 리터럴, Array 생성자 함수, Array.of, Array.from 메서드로 생성 가능.

```jsx
const arr = [1, 2, 3];

arr.constructor === Array // -> true
Object.getPrototypeOf(arr) === Array.prototype // -> true
```

| **구분** | **객체** | **배열** |
| --- | --- | --- |
| 구조 | 프로퍼티 키와 프로퍼티 값 | 인덱스와 요소 |
| 값의 참조 | 프로퍼티 키 | 인덱스 |
| 값의 순서 | X | O |
| length 프로퍼티 | X | O |

자바스크립트에서 배열은 객체 타입.

```jsx
typeof arr // -> object
```

하지만 “값의 순서”와 “length 프로퍼티”에서 둘은 명확한 차이가 있다.

```jsx
const arr = [1, 2, 3];

// 반복문으로 자료 구조를 순서대로 순회하기 위해서는 자료 구조의 요소에 순서대로
// 접근할 수 있어야 하며 자료 구조의 길이를 알 수 있어야 한다.
for (let i = 0; i < arr.length; i++) {
  console.log(arr[i]); // 1 2 3
}
```

# 27.2 자바스크립트 배열은 배열이 아니다

> 밀집 배열 (dense array)
> 
> 
> 배열의 요소가 하나의 데이터 타입으로 통일되어 있고 연속적으로 인접.
> 

인덱스를 통해 단 한번의 연산으로 특정 요소에 접근 가능. (`O(1)`)

정렬되지 않은 배열의 경우 처음 위치부터 선형적으로 검색해야 한다. (`O(n)`)

```jsx
// 선형 검색을 통해 배열(array)에 특정 요소(target)가 존재하는지 확인한다.
// 배열에 특정 요소가 존재하면 특정 요소의 인덱스를 반환하고, 존재하지 않으면 -1을 반환한다.
function linearSearch(array, target) {
  const length = array.length;

  for (let i = 0; i < length; i++) {
    if (array[i] === target) return i;
  }

  return -1;
}

console.log(linearSearch([1, 2, 3, 4, 5, 6], 3)); // 2
console.log(linearSearch([1, 2, 3, 4, 5, 6], 0)); // -1
```

> 희소 배열 (sparse array)
> 
> 
> 배열 요소 각각의 메모리 공간은 서로 다를 수 있고 연속적이지 않을 수 있다.
> 

자바스크립트의 배열은 일반적인 배열을 흉내낸 특수한 객체.

```jsx
// "16.2. 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체" 참고
console.log(Object.getOwnPropertyDescriptors([1, 2, 3]));
/*
{
  '0': {value: 1, writable: true, enumerable: true, configurable: true}
  '1': {value: 2, writable: true, enumerable: true, configurable: true}
  '2': {value: 3, writable: true, enumerable: true, configurable: true}
  length: {value: 3, writable: true, enumerable: false, configurable: false}
}
*/
```

```jsx
const arr = [
  'string',
  10,
  true,
  null,
  undefined,
  NaN,
  Infinity,
  [ ],
  { },
  function () {}
];
```

**일반적인 배열 vs 자바스크립트 배열**

🫠 일반적인 배열은 인덱스로 요소에 빠르게 접근 가능. 하지만 요소를 삽입 또는 삭제하는 경우에는 효율적이지 않다.

🫠 자바스크립트 배열은 "해시 테이블"로 구현된 객체이므로 인덱스로 접근하는 경우 일반적인 배열보다 느릴 수 밖에 없는 구조적인 단점이 있다. 하지만 요소를 삽입 또는 삭제하는 경우에는 일반적인 배열보다 빠른 성능을 기대할 수 있다.

# 27.3 length 프로퍼티와 희소 배열

배열의 길이를 나타내는 0 이상의 정수.

```jsx
[].length        // -> 0
[1, 2, 3].length // -> 3
```

현재 길이보다 더 작은 값을 length 프로퍼티에 할당하면 길이가 줄어든다.

```jsx
const arr = [1, 2, 3, 4, 5];

// 현재 length 프로퍼티 값인 5보다 작은 숫자 값 3을 length 프로퍼티에 할당
arr.length = 3;

// 배열의 길이가 5에서 3으로 줄어든다.
console.log(arr); // [1, 2, 3]
```

```jsx
const arr = [1, 2, 3];
console.log(arr.length); // 3

// 요소 추가
arr.push(4);
// 요소를 추가하면 length 프로퍼티의 값이 자동 갱신된다.
console.log(arr.length); // 4

// 요소 삭제
arr.pop();
// 요소를 삭제하면 length 프로퍼티의 값이 자동 갱신된다.
console.log(arr.length); // 3
```

```jsx
// 희소 배열
const sparse = [, 2, , 4];

// 희소 배열의 length 프로퍼티 값은 요소의 개수와 일치하지 않는다.
console.log(sparse.length); // 4
console.log(sparse); // [empty, 2, empty, 4]

// 배열 sparse에는 인덱스가 0, 2인 요소가 존재하지 않는다.
console.log(Object.getOwnPropertyDescriptors(sparse));
/*
{
  '1': { value: 2, writable: true, enumerable: true, configurable: true },
  '3': { value: 4, writable: true, enumerable: true, configurable: true },
  length: { value: 4, writable: true, enumerable: false, configurable: false }
}
*/
```

**희소 배열은 length 프로퍼티 값과 배열 요소의 개수가 일치하지 않는다. 희소 배열의 length는 희소 배열의 실제 요소 개수보다 언제나 크다.**

# 27.4 배열 생성

## 27.4.1 배열 리터럴

가장 일반적이고 간편한 배열 생성 방식.

배열 리터럴은 0개 이상의 요소를 쉼표로 구분하여 대괄호([])로 묶는다.

```jsx
const arr = [1, 2, 3];
console.log(arr.length); // 3
```

```jsx
const arr = [];
console.log(arr.length); // 0
```

```jsx
const arr = [1, , 3]; // 희소 배열

// 희소 배열의 length는 배열의 실제 요소 개수보다 언제나 크다.
console.log(arr.length); // 3
console.log(arr);        // [1, empty, 3]
console.log(arr[1]);     // undefined
```

## 27.4.2 Array 생성자 함수

`Array` 생성자 함수를 통해 배열을 생성할 수 있다. Array 생성자 함수는 전달된 인수의 개수에 따라 다르게 동작하므로 주의가 필요하다.

- 전달된 인수가 1개이고 숫자인 경우 length 프로퍼티 값이 인수인 배열을 생성

```jsx
const arr = new Array(10);

console.log(arr); // [empty × 10]
console.log(arr.length); // 10
```

```jsx
console.log(Object.getOwnPropertyDescriptors(arr));
/*
{
  length: {value: 10, writable: true, enumerable: false, configurable: false}
}
*/
```

```jsx
// 배열은 요소를 최대 4,294,967,295개 가질 수 있다.
new Array(4294967295);

// 전달된 인수가 0 ~ 4,294,967,295를 벗어나면 RangeError가 발생한다.
new Array(4294967296); // RangeError: Invalid array length

// 전달된 인수가 음수이면 에러가 발생한다.
new Array(-1); // RangeError: Invalid array length
```

- 이때 생성된 배열은 희소 배열이다. length 프로퍼티 값은 0이 아니지만 실제로 배열의 요소는 존재하지 않는다.
- 전달된 인수가 없는 경우 빈 배열을 생성한다. 즉, 배열 리터럴 []과 같다.

```jsx
new Array(); // -> []
```

```jsx
// 전달된 인수가 2개 이상이면 인수를 요소로 갖는 배열을 생성한다.
new Array(1, 2, 3); // -> [1, 2, 3]

// 전달된 인수가 1개지만 숫자가 아니면 인수를 요소로 갖는 배열을 생성한다.
new Array({}); // -> [{}]
```

```jsx
Array(1, 2, 3); // -> [1, 2, 3]
```

## 27.4.3 Array.of

전달된 인수를 요소로 갖는 배열을 생성한다.

ES6에서 도입된 `Array.of` 메서드는 전달된 인수를 요소로 갖는 배열을 생성한다.

```jsx
// 전달된 인수가 1개이고 숫자이더라도 인수를 요소로 갖는 배열을 생성한다.
Array.of(1); // -> [1]

Array.of(1, 2, 3); // -> [1, 2, 3]

Array.of('string'); // -> ['string']
```

## 27.4.4 Array.from

ES6에서 도입된 `Array.from` 메서드는 유사 배열 객체array-like object 또는 이터러블 객체iterable object 를 인수로 전달받아 배열로 변환하여 반환한다.

```jsx
// 유사 배열 객체를 변환하여 배열을 생성한다.
Array.from({ length: 2, 0: 'a', 1: 'b' }); // -> ['a', 'b']

// 이터러블을 변환하여 배열을 생성한다. 문자열은 이터러블이다.
Array.from('Hello'); // -> ['H', 'e', 'l', 'l', 'o']
```

`Array.from`을 사용하면 두 번째 인수로 전달한 콜백 함수를 통해 값을 만들면서 요소를 채울 수 있다. 콜백 함수에 첫 번째 인수에 의해 생성된 배열의 요소값과 인덱스를 순차적으로 전달하면서 호출하고, 콜백 함수의 반환값으로 구성된 배열을 반환한다.

```jsx
// Array.from에 length만 존재하는 유사 배열 객체를 전달하면 undefined를 요소로 채운다.
Array.from({ length: 3 }); // -> [undefined, undefined, undefined]

// Array.from은 두 번째 인수로 전달한 콜백 함수의 반환값으로 구성된 배열을 반환한다.
Array.from({ length: 3 }, (_, i) => i); // -> [0, 1, 2]
```

<aside>
🍀

 **유사 배열 객체와 이터러블 객체**
유사 배열 객체는 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체를 말한다. 유사 배열 객체는 마치 배열처럼 `for` 문으로 순회할 수도 있다.

이터러블 객체는 `for .. of` 문으로 순회할 수 있으며, 스프레드 문법과 배열 디스트럭처링 할당의 대상으로 사용할 수 있는 객체를 말한다. ES6에서 제공하는 빌트인 이터러블은 `Array`, `String`, `Map`, `Set` 등이 있다.

</aside>

# 27.5 배열 요소의 참조

대괄호에 인덱스를 넣어 배열의 요소를 참조한다.

```jsx
const arr = [1, 2];

// 인덱스가 0인 요소를 참조
console.log(arr[0]); // 1
// 인덱스가 1인 요소를 참조
console.log(arr[1]); // 2
```

존재하지 않는 요소에 접근하면 `undefined`가 반환된다.

```jsx
const arr = [1, 2];

// 인덱스가 2인 요소를 참조. 배열 arr에는 인덱스가 2인 요소가 존재하지 않는다.
console.log(arr[2]); // undefined
```

배열은 사실 인덱스를 나타내는 문자열을 프로퍼티 키로 갖는 객체다. 따라서 존재하지 않는 프로퍼티 키로 객체의 프로퍼티에 접근했을 때 `undefined`를 반환하는 것처럼 배열도 존재하지 않는 요소를 참조하면 `undefined`를 반환한다.

```jsx
// 희소 배열
const arr = [1, , 3];

// 배열 arr에는 인덱스가 1인 요소가 존재하지 않는다.
console.log(Object.getOwnPropertyDescriptors(arr));
/*
{
  '0': {value: 1, writable: true, enumerable: true, configurable: true},
  '2': {value: 3, writable: true, enumerable: true, configurable: true},
  length: {value: 3, writable: true, enumerable: false, configurable: false}
*/

// 존재하지 않는 요소를 참조하면 undefined가 반환된다.
console.log(arr[1]); // undefined
console.log(arr[3]); // undefined
```

# 27.6 배열 요소의 추가와 갱신

존재하지 않는 인덱스를 통해 값을 할당하면 새로운 요소가 추가된다.

동시에 length 프로퍼티의 값이 자동 갱신된다.

만약 현재 배열의 `length` 프로퍼티 값보다 큰 인덱스로 새로운 요소를 추가하면 희소 배열이 된다.

```jsx
const arr = [0];

// 배열 요소의 추가
arr[1] = 1;

console.log(arr); // [0, 1]
console.log(arr.length); // 2
```

인덱스(`index`)는 0 이상의 정수여야 한다. 만약 정수 이외의 값을 인덱스처럼 사용하면 요소가 생성되는 것이 아니라 프로퍼티가 추가된다.

```jsx
arr[100] = 100;

console.log(arr); // [0, 1, empty × 98, 100]
console.log(arr.length); // 101
```

```jsx
// 명시적으로 값을 할당하지 않은 요소는 생성되지 않는다.
console.log(Object.getOwnPropertyDescriptors(arr));
/*
{
  '0': {value: 0, writable: true, enumerable: true, configurable: true},
  '1': {value: 1, writable: true, enumerable: true, configurable: true},
  '100': {value: 100, writable: true, enumerable: true, configurable: true},
  length: {value: 101, writable: true, enumerable: false, configurable: false}
*/
```

```jsx
// 요소값의 갱신
arr[1] = 10;

console.log(arr); // [0, 10, empty × 98, 100]
```

# 27.7 배열 요소의 삭제

배열은 사실 객체이기 때문에 배열의 특정 요소를 삭제하기 위해 `delete` 연산자를 사용할 수 있다.

이때 delete는 배열의 `length` 프로퍼티에 영향을 주지 않는다. 즉, 희소 배열이 된다. 따라서 희소 배열을 만드는 delete 연산자는 사용하지 않는 것이 좋다.

희소 배열을 만들지 않으면서 배열의 특정 요소를 완전히 삭제하려면 `Array.prototype.splice` 메서드를 사용한다.

```jsx
const arr = [1, 2, 3];

// 배열 요소의 삭제
delete arr[1];
console.log(arr); // [1, empty, 3]

// length 프로퍼티에 영향을 주지 않는다. 즉, 희소 배열이 된다.
console.log(arr.length); // 3
```

length 프로퍼티에 영향이 없고 희소 배열이 되기 때문에 사용하지 않는 것이 좋다.

Array.prototype.splice 메서드를 사용하는 것이 좋다.’

```jsx
const arr = [1, 2, 3];

// Array.prototype.splice(삭제를 시작할 인덱스, 삭제할 요소 수)
// arr[1]부터 1개의 요소를 제거
arr.splice(1, 1);
console.log(arr); // [1, 3]

// length 프로퍼티가 자동 갱신된다.
console.log(arr.length); // 2
```

# 27.8 배열 메서드

배열이 제공하는 메서드 중 사용 빈도가 높은 메서드에 대해 살펴보도록 하자.

배열 메서드는 결과물을 반환하는 패턴이 두 가지이므로 주의가 필요하다. 

**배열에는 원본 배열(배열 메서드를 호출한 배열, 즉 배열 메서드의 구현체 내부에서 this가 가리키는 객체)을 직접 변경하는 메서드와 원본 배열을 직접 변경하지 않고 새로운 배열을 생성하여 반환하는 메서드가 있다.**

원본 배열을 직접 변경하는 메서드 (mutator method)

원본 배열을 직접 변경하지 않고 새로운 배열을 생성하여 반환하는 메서드 (accessor method)

```jsx
const arr = [1];

// push 메서드는 원본 배열(arr)을 직접 변경한다.
arr.push(2);
console.log(arr); // [1, 2]

// concat 메서드는 원본 배열(arr)을 직접 변경하지 않고 새로운 배열을 생성하여 반환한다.
const result = arr.concat(3);
console.log(arr);    // [1, 2]
console.log(result); // [1, 2, 3]
```

후자를 사용하는 것이 좋다.

## 27.8.1 Array.isArray

전달된 인수가 배열인지 여부를 boolean으로 반환.

```jsx
// true
Array.isArray([]);
Array.isArray([1, 2]);
Array.isArray(new Array());

// false
Array.isArray();
Array.isArray({});
Array.isArray(null);
Array.isArray(undefined);
Array.isArray(1);
Array.isArray('Array');
Array.isArray(true);
Array.isArray(false);
Array.isArray({ 0: 1, length: 1 })
```

## 27.8.2 Array.prototype.indexOf

원본 배열에서 인수로 전달된 요소의 인덱스를 반환.

```jsx
const arr = [1, 2, 2, 3];

// 배열 arr에서 요소 2를 검색하여 첫 번째로 검색된 요소의 인덱스를 반환한다.
arr.indexOf(2);    // -> 1
// 배열 arr에 요소 4가 없으므로 -1을 반환한다.
arr.indexOf(4);    // -> -1
// 두 번째 인수는 검색을 시작할 인덱스다. 두 번째 인수를 생략하면 처음부터 검색한다.
arr.indexOf(2, 2); // -> 2
```

`indexOf` 메서드는 특정 요소가 배열에 존재하는지 확인할 때 유용하지만, ES7에서 도입된 `Array.prototype.includes` 메서드를 사용하면 가독성이 더 좋다.

```jsx
const foods = ['apple', 'banana', 'orange'];

// foods 배열에 'orange' 요소가 존재하는지 확인한다.
if (foods.indexOf('orange') === -1) {
  // foods 배열에 'orange' 요소가 존재하지 않으면 'orange' 요소를 추가한다.
  foods.push('orange');
}

console.log(foods); // ["apple", "banana", "orange"]
```

```jsx
const foods = ['apple', 'banana'];

// foods 배열에 'orange' 요소가 존재하는지 확인한다.
if (!foods.includes('orange')) {
  // foods 배열에 'orange' 요소가 존재하지 않으면 'orange' 요소를 추가한다.
  foods.push('orange');
}

console.log(foods); // ["apple", "banana", "orange"]
```

## 27.8.3 Array.prototype.push

인수를 배열의 마지막 요소로 추가한다.

```jsx
const arr = [1, 2];

// 인수로 전달받은 모든 값을 원본 배열 arr의 마지막 요소로 추가하고 변경된 length 값을 반환한다.
let result = arr.push(3, 4);
console.log(result); // 4

// push 메서드는 원본 배열을 직접 변경한다.
console.log(arr); // [1, 2, 3, 4]
```

push 메서드 보다는 length 프로퍼티로 마지막에 직접 추가하는 것이 더 성능적으로 좋다.

```jsx
const arr = [1, 2];

// arr.push(3)과 동일한 처리를 한다. 이 방법이 push 메서드보다 빠르다.
arr[arr.length] = 3;
console.log(arr); // [1, 2, 3]
```

push 메서드는 원본 배열을 직접 변경하므로 ES6 스프레드 문법을 사용하는 것이 좋다.

```jsx
const arr = [1, 2];

// ES6 스프레드 문법
const newArr = [...arr, 3];
console.log(newArr); // [1, 2, 3]
```

## 27.8.4 Array.prototype.pop

원본 배열에서 마지막 요소를 제거하고 제거한 요소를 반환.

빈 배열이면 undefined를 반환하며, 원본 배열을 직접 변경한다.

```jsx
const arr = [1, 2];

// 원본 배열에서 마지막 요소를 제거하고 제거한 요소를 반환한다.
let result = arr.pop();
console.log(result); // 2

// pop 메서드는 원본 배열을 직접 변경한다.
console.log(arr); // [1]
```

push와 pop을 통해 스택을 구현할 수 있다.

```jsx
const Stack = (function () {
  function Stack(array = []) {
    if (!Array.isArray(array)) {
      // "47. 에러 처리" 참고
      throw new TypeError(`${array} is not an array.`);
    }
    this.array = array;
  }

  Stack.prototype = {
    // "19.10.1. 생성자 함수에 의한 프로토타입의 교체" 참고
    constructor: Stack,
    // 스택의 가장 마지막에 데이터를 밀어 넣는다.
    push(value) {
      return this.array.push(value);
    },
    // 스택의 가장 마지막 데이터, 즉 가장 나중에 밀어 넣은 최신 데이터를 꺼낸다.
    pop() {
      return this.array.pop();
    },
    // 스택의 복사본 배열을 반환한다.
    entries() {
      return [...this.array];
    }
  };

  return Stack;
}());

const stack = new Stack([1, 2]);
console.log(stack.entries()); // [1, 2]

stack.push(3);
console.log(stack.entries()); // [1, 2, 3]

stack.pop();
console.log(stack.entries()); // [1, 2]
```

```jsx
class Stack {
  #array; // private class member

  constructor(array = []) {
    if (!Array.isArray(array)) {
      throw new TypeError(`${array} is not an array.`);
    }
    this.#array = array;
  }

  // 스택의 가장 마지막에 데이터를 밀어 넣는다.
  push(value) {
    return this.#array.push(value);
  }

  // 스택의 가장 마지막 데이터, 즉 가장 나중에 밀어 넣은 최신 데이터를 꺼낸다.
  pop() {
    return this.#array.pop();
  }

  // 스택의 복사본 배열을 반환한다.
  entries() {
    return [...this.#array];
  }
}

const stack = new Stack([1, 2]);
console.log(stack.entries()); // [1, 2]

stack.push(3);
console.log(stack.entries()); // [1, 2, 3]

stack.pop();
console.log(stack.entries()); // [1, 2]
```

## 27.8.5 Array.prototype.unshift

인수를 원본 배열의 선두에 추가.

원본 배열을 직접 변경.

```jsx
const arr = [1, 2];

// 인수로 전달받은 모든 값을 원본 배열의 선두에 요소로 추가하고 변경된 length 값을 반환한다.
let result = arr.unshift(3, 4);
console.log(result); // 4

// unshift 메서드는 원본 배열을 직접 변경한다.
console.log(arr); // [3, 4, 1, 2]
```

역시 ES6의 스프레드 문법을 사용하는 것이 좋다.

```jsx
const arr = [1, 2];

// ES6 스프레드 문법
const newArr = [3, ...arr];
console.log(newArr); // [3, 1, 2]
```

## 27.8.6 Array.prototype.shift

원본 배열에서 첫 번째 요소를 제거하고 제거된 요소를 반환.

원본 배열을 직접 변경.

```jsx
const arr = [1, 2];

// 원본 배열에서 첫 번째 요소를 제거하고 제거한 요소를 반환한다.
let result = arr.shift();
console.log(result); // 1

// shift 메서드는 원본 배열을 직접 변경한다.
console.log(arr); // [2]
```

shift와 push를 통해 큐를 규현할 수 있다.

```jsx
const Queue = (function () {
  function Queue(array = []) {
    if (!Array.isArray(array)) {
      // "47. 에러 처리" 참고
      throw new TypeError(`${array} is not an array.`);
    }
    this.array = array;
  }

  Queue.prototype = {
    // "19.10.1. 생성자 함수에 의한 프로토타입의 교체" 참고
    constructor: Queue,
    // 큐의 가장 마지막에 데이터를 밀어 넣는다.
    enqueue(value) {
      return this.array.push(value);
    },
    // 큐의 가장 처음 데이터, 즉 가장 먼저 밀어 넣은 데이터를 꺼낸다.
    dequeue() {
      return this.array.shift();
    },
    // 큐의 복사본 배열을 반환한다.
    entries() {
      return [...this.array];
    }
  };

  return Queue;
}());

const queue = new Queue([1, 2]);
console.log(queue.entries()); // [1, 2]

queue.enqueue(3);
console.log(queue.entries()); // [1, 2, 3]

queue.dequeue();
console.log(queue.entries()); // [2, 3]
```

```jsx
class Queue {
  #array; // private class member

  constructor(array = []) {
    if (!Array.isArray(array)) {
      throw new TypeError(`${array} is not an array.`);
    }
    this.#array = array;
  }

  // 큐의 가장 마지막에 데이터를 밀어 넣는다.
  enqueue(value) {
    return this.#array.push(value);
  }

  // 큐의 가장 처음 데이터, 즉 가장 먼저 밀어 넣은 데이터를 꺼낸다.
  dequeue() {
    return this.#array.shift();
  }

  // 큐의 복사본 배열을 반환한다.
  entries() {
    return [...this.#array];
  }
}

const queue = new Queue([1, 2]);
console.log(queue.entries()); // [1, 2]

queue.enqueue(3);
console.log(queue.entries()); // [1, 2, 3]

queue.dequeue();
console.log(queue.entries()); // [2, 3]
```

## 27.8.7 Array.prototype.concat

인수로 전달된 값들(배열 또는 원시값)을 원본 배열의 마지막 요소로 추가한 새로운 배열을 반환한다. 이때 원본 배열은 변경되지 않는다.

`push`와 `unshift` 메서드는 `concat` 메서드로 대체할 수 있다. 차이점은 `concat` 메서드는 원본 배열을 변경하지 않고 새로운 배열을 반환하기 때문에 반환값을 반드시 변수에 할당받아야 한다.

값 또는 배열을 인수로 전달받아 원본 배열의 마지막 요소로 추가한 새로운 배열을 반환.

```jsx
const arr1 = [1, 2];
const arr2 = [3, 4];

// 배열 arr2를 원본 배열 arr1의 마지막 요소로 추가한 새로운 배열을 반환한다.
// 인수로 전달한 값이 배열인 경우 배열을 해체하여 새로운 배열의 요소로 추가한다.
let result = arr1.concat(arr2);
console.log(result); // [1, 2, 3, 4]

// 숫자를 원본 배열 arr1의 마지막 요소로 추가한 새로운 배열을 반환한다.
result = arr1.concat(3);
console.log(result); // [1, 2, 3]

// 배열 arr2와 숫자를 원본 배열 arr1의 마지막 요소로 추가한 새로운 배열을 반환한다.
result = arr1.concat(arr2, 5);
console.log(result); // [1, 2, 3, 4, 5]

// 원본 배열은 변경되지 않는다.
console.log(arr1); // [1, 2]
```

새로운 배열을 반환하며 반환값을 반드시 변수에 할당해야 한다.

```jsx
const arr1 = [3, 4];

// unshift 메서드는 원본 배열을 직접 변경한다.
// 따라서 원본 배열을 변수에 저장해 두지 않으면 변경된 배열을 사용할 수 없다.
arr1.unshift(1, 2);
// unshift 메서드를 사용할 경우 원본 배열을 반드시 변수에 저장해 두어야 결과를 확인할 수 있다.
console.log(arr1); // [1, 2, 3, 4]

// push 메서드는 원본 배열을 직접 변경한다.
// 따라서 원본 배열을 변수에 저장해 두지 않으면 변경된 배열을 사용할 수 없다.
arr1.push(5, 6);
// push 메서드를 사용할 경우 원본 배열을 반드시 변수에 저장해 두어야 결과를 확인할 수 있다.
console.log(arr1); // [1, 2, 3, 4, 5, 6]

// unshift와 push 메서드는 concat 메서드로 대체할 수 있다.
const arr2 = [3, 4];

// concat 메서드는 원본 배열을 변경하지 않고 새로운 배열을 반환한다.
// arr1.unshift(1, 2)를 다음과 같이 대체할 수 있다.
let result = [1, 2].concat(arr2);
console.log(result); // [1, 2, 3, 4]

// arr1.push(5, 6)를 다음과 같이 대체할 수 있다.
result = result.concat(5, 6);
console.log(result); // [1, 2, 3, 4, 5, 6]
```

```jsx
const arr = [3, 4];

// unshift와 push 메서드는 인수로 전달받은 배열을 그대로 원본 배열의 요소로 추가한다
arr.unshift([1, 2]);
arr.push([5, 6]);
console.log(arr); // [[1, 2], 3, 4,[5, 6]]

// concat 메서드는 인수로 전달받은 배열을 해체하여 새로운 배열의 요소로 추가한다
let result = [1, 2].concat([3, 4]);
result = result.concat([5, 6]);

console.log(result); // [1, 2, 3, 4, 5, 6]
```

역시 ES6의 스프레드 문법으로 대체할 수 있다.

```jsx
let result = [1, 2].concat([3, 4]);
console.log(result); // [1, 2, 3, 4]

// concat 메서드는 ES6의 스프레드 문법으로 대체할 수 있다.
result = [...[1, 2], ...[3, 4]];
console.log(result); // [1, 2, 3, 4]
```

push, pop, unshift 등의 메서드보다는 ES6의 스프레드 문법을 일관성있게 사용하는 것이 더 좋다.

## 27.8.8 Array.prototype.splice

원본 배열의 중간에 있는 요소를 추가 또는 제거할 경우 사용.

```jsx
const arr = [1, 2, 3, 4];

// 원본 배열의 인덱스 1부터 2개의 요소를 제거하고 그 자리에 새로운 요소 20, 30을 삽입한다.
const result = arr.splice(1, 2, 20, 30);

// 제거한 요소가 배열로 반환된다.
console.log(result); // [2, 3]
// splice 메서드는 원본 배열을 직접 변경한다.
console.log(arr); // [1, 20, 30, 4]
```

```jsx
const arr = [1, 2, 3, 4];

// 원본 배열의 인덱스 1부터 0개의 요소를 제거하고 그 자리에 새로운 요소 100을 삽입한다.
const result = arr.splice(1, 0, 100);

// 원본 배열이 변경된다.
console.log(arr); // [1, 100, 2, 3, 4]
// 제거한 요소가 배열로 반환된다.
console.log(result); // []
```

```jsx
const arr = [1, 2, 3, 4];

// 원본 배열의 인덱스 1부터 2개의 요소를 제거한다.
const result = arr.splice(1, 2);

// 원본 배열이 변경된다.
console.log(arr); // [1, 4]
// 제거한 요소가 배열로 반환된다.
console.log(result); // [2, 3]
```

```jsx
const arr = [1, 2, 3, 4];

// 원본 배열의 인덱스 1부터 모든 요소를 제거한다.
const result = arr.splice(1);

// 원본 배열이 변경된다.
console.log(arr); // [1]
// 제거한 요소가 배열로 반환된다.
console.log(result); // [2, 3, 4]
```

indexOf 로 특정 요소의 인덱스를 알아내어 제거할 수 있다.

```jsx
const arr = [1, 2, 3, 1, 2];

// 배열 array에서 item 요소를 제거한다. item 요소가 여러 개 존재하면 첫 번째 요소만 제거한다.
function remove(array, item) {
  // 제거할 item 요소의 인덱스를 취득한다.
  const index = array.indexOf(item);

  // 제거할 item 요소가 있다면 제거한다.
  if (index !== -1) array.splice(index, 1);

  return array;
}

console.log(remove(arr, 2)); // [1, 3, 1, 2]
console.log(remove(arr, 10)); // [1, 3, 1, 2]
```

중복된 특정 요소를 전부 제거하려면 filter 메서드를 사용할 수 있다.

```jsx
const arr = [1, 2, 3, 1, 2];

// 배열 array에서 모든 item 요소를 제거한다.
function removeAll(array, item) {
  return array.filter(v => v !== item);
}

console.log(removeAll(arr, 2)); // [1, 3, 1]
```

## 27.8.9 Array.prototype.slice

원본 배열의 중간에 요소를 추가하거나 중간에 있는 요소를 제거하는 경우 `splice` 메서드를 사용한다. `splice` 메서드는 3개의 매개변수가 있으며 원본 배열을 직접 변경한다.

- start
    
    원본 배열의 요소를 제거하기 시작할 인덱스다. `start`만 지정하면 원본 배열의 `start`부터 모든 요소를 제거한다.
    
- deleteCount
    
    원본 배열의 요소를 제거하기 시작할 인덱스인 start부터 제거할 요소의 개수다.(옵션)
    
- items
    
    제거한 위치에 삽입할 요소들의 목록이다. 생략할 경우 원본 배열에서 요소들을 제거하기만 한다.(옵션)
    

```jsx
const arr = [1, 2, 3];

// arr[0]부터 arr[1] 이전(arr[1] 미포함)까지 복사하여 반환한다.
arr.slice(0, 1); // -> [1]

// arr[1]부터 arr[2] 이전(arr[2] 미포함)까지 복사하여 반환한다.
arr.slice(1, 2); // -> [2]

// 원본은 변경되지 않는다.
console.log(arr); // [1, 2, 3]
```

```jsx
const arr = [1, 2, 3];

// arr[1]부터 이후의 모든 요소를 복사하여 반환한다.
arr.slice(1); // -> [2, 3]
```

```jsx
const arr = [1, 2, 3];

// 배열의 끝에서부터 요소를 한 개 복사하여 반환한다.
arr.slice(-1); // -> [3]

// 배열의 끝에서부터 요소를 두 개 복사하여 반환한다.
arr.slice(-2); // -> [2, 3]
```

```jsx
const arr = [1, 2, 3];

// 인수를 모두 생략하면 원본 배열의 복사본을 생성하여 반환한다.
const copy = arr.slice();
console.log(copy); // [1, 2, 3]
console.log(copy === arr); // false
```

```jsx
const todos = [
  { id: 1, content: 'HTML', completed: false },
  { id: 2, content: 'CSS', completed: true },
  { id: 3, content: 'Javascript', completed: false }
];

// 얕은 복사(shallow copy)
const _todos = todos.slice();
// const _todos = [...todos];

// _todos와 todos는 참조값이 다른 별개의 객체다.
console.log(_todos === todos); // false

// 배열 요소의 참조값이 같다. 즉, 얕은 복사되었다.
console.log(_todos[0] === todos[0]); // true
```

## 27.8.10 Array.prototype.join

원본 배열의 요소를 문자로 변환하고 인수로 전달 받은 문자열을 구분자로 연결하여 반환.

```jsx
const arr = [1, 2, 3, 4];

// 기본 구분자는 ','이다.
// 원본 배열 arr의 모든 요소를 문자열로 변환한 후, 기본 구분자 ','로 연결한 문자열을 반환한다.
arr.join(); // -> '1,2,3,4';

// 원본 배열 arr의 모든 요소를 문자열로 변환한 후, 빈문자열로 연결한 문자열을 반환한다.
arr.join(''); // -> '1234'

// 원본 배열 arr의 모든 요소를 문자열로 변환한 후, 구분자 ':'로 연결한 문자열을 반환한다.ㄴ
arr.join(':'); // -> '1:2:3:4'
```

## 27.8.11 Array.prototype.reverse

원본 배열의 순서를 반대로 뒤집으며 원본 배열이 변경된다.

```jsx
const arr = [1, 2, 3];
const result = arr.reverse();

// reverse 메서드는 원본 배열을 직접 변경한다.
console.log(arr); // [3, 2, 1]
// 반환값은 변경된 배열이다.
console.log(result); // [3, 2, 1]
```

## 27.8.12 Array.prototype.fill

ES6에서부터 도입.

인수로 전달받은 값으로 배열의 처음부터 끝까지 변경.

```jsx
const arr = [1, 2, 3];

// 인수로 전달 받은 값 0을 배열의 처음부터 끝까지 요소로 채운다.
arr.fill(0);

// fill 메서드는 원본 배열을 직접 변경한다.
console.log(arr); // [0, 0, 0]
```

```jsx
const arr = [1, 2, 3];

// 인수로 전달받은 값 0을 배열의 인덱스 1부터 끝까지 요소로 채운다.
arr.fill(0, 1);

// fill 메서드는 원본 배열을 직접 변경한다.
console.log(arr); // [1, 0, 0]
```

```jsx
const arr = [1, 2, 3, 4, 5];

// 인수로 전달받은 값 0을 배열의 인덱스 1부터 3 이전(인덱스 3 미포함)까지 요소로 채운다.
arr.fill(0, 1, 3);

// fill 메서드는 원본 배열을 직접 변경한다.
console.log(arr); // [1, 0, 0, 4, 5]
```

```jsx
const arr = new Array(3);
console.log(arr); // [empty × 3]

// 인수로 전달받은 값 1을 배열의 처음부터 끝까지 요소로 채운다.
const result = arr.fill(1);

// fill 메서드는 원본 배열을 직접 변경한다.
console.log(arr); // [1, 1, 1]

// fill 메서드는 변경된 원본 배열을 반환한다.
console.log(result); // [1, 1, 1]
```

Array.from 메서드와 함께 사용할 경우 새로운 배열을 만들면서 요소를 채울 수 있다.

```jsx
// 인수로 전달받은 정수만큼 요소를 생성하고 0부터 1씩 증가하면서 요소를 채운다.
const sequences = (length = 0) => Array.from({ length }, (_, i) => i);
// const sequences = (length = 0) => Array.from(new Array(length), (_, i) => i);

console.log(sequences(3)); // [0, 1, 2]
```

## 27.8.13 Array.prototype.includes

배열 내에 특정 요소가 포함되어 있는지 확인하여 true 또는 false 반환.

```jsx
const arr = [1, 2, 3];

// 배열에 요소 2가 포함되어 있는지 확인한다.
arr.includes(2); // -> true

// 배열에 요소 100이 포함되어 있는지 확인한다.
arr.includes(100); // -> false
```

```jsx
const arr = [1, 2, 3];

// 배열에 요소 1이 포함되어 있는지 인덱스 1부터 확인한다.
arr.includes(1, 1); // -> false

// 배열에 요소 3이 포함되어 있는지 인덱스 2(arr.length - 1)부터 확인한다.
arr.includes(3, -1); // -> true
```

```jsx
[NaN].indexOf(NaN) !== -1; // -> false
[NaN].includes(NaN);       // -> true
```

## 27.8.14 Array.prototype.flat

인수로 전달한 깊이 만큼 재귀적으로 배열을 평탄화.

```jsx
[1, [2, 3, 4, 5]].flat(); // -> [1, 2, 3, 4, 5]
```

```jsx
// 중첩 배열을 평탄화하기 위한 깊이 값의 기본값은 1이다.
[1, [2, [3, [4]]]].flat();  // -> [1, 2, [3, [4]]]
[1, [2, [3, [4]]]].flat(1); // -> [1, 2, [3, [4]]]

// 중첩 배열을 평탄화하기 위한 깊이 값을 2로 지정하여 2단계 깊이까지 평탄화한다.
[1, [2, [3, [4]]]].flat(2); // -> [1, 2, 3, [4]]
// 2번 평탄화한 것과 동일하다.
[1, [2, [3, [4]]]].flat().flat(); // -> [1, 2, 3, [4]]

// 중첩 배열을 평탄화하기 위한 깊이 값을 Infinity로 지정하여 중첩 배열 모두를 평탄화한다.
[1, [2, [3, [4]]]].flat(Infinity); // -> [1, 2, 3, 4]
```

# 27.9 배열 고차 함수

> 고차 함수 (Higher-Order Function, HOF)
> 
> 
> 함수를 인수로 전달받거나 함수를 반환하는 함수.
> 

외부 상태의 변경이나 가변 데이터를 피하고, 불변성을 지향하는 함수형 프로그래밍에 기반.

## 22.9.1 Array.prototype.sort

배열의 요소를 정렬.

```jsx
const fruits = ['Banana', 'Orange', 'Apple'];

// 오름차순(ascending) 정렬
fruits.sort();

// sort 메서드는 원본 배열을 직접 변경한다.
console.log(fruits); // ['Apple', 'Banana', 'Orange']
```

```jsx
const fruits = ['바나나', '오렌지', '사과'];

// 오름차순(ascending) 정렬
fruits.sort();

// sort 메서드는 원본 배열을 직접 변경한다.
console.log(fruits); // ['바나나', '사과', '오렌지']
```

sort와 reverse를 사용하여 내림차순 정렬 가능.

```jsx
const fruits = ['Banana', 'Orange', 'Apple'];

// 오름차순(ascending) 정렬
fruits.sort();

// sort 메서드는 원본 배열을 직접 변경한다.
console.log(fruits); // ['Apple', 'Banana', 'Orange']

// 내림차순(descending) 정렬
fruits.reverse();

// reverse 메서드도 원본 배열을 직접 변경한다.
console.log(fruits); // ['Orange', 'Banana', 'Apple']
```

sort의 기본 정렬 순서는 유니코드 코드 포인트의 순서를 따른다.

배열의 요소를 일시적으로 문자열로 변환한 후 정렬하는데 숫자의 경우 의도치 않은 결과가 나올 수 있다.

따라서 숫자 정렬 시 정렬 순서를 정의하는 비교 함수를 인수로 전달해야 한다.

양수, 음수, 0을 반환할 수 있다.

양수 ⇒ 두 번째 인수를 우선시.

음수 ⇒ 첫 번째 인수를 우선시.

0 ⇒ 정렬하지 않는다.

```jsx
const points = [40, 100, 1, 5, 2, 25, 10];

// 숫자 배열의 오름차순 정렬. 비교 함수의 반환값이 0보다 작으면 a를 우선하여 정렬한다.
points.sort((a, b) => a - b);
console.log(points); // [1, 2, 5, 10, 25, 40, 100]

// 숫자 배열에서 최소/최대값 취득
console.log(points[0], points[points.length]); // 1

// 숫자 배열의 내림차순 정렬. 비교 함수의 반환값이 0보다 작으면 b를 우선하여 정렬한다.
points.sort((a, b) => b - a);
console.log(points); // [100, 40, 25, 10, 5, 2, 1]

// 숫자 배열에서 최대값 취득
console.log(points[0]); // 100
```

```jsx
const todos = [
  { id: 4, content: 'JavaScript' },
  { id: 1, content: 'HTML' },
  { id: 2, content: 'CSS' }
];

// 비교 함수. 매개변수 key는 프로퍼티 키다.
function compare(key) {
  // 프로퍼티 값이 문자열인 경우 - 산술 연산으로 비교하면 NaN이 나오므로 비교 연산을 사용한다.
  // 비교 함수는 양수/음수/0을 반환하면 되므로 - 산술 연산 대신 비교 연산을 사용할 수 있다.
  return (a, b) => (a[key] > b[key] ? 1 : (a[key] < b[key] ? -1 : 0));
}

// id를 기준으로 오름차순 정렬
todos.sort(compare('id'));
console.log(todos);
/*
[
  { id: 1, content: 'HTML' },
  { id: 2, content: 'CSS' },
  { id: 4, content: 'JavaScript' }
]
*/

// content를 기준으로 오름차순 정렬
todos.sort(compare('content'));
console.log(todos);
/*
[
  { id: 2, content: 'CSS' },
  { id: 1, content: 'HTML' },
  { id: 4, content: 'JavaScript' }
]
*/
```

## 27.9.2 Array.prototype.forEach

for 문을 대체할 수 잇는 고차 함수.

내부에서 반복문을 통해 자신을 호출한 배열을 순회한다.

수행해야 할 처리를 콜백 함수로 전달받아 반복적으로 호출한다.

```jsx
const numbers = [1, 2, 3];
let pows = [];

// forEach 메서드는 numbers 배열의 모든 요소를 순회하면서 콜백 함수를 반복 호출한다.
numbers.forEach(item => pows.push(item ** 2));
console.log(pows); // [1, 4, 9]
```

```jsx
// forEach 메서드는 콜백 함수를 호출하면서 3개(요소값, 인덱스, this)의 인수를 전달한다.
[1, 2, 3].forEach((item, index, arr) => {
  console.log(`요소값: ${item}, 인덱스: ${index}, this: ${JSON.stringify(arr)}`);
});
/*
요소값: 1, 인덱스: 0, this: [1,2,3]
요소값: 2, 인덱스: 1, this: [1,2,3]
요소값: 3, 인덱스: 2, this: [1,2,3]
*/
```

<aside>
🍀

**JSON.stringify 메서드**

`JSON.stringify` 메서드는 객체를 JSON 포맷의 문자열로 변환한다. 위 예제에선 객체인 `arr` 배열을 문자열로 출력하기 위해 사용했다

</aside>

```jsx
const numbers = [1, 2, 3];

// forEach 메서드는 원본 배열을 변경하지 않지만 콜백 함수를 통해 원본 배열을 변경할 수는 있다.
// 콜백 함수의 세 번째 매개변수 arr은 원본 배열 numbers를 가리킨다.
// 따라서 콜백 함수의 세 번째 매개변수 arr을 직접 변경하면 원본 배열 numbers가 변경된다.
numbers.forEach((item, index, arr) => { arr[index] = item ** 2; });
console.log(numbers); // [1, 4, 9]
```

```jsx
const result = [1, 2, 3].forEach(console.log);
console.log(result); // undefined
```

ES6의 화살표 함수와 같이 사용하면 this의 바인딩 이슈도 깔끔하게 해결하면서 사용할 수 있다.

```jsx
class Numbers {
  numberArray = [];

  multiply(arr) {
    // 화살표 함수 내부에서 this를 참조하면 상위 스코프의 this를 그대로 참조한다.
    arr.forEach(item => this.numberArray.push(item * item));
  }
}

const numbers = new Numbers();
numbers.multiply([1, 2, 3]);
console.log(numbers.numberArray); // [1, 4, 9]
```

forEach문은 함수이기 때문에 return 으로 탈출할 수 있다.

```jsx
[1, 2, 3].forEach(item => {
  console.log(item);
  if (item > 1) break; // SyntaxError: Illegal break statement
});

[1, 2, 3].forEach(item => {
  console.log(item);
  if (item > 1) continue;
  // SyntaxError: Illegal continue statement: no surrounding iteration statement
});
```

`forEach` 메서드는 원본 배열을 변경하지 않는다. forEach 메서드도 내부에서는 반복문(for 문)을 통해 배열을 순회할 수밖에 없다. 단, 반복문을 메서드 내부로 은닉하여 로직의 흐름을 이해하기 쉽게 하고 복잡성을 해결한다.

`forEach` 메서드는 for 문과는 달리 `break`, `continue` 문을 사용할 수 없다. 다시 말해, 배열의 모든 요소를 빠짐없이 모두 순회하며 중간에 순회를 중단할 수 없다.

## 27.9.3 Array.prototype.map

자신을 호출한 배열을 순회하면서 콜백 함수의 반환값들로 구성된 새로운 배열을 반환한다.

```jsx
const numbers = [1, 4, 9];

// map 메서드는 numbers 배열의 모든 요소를 순회하면서 콜백 함수를 반복 호출한다.
// 그리고 콜백 함수의 반환값들로 구성된 새로운 배열을 반환한다.
const roots = numbers.map(item => Math.sqrt(item));

// 위 코드는 다음과 같다.
// const roots = numbers.map(Math.sqrt);

// map 메서드는 새로운 배열을 반환한다
console.log(roots);   // [ 1, 2, 3 ]
// map 메서드는 원본 배열을 변경하지 않는다
console.log(numbers); // [ 1, 4, 9 ]
```

map 메서드가 반환한 새로운 배열은 기존의 배열과 반드시 1대1 매핑된다.

```jsx
// map 메서드는 콜백 함수를 호출하면서 3개(요소값, 인덱스, this)의 인수를 전달한다.
[1, 2, 3].map((item, index, arr) => {
  console.log(`요소값: ${item}, 인덱스: ${index}, this: ${JSON.stringify(arr)}`);
  return item;
});
/*
요소값: 1, 인덱스: 0, this: [1,2,3]
요소값: 2, 인덱스: 1, this: [1,2,3]
요소값: 3, 인덱스: 2, this: [1,2,3]
*/
```

## 27.9.4 Array.prototype.filter

`filter` 메서드는 자신을 호출한 배열의 모든 요소를 순회하면서 인수로 전달받은 콜백 함수를 반복 호출한다. 그리고 **콜백 함수의 반환값이 `true`인 요소로만 구성된 새로운 배열을 반환한다.** 이때 원본 배열은 변경되지 않는다.

```jsx
const numbers = [1, 2, 3, 4, 5];

// filter 메서드는 numbers 배열의 모든 요소를 순회하면서 콜백 함수를 반복 호출한다.
// 그리고 콜백 함수의 반환값이 true인 요소로만 구성된 새로운 배열을 반환한다.
// 다음의 경우 numbers 배열에서 홀수인 요소만을 필터링한다(1은 true로 평가된다).
const odds = numbers.filter(item => item % 2);
console.log(odds); // [1, 3, 5]
```

`forEach`, `map` 메서드와 마찬가지로 `filter` 메서드의 콜백 함수는 해당 메서드를 호출한 배열의 요소값과 인덱스, `filter` 메서드를 호출한 배열 자체, 즉 `this`를 순차적으로 전달받을 수 있다.

map과 달리 filter가 반환한 새로운 배열은 기존의 배열과 길이가 다를 수 있다.

## 27.9.5 Array.prototype.reduce

자신을 호출한 배열을 순회하면서 콜백 함수를 호출한다.

콜백 함수의 반환값은 다음 순회에서의 콜백 함수의 첫 번째 인수로 전달된다.

이런식으로 순회하면서 **최종적으로는 하나의 결과값을 반환**한다.

```jsx
// [1, 2, 3, 4]의 모든 요소의 누적을 구한다.
const sum = [1, 2, 3, 4].reduce((accumulator, currentValue, index, array) => accumulator + currentValue, 0);

console.log(sum); // 10
```

reduce 메서드는 다양한 방법으로 사용할 수 있다.

**평균 구하기**

```jsx
const values = [1, 2, 3, 4, 5, 6];

const average = values.reduce((acc, cur, i, { length }) => {
  // 마지막 순회가 아니면 누적값을 반환하고 마지막 순회면 누적값으로 평균을 구해 반환한다.
  return i === length - 1 ? (acc + cur) / length : acc + cur;
}, 0);

console.log(average); // 3.5
```

**최대값 구하기**

```jsx
const values = [1, 2, 3, 4, 5];

const max = values.reduce((acc, cur) => (acc > cur ? acc : cur), 0);
console.log(max); // 5
```

**요소의 중복 횟수 구하기**

```jsx
const fruits = ['banana', 'apple', 'orange', 'orange', 'apple'];

const count = fruits.reduce((acc, cur) => {
  // 첫 번째 순회 시 acc는 초기값인 {}이고 cur은 첫 번째 요소인 'banana'다.
  // 초기값으로 전달받은 빈 객체에 요소값인 cur을 프로퍼티 키로, 요소의 개수를 프로퍼티 값으로
  // 할당한다. 만약 프로퍼티 값이 undefined(처음 등장하는 요소)이면 프로퍼티 값을 1로 초기화한다.
  acc[cur] = (acc[cur] || 0) + 1;
  return acc;
}, {});

// 콜백 함수는 총 5번 호출되고 다음과 같이 결과값을 반환한다.
/*
{banana: 1} => {banana: 1, apple: 1} => {banana: 1, apple: 1, orange: 1}
=> {banana: 1, apple: 1, orange: 2} => {banana: 1, apple: 2, orange: 2}
*/

console.log(count); // { banana: 1, apple: 2, orange: 2 }
```

**중첩 배열 평탄화**

```jsx
const values = [1, [2, 3], 4, [5, 6]];

const flatten = values.reduce((acc, cur) => acc.concat(cur), []);
// [1] => [1, 2, 3] => [1, 2, 3, 4] => [1, 2, 3, 4, 5, 6]

console.log(flatten); // [1, 2, 3, 4, 5, 6]
```

```jsx
[1, [2, 3, 4, 5]].flat(); // -> [1, 2, 3, 4, 5]

// 인수 2는 중첩 배열을 평탄화하기 위한 깊이 값이다.
[1, [2, 3, [4, 5]]].flat(2); // -> [1, 2, 3, 4, 5]
```

**중복 요소 제거**

```jsx
const values = [1, 2, 1, 3, 5, 4, 5, 3, 4, 4];

const result = values.reduce(
  (unique, val, i, _values) =>
    // 현재 순회 중인 요소의 인덱스 i가 val의 인덱스와 같다면 val은 처음 순회하는 요소다.
    // 현재 순회 중인 요소의 인덱스 i가 val의 인덱스와 다르다면 val은 중복된 요소다.
    // 처음 순회하는 요소만 초기값 []가 전달된 unique 배열에 담아 반환하면 중복된 요소는 제거된다.
    _values.indexOf(val) === i ? [...unique, val] : unique,
  []
);

console.log(result); // [1, 2, 3, 5, 4]
```

## 27.9.6 Array.prototype.some

자신을 호출한 배열을 순회하면서 콜백 함수를 호출한다.

콜백 함수 반환값이 단 한 번이라도 참이면 true, 거짓이면 false를 반환한다.

```jsx
// 배열의 요소 중에 10보다 큰 요소가 1개 이상 존재하는지 확인
[5, 10, 15].some(item => item > 10); // -> true

// 배열의 요소 중에 0보다 작은 요소가 1개 이상 존재하는지 확인
[5, 10, 15].some(item => item < 0); // -> false

// 배열의 요소 중에 'banana'가 1개 이상 존재하는지 확인
['apple', 'banana', 'mango'].some(item => item === 'banana'); // -> true

// some 메서드를 호출한 배열이 빈 배열인 경우 언제나 false를 반환한다.
[].some(item => item > 3); // -> false
```

## 27.9.7 Array.prototype.every

자신을 호출한 배열을 순회하면서 콜백 함수를 호출한다.

콜백 함수 반환값이 모두 참이면 true, 거짓이면 false를 반환한다.

```jsx
// 배열의 모든 요소가 3보다 큰지 확인
[5, 10, 15].every(item => item > 3); // -> true

// 배열의 모든 요소가 10보다 큰지 확인
[5, 10, 15].every(item => item > 10); // -> false

// every 메서드를 호출한 배열이 빈 배열인 경우 언제나 true를 반환한다.
[].every(item => item > 3); // -> true
```

## 27.9.8 Array.prototype.find

자신을 호출한 배열을 순회하면서 콜백 함수를 호출하면서 반환값이 true인 첫 번째 요소를 반환한다.

```jsx
const users = [
  { id: 1, name: 'Lee' },
  { id: 2, name: 'Kim' },
  { id: 2, name: 'Choi' },
  { id: 3, name: 'Park' }
];

// id가 2인 첫 번째 요소를 반환한다. find 메서드는 배열이 아니라 요소를 반환한다.
users.find(user => user.id === 2); // -> {id: 2, name: 'Kim'}
```

```jsx
// Array#filter는 배열을 반환한다.
[1, 2, 2, 3].filter(item => item === 2); // -> [2, 2]

// Array#find는 요소를 반환한다.
[1, 2, 2, 3].find(item => item === 2); // -> 2
```

## 27.9.9 Array.prototype.findIndex

자신을 호출한 배열을 순회하면서 콜백 함수를 호출하면서 반환값이 true인 첫 번째 요소의 인덱스를 반환한다.

```jsx
const users = [
  { id: 1, name: 'Lee' },
  { id: 2, name: 'Kim' },
  { id: 2, name: 'Choi' },
  { id: 3, name: 'Park' }
];

// id가 2인 요소의 인덱스를 구한다.
users.findIndex(user => user.id === 2); // -> 1

// name이 'Park'인 요소의 인덱스를 구한다.
users.findIndex(user => user.name === 'Park'); // -> 3

// 위와 같이 프로퍼티 키와 프로퍼티 값으로 요소의 인덱스를 구하는 경우
// 다음과 같이 콜백 함수를 추상화할 수 있다.
function predicate(key, value) {
  // key와 value를 기억하는 클로저를 반환
  return item => item[key] === value;
}

// id가 2인 요소의 인덱스를 구한다.
users.findIndex(predicate('id', 2)); // -> 1

// name이 'Park'인 요소의 인덱스를 구한다.
users.findIndex(predicate('name', 'Park')); // -> 3
```

## 27.9.10 Array.prototype.flatMap

map 메서드를 통해 생성된 새로운 배열을 평탄화한다.

즉, map 메서드와 flat 메서드를 순차적으로 실행한다.

```jsx
const arr = ['hello', 'world'];

// map과 flat을 순차적으로 실행
arr.map(x => x.split('')).flat();
// -> ['h', 'e', 'l', 'l', 'o', 'w', 'o', 'r', 'l', 'd']

// flatMap은 map을 통해 생성된 새로운 배열을 평탄화한다.
arr.flatMap(x => x.split(''));
// -> ['h', 'e', 'l', 'l', 'o', 'w', 'o', 'r', 'l', 'd']
```

```jsx
const arr = ['hello', 'world'];

// flatMap은 1단계만 평탄화한다.
arr.flatMap((str, index) => [index, [str, str.length]]);
// -> [[0, ['hello', 5]], [1, ['world', 5]]] => [0, ['hello', 5], 1, ['world', 5]]

// 평탄화 깊이를 지정해야 하면 flatMap 메서드를 사용하지 말고 map 메서드와 flat 메서드를 각각 호출한다.
arr.map((str, index) => [index, [str, str.length]]).flat(2);
// -> [[0, ['hello', 5]], [1, ['world', 5]]] => [0, 'hello', 5, 1, 'world', 5]
```