### 3주차 질문

arguments 객체는 가변 인자 함수를 구현할 때 유용한데, 인수의 개수를 지정해야 줘야하는 타입스크립트에서는 필요가 없는지? (ch18)

ES6의 클래스 문법과 프로토타입 기반 상속의 차이점은? (ch19)

---

# CH 15 let,const 키워드와 블록레벨 스코프

---

### var 키워드로 선언한 변수의 문제점

- 변수 중복 선언 가능
- 함수의 코드 블록만을 지역 스코프로 인정
- 함수 외부에서 선언한 변수는 코드 블록 내에서 선언해도 전역 변수가 됨
- 변수 호이스팅 발생

```javascript
var x = 1;

if (true) {
  // x 는 전역변수로 선언이 되었으므로 코드 블록 내에서 선언하더라도 전역 변수가 됨
  // 따라서 변수 값이 의도치 않게 변경 됨
  x = 10;
}

console.log(x); // 10
```

```javascript
console.log(foo); //undefined

// 변수에 값을 할당
foo = 123;

console.log(foo); // 123

// 변수 선언은 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 실행
var foo;
```

> 변수 호이스팅은 가독성을 떨어뜨리고 오류를 발생시킬 여지를 남긴다

### let의 특징

- 변수 중복 선언 금지 : let 키워드로 변수를 중복 선언하면 문법 에러 발생
- 블록 레벨 스코프 : 모든 코드 블록을 지역 스코프로 인정하는 블록 레벨 스코프를 따름
- 변수 호이스팅 발생하지 않는 것 처럼 동작

```javascript
let foo = 1; // 전역 변수

{
  let foo = 2; // 지역 변수
  let bar = 3; // 지역 변수
}

console.log(foo); // 1
console.log(bar); // ReferenceError
```

**함수 내의 코드 블록은 함수 레벨 스코프에 중첩**

```javascript
// 런타임 이전에 선언 단계 실행, 아직 변수가 초기화 되지 않음
// 초기화 이전의 일시적 사각지대에서는 변수 참조 불가
console.log(foo); //undefined

foo = 1; // 할당문에서 할당 단계 실행
console.log(foo); // 1
}
```

#### 일시적 사각지대 : 스코프의 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간

하지만 let 키워드로 선언한 변수도 여전히 호이스팅이 발생
자바스크립트는 ES6에서 도입된 let const를 포함한 모든 선언을 호이스팅하기 때문

### var과 let의 전역객체

- var 키워드로 선언한 전역 변수와 전역 함수, 암묵적 전역은 전역 객체 window의 프로퍼티가 됨
- let 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니므로 전역 객체에 접근 불가 / let의 전역 변수는 보이지 않는 개념적인 블록 내에 존재

### const : 상수를 선언하기 위해 사용 (재할당이 금지된 변수)

- const 키워드로 선언한 변수는 let 키워드로 선언한 변수와 마찬가지로 블록 레벨 스코프를 가지며 변수 호이스팅이 발생하지 않는 것처럼 동작함
- const 키워드로 선언된 변수에 원시 값을 할당한 경우 원시 값은 변경할 수 없는 값이고 const 키워드에 의해 재할당이 금지되므로 할당된 값을 변경할 수 없음
- const 키워드로 선언된 변수에 객체를 할당한 경우에는 값을 변경할 수 있음

### var vs let vs const

- ES6 사용 시 var는 사용하지 않는다
- 재할당이 필요한 경우 let을 사용한다. 이때 변수의 스코프는 최대한 좁게 만든다.
- 변경이 발생하지 않고 읽기 전용 원시 값과 객체는 const를 사용한다.

> 일단 선언 후 재할당이 필요하다면 let으로 변경

# CH 16 프로퍼티 어트리뷰트

---

### 내부 슬롯과 내부 메서드

자바스크립트 엔진의 구현 알고리즘을 설명하기 위한 의사 프로퍼티와 의사 메서드 : 이중 대괄호로 감싼 이름

\*\*내부 슬롯과 내부 메서드는 자바스크립트 엔진의 내부 로직이므로 원칙적으로 자바스크립트는 내부 슬롯과 내부 메서드에 직접 접근하거나 호출할 수 있는 방법을 제공하지 않음 / 일부 내부 슬롯과 내부 메서드에 간접적으로 접근할 수 있는 방법 제공

```javascript
const o = {};

o.[[prototype]] // Uncaught SyntaxError

o.__proto__ // object.prototype
```

#### 자바스크립트 엔진은 프로퍼티를 생성할 때 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의한다.

**프로퍼티 상태**

- 프로퍼티 값의 갱신 가능 여부
- 프로퍼티 값의 열거 가능 여부
- 프로퍼티 값의 재정의 가능 여부

**프로퍼티 어트리뷰트**

- 내부슬롯 [[Writable]], [[Enumerable]], [[configurable]]
- 직접 접근은 불가능하나 Object.getOwnPropertyDescriptor 메서드를 사용하여 간접적으로 확인 가능

### Object.getOwnPropertyDescriptor

- 첫 번째 매개변수에는 객체의 참조 전달
- 두 번쨰 매개변수에는 프로퍼티 키를 문자열로 전달
- 프로퍼티 디스크립터 객체 반환
- 존재하지 않는 프로퍼티나 상속받은 프로퍼티에 대한 프로퍼티 디스크립터를 요구하면 undefined 반환

#### Object.getOwnPropertyDescriptor 메서드는 하나의 프로퍼티에 대해 프로퍼티 디스크립터 객체를 반환하지만 ES8에서 도입된 Object.getOwnPropertyDescriptors는 모든 프로퍼티의 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크립터 객체들을 반환

### 데이터 프로퍼티

키와 값으로 구성된 일반적인 프로퍼티

**데이터 프로퍼티의 어트리뷰트**

| 프로퍼티 어트리뷰트 | 프로퍼티 디스크릡터 객체의 프로퍼티 | 설명                                                                                                              |
| :------------------ | :---------------------------------- | :---------------------------------------------------------------------------------------------------------------- |
| [[Value]]           | value                               | -프로퍼티 키를 통에 값에 접근하면 반환됨 <br> - 프로퍼티 키를 통해 프로퍼티 값을 변경하면 [[Value]]에 값을 재할당 |
| [[Writable]]        | writable                            | - 프로퍼티 값의 변경 가능 여부(불리언 값) <br> - [Writable] 값이 false인 경우 읽기 전용 프로퍼티로 변경           |
| [[Enumerable]]      | enumerable                          | - 프로퍼티 값의 열거 가능 여부(불리언 값) <br> -값이 false인 경우 열거 불가                                       |
| [[Configurable]]    | configurable                        | -프로퍼티 값의 재정의 가능 여부 <br> - 값이 false인 경우 프로퍼티의 어트리뷰트 값 변경 불가                       |

프로퍼티가 생성될 때 [[Value]]의 값은 프로퍼티 값으로 초기화되며 [[Writable]],[[Enumerable]], [[Configurable]]의 값은 true로 초기화 된다.

### 접근자 프로퍼티

자체적으로는 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 호출되는 접근자 함수로 구성된 프로퍼티

| 프로퍼티 어트리뷰트 | 프로퍼티 디스크릡터 객체의 프로퍼티 | 설명                                                                                                                                             |
| :------------------ | :---------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------- |
| [[Get]]             | get                                 | -접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 읽을 때 호출되는 접근자 함수 <br> -접근자 프로퍼티 키로 프로퍼티 값에 접근하면 getter 함수 호출   |
| [[Set]]             | set                                 | -접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 저장할 때 호출되는 접근자 함수 <br> -접근자 프로퍼티 키로 프로퍼티 값을 저장하면 setter 함수 호출 |

> - 접근자 프로퍼티는 getter와 setter 함수를 모두 정의할 수 도 있고 하나만 정리할 수도 있다.

- 접근자 프로퍼티는 자체적으로 값을 가지지 않으며 데이터 프로퍼티의 값을 읽거나 저장할 때 관여할 뿐이다

**접근자 프로퍼티와 데이터 프로퍼티 구별 방법**

```javascript
// 일반 객체와 __proto__는 접근자 프로퍼티이다
Object.getOwnPropertyDescriptor(Object.prototype, '__proto__');
// get: f set: f enumerable: false, configurable: true

// 함수 객체의 prototype은 데이터 프로퍼티다.
Object.getOwnPropertyDescriptor(function () {}, 'prototype');
// value: {...}, writable: true, enumerable: false, configurable: false
```

### 프로퍼티 정의

새로운 프로퍼티를 추가하면서 프로퍼티 어트리뷰트를 명시적으로 정의하거나, 기존 프로퍼티의 프로퍼티 어트리뷰트를 재정의 하는 것

**ObjectdefineProperty 메서드 사용**

- 인수로 객체의 참조와 데이터 프로퍼티의 키인 문자열, 프로퍼티 디스크립터 객체 전달
- 한 번에 하나의 프로퍼티만 정의 가능 / Object.defineProperties 메서드 사용 시 여러개의 프로퍼티를 한 번에 정의 가능

| 프로퍼티 디스크립터 객체의 프로퍼티 | 대응하는 프로퍼티 어트리뷰트 | 생략했을 때의 기본 값 |
| :---------------------------------- | :--------------------------- | :-------------------- |
| value                               | [[Value]]                    | undefined             |
| get                                 | [[Get]]                      | undefined             |
| set                                 | [[Set]]                      | undefined             |
| writable                            | [[Writable]]                 | false                 |
| enumerable                          | [[Enumerable]]               | false                 |
| configurable                        | [[Configurable]]             | false                 |

### 객체 변경 방지 (얕은 변경 방지)

객체는 변경 가능한 값이므로 재할당 없이 변경 가능 -> 자바스크립트에서 객체의 변경을 방지하는 다양한 메서드 제공

- **객체 확장 금지**
  - Object.preventExtensions
  - 프로퍼티 추가 금지
- **객체 밀봉**
  - Object.seal
  - 프로퍼티 추가 및 삭제, 프로퍼티 어트리뷰트 재정의 금지
  - 밀봉된 객체는 **읽기와 쓰기만 가능**
- **객체 동결**
  - Object.freeze
  - 프로퍼티 추가 및 삭제, 프로퍼티 어트리뷰드 재정의 금지, 프로퍼티 값 갱신 금지
  - 동결된 객체는 **읽기만 가능**

# CH17 생성자 함수에 의한 객체 생성

---

### 생성자 함수

new 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수

#### 인스턴스 : 생성자 함수에 의해 생성된 객체

### Object 생성자 함수

new 연산자와 함께 Object 생성자 함수를 호출하여 빈 객체를 생성하여 반환

```javascript
// 빈 객체 생성
const person = new Object();

// 프로퍼티 추가
person.name = 'Lee';
person.sayHello = function () {
  console.log(`Hi: My name is` + this.name);
};

console.log(person);
person.sayHello();
```

### 객체 리터럴을 사용한 객체 생성

- 직관적이고 간편한 방법
- 하나의 객체만 생성
- 동일한 프로퍼티를 갖는 객체를 여러 개 생성해야 하는 경우 매번 같은 프로퍼티 기술해야 하는 단점 존재

**객체는 프로퍼티를 통해 고유의 상태를 표현하고, 메서드를 통해 상태 데이터인 프로퍼티를 참조하고 조작하는 동작을 표현한다.**

- 따라서 프로퍼티는 객체마다 값이 다를 수 있지만 메서드는 내용이 동일한 경우가 일반적

### 생성자 함수를 사용한 객체 생성의 장점

- 객체를 생성하기 위한 템플릿처럼 생성자 함수를 사용하여 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성 가능함

**생성자 함수는 일반 함수와 동일한 방법으로 생성자 함수를 정의하고 new 연산자를 사용해 호출하여 생성자 함수로 동작한다**

### 생성자 함수의 역할

프로퍼티 구조가 동일한 인스턴스를 생성하기 위한 템플릿으로서 동작하며

- 인스턴스 생성 (필수)
- 생성된 인스턴스를 초기화 (옵션)

하는 역할을 한다.

### 생성자 함수의 인스턴스 생성 과정

1. 인스턴스 생성과 this 바인딩
   - 암묵적으로 빈 객체(인스턴스) 생성
   - 생성된 빈 객체를 this에 바인딩
2. 인스턴스 초기화
   - 생성자 함수에 기술되어 있는 코드가 한 줄 씩 실행되어 this에 바인딩되어 있는 인스턴스를 초기화 함
3. 인스턴스 반환
   - 생성자 함수 내부에서 모든 처리가 끝나면 완성된 인스턴스가 바인딩 된 this를 암묵적으로 반환
   - this가 아닌 다른 객체를 명시적으로 반환하면 return 문에 명시한 객체가 반환됨
   - 명시적으로 원시 값을 반환하면 원시 값 반환은 무시되고 암묵적으로 this가 반환됨

### Call과 Construct 메서드

함수가 일반 함수로 호출되면 함수 객체의 내부 메서드 [[Call]]이 호출되고 new 연산자와 함께 생성자 함수로서 호출되면 내부 메서드 [[Construct]]가 호출됨

**callable** : 내부 메서드 [[Call]]을 갖는 함수 객체
**constructor** : 내부 메서드 [[Construct]]를 갖는 함수 객체
**non-constructor** : [[Construct]]를 갖지 않는 함수 객체

### costructor와 non-constructor의 구분

- constructor : 함수 선언문, 함수 표현식, 클래스
- non-constructor : 메서드(메서드 축약표현), 화살표 함수

non-constructor 함수 객체를 생성자 함수로서 호출하면 에러 발생

### new 연산자

- new 연산자와 함께 함께 함수를 호출하면 내부 메서드 [[Construct]]가 호출
- 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킴

**생성자 함수는 주로 파스칼 케이스 사용**

### new.target

- new 연산자와 함께 생성자 함수로서 호출되었는지 확인할 수 있음
- 함수 내부의 new.target은 함수 자신을 가리킨다
- 일반 함수로서 호출된 함수 내부의 new.target은 undefined

**Object와 생성자 함수는 new 연산자 없이 호출해도 new 연산자와 함께 호출했을 때와 동일하게 동작한다.**

\*\*String, Number, Boolean 생성자 함수는 new 연산자와 함께 호출했을 때 String, Number, Boolean 객체를 생성하여 반환 / new 연산자 없이 호출하면 문자열, 숫자, 불리언 값 반환

# CH 18 함수와 일급 객체

---

### 일급 객체

1. 무명과 리터럴로 생성 가능, 즉 런타임에 생성이 가능하다.
2. 변수나 자료구조에 저장할 수 있다.
3. 함수의 매개변수에 전달할 수 있다.
4. 함수의 반환값으로 사용할 수 있다.

> 자바스크립트의 함수는 위의 조건을 모두 만족하므로 일급 객체이다.

함수 = 일급 객체 = 동일하게 사용 가능

객체 = 값 = 함수

**함수는 값을 사용할 수 있는 곳에 리터럴로 정의할 수 있으며 런타임에 함수 객체로 평가된다.**

### 일급 객체로서 함수가 가지는 특징

- 일반 객체와 같이 함수의 매개변수에 전달 가능
- 함수의 반환 값으로 사용 가능

### 함수와 일반 객체의 차이

- 일반 객체는 호출 불가
- 함수는 호출 가능

### 함수 객체의 프로퍼티

arguments, caller, length, name, prototype

- **arguments**

  - 함수 호출 시 전달된 인수들의 정보를 담고 있는 순회 가능한 유사 배열 객체이며, 함수 내부에서 지역변수처럼 사용됨
  - 인수를 프로퍼티 값으로 소유하며 프로퍼티 키는 인수의 순서를 나타냄
  - arguments 객체의 callee 프로퍼티는 호출되어 arguments 객체를 생성한 함수, 즉 함수 자신을 가리킴
  - arguments 객체의 length 프로퍼티는 **인수의 개수**를 가리킴
  - **매개변수의 개수를 확정할 수 없는 가변 인자 함수를 구현할 때 유용**

- **caller 프로퍼티** -함수 자신을 호출한 함수를 가리킴
- **length 프로퍼티**

  - 함수를 정의할 때 선언한 **매개변수의 개수**를 가리킴
  - arguments 객체의 length 프로퍼티와 함수 객체의 length 프로퍼티의 값은 다를 수 있음

- **name 프로퍼티**

  - 함수 이름을 나타냄
  - 함수 객체를 가리키는 식별자를 값으로 가짐

- \*\***proto** 접근자 프로퍼티

  - [[Prototype]] 내부 슬롯이 가리키는 프로토타입 객체에 접근하기 위해 사용하는 접근자 프로퍼티
  - 간접적인 접근 방법을 제공하는 경우에 한함

- prototype 프로퍼티
  - 생성자 함수로 호출할 수 있는 함수 객체, constructor만이 소유하는 프로퍼티
  - non-constructor에는 prototype 프로퍼티가 없음
  - 함수가 객체를 생성하는 생성자 함수로 호출될 때 생성자 함수가 생성할 인스턴스의 프로토타입 객체를 가리킴

# CH 19 프로토타입

---

### 객체지향 프로그래밍

- 프로그램을 객체의 집합으로 프로그램을 표현하려는 프로그래망 패러다임

**객체**

- 상태 데이터와 동작을 하나의 논리적인 단위로 묶은 복합 자료구조
- 객체의 상태 데이터 : 프로퍼티 / 동작 : 메서드

#### 특징

- 속성
- 추상화

### 상속

- 어떤 객체의 프로퍼티 또는 메서드를 다른객체가 상속받아 그대로 사용
- 불필요한 중복 제거
- 자바스크립트는 프로토타입을 기반으로 상속을 구현함

```javascript
// 생성자 함수
function Circle(radius) {
  this.radius = radius;
}

// Circle 생성자 함수가 생성한 모든 인스턴스가 getArea 메서드를 공유해서 사용할 수 있도록 프로토타입에 추가
// 프로토타입은 Circle 생성자 함수의 prototype 프로퍼티에 바인딩

Circle.prototype.getArea = function () {
  return Math.PI * this.radius ** 2;
};

// 인스턴스 생성
const circle1 = new Circle(1);
const circle2 = new Circle(2);

// Circle 생성자 함수가 생성한 모든 인스턴스는 부모 객체의 역할을 하는 프로토타입 Circle.prototype으로부터 getArea 메서드를 상속받음
// Circle 생성자 함수가 생성하는 모든 인스턴스는 하나의 getArea 메서드를 공유
console.log(circle1.getArea === circle2.getArea); // true

console.log(circle1.getArea()); // 3.14
console.log(circl2.getArea()); // 12.56
```

![](https://velog.velcdn.com/images/se0kcess/post/fc323a37-9396-4331-8a3f-1a7bb84b86bd/image.png)

### 프로토타입 객체

- 어떤 객체의 부모 객체로서 다른 객체에 공유 프로퍼티를 제공
- 프로토타입을 상속받은 자식 객체는 상위 객체의 프로퍼티를 자신의 프로퍼티처럼 자유롭게 사용 가능
- 객체 간 상속을 구현하기 위해 사용
- 객체 생성 방식에 따라 프로토타입이 결정되고 [[Prototype]]에 저장
- 모든 객체는 하나의 프로토타입을 갖는다

### 프로토타입 접근

- \_\_ **proto** \_\_ 접근자 프로퍼티
  - [[Prototype]] 내부 슬롯에 간접적으로 접근 가능
  - 상속을 통해 사용
  - 최상위 객체는 Object.prototype
  - 상호 참조에 의해 프로토타입 체인이 생성되는 것을 방지하기 위해 사용

#### 프로토타입 체인은 단방향 링크드 리스트로 구현되어야 함

- 서로가 자신의 프로토타입이 되는 비정상적인 프로토타입 체인이 만들어지면 프로퍼티 검색 시 무한루프에 빠짐

> \_\_ **proto** \_\_ 의 경우 모든 객체가 사용할 수 있는 것이 아니기 때문에 사용을 권장하지 않음

대신에 Object.getPrototypeOf 메서드 사용

### 함수 객체의 prototype 프로퍼티

- 함수 객체만이 소유하는 prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킴
- non-constructor는 prototype 프로퍼티를 소유하지 않으며 프로토타입을 생성하지도 않음

**객체를 생성하지 않는 일반 함수의 prototype 프로퍼티는 아무런 의미가 없다**

| 구분                | 소유        | 값                | 사용 주체   | 사용 목적                                                          |
| :------------------ | :---------- | :---------------- | :---------- | :----------------------------------------------------------------- |
| \_\_ **proto** \_\_ | 모든 객체   | 프로토타입의 참조 | 모든 객체   | 객체가 자신의 프로토타입에 접근 또는 교체하기 위해 사용            |
| prototype           | constructor | 프로토타입의 참조 | 생성자 함수 | 생성자 함수가 자신이 생성할 객체의 프로토타입을 할당하기 위해 사용 |

**모든 프로토타입은 constructor 프로퍼티를 가지며 prototype 프로퍼티로 자신을 참조하고 있는 생성자 함수를 가리킨다.**

리터럴 표기법에 의해 생성한 객체도 프로토타입이 존재하지만 프로토타입의 constructor 프로퍼티가 가리키는 생성자 함수가 반드시 객체를 생성한 생성자 함수라고 단정할 수는 없다.

**프로토타입과 생성자 함수는 단독으로 존재할 수 없고 언제나 쌍으로 존재**

### 리터럴 표기법 생성 객체의 생성자 함수와 프로토타입

| 리터럴 표기법      | 생성자 함수 | 프로토타입         |
| :----------------- | :---------- | :----------------- |
| 객체 리터럴        | Object      | Object.prototype   |
| 함수 리터럴        | Function    | Function.prototype |
| 배열 리터럴        | Array       | Array.prototype    |
| 정규 표현식 리터럴 | RegExp      | RegExp.prototype   |

### 프로토타입 생성 시점

생성자 함수가 생성되는 시점에 생성

- 사용자 정의 생성자 함수
  - 함수 객체를 생성하는 시점에 프로토타입도 생성
  - Object.prototype
- 빌트인 생성자 함수와 프로토타입 생성 시점
  - 빌트인 생성자 함수가 생성되는 시점에 프로토타입 생성
  - 빌트인 생성자 함수는 전역 객체가 생성되는 시점에 생성

> 객체가 생성되기 이전에 생성자 함수와 프로토타입은 이미 객체화되어 존재하며 이후에 객체를 생성하면 [[Prototype]] 내부 슬롯에 할당되어 프로토타입을 상속받는다.

### 객체의 생성방식

- 객체 리터럴
  - Object.prototype을 프로토타입으로 가지며 이를 상속
- Object 생성자 함수
  - 빈 객체를 생성한 이후 프로퍼티 추가
- 생성자 함수
  - 생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체를 프로토타입으로 전달
- Object.create 메서드 (직접 상속)
  - 객체를 생성하면서 직접적으로 상속 구현
  - new 연산자 없이 객체 생성 가능
  - 프로토타입을 지정하면서 객체 생성 가능
  - 객체 리터럴에 의해 생성된 객체도 상속 가능
- 클래스

공통점 : 추상연산 OrdinaryObjectCreate에 의해 생성

### 프로토타입 체인

객체의 프로퍼티에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티가 없으면 [[Prototype]] 내부 슬롯의 참조에 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색하는 것

```javascript
function Person(name){
  this.name = name;
}

// 프로토타입 메서드
Person.prototype.sayHello = function() {
  console.log(`Hi! My name is ${this.name});
};

const me = new Person(`Lee`);

// hasOwnProperty는 Object.prototype의 메서드다.
console.log(me.hasOwnProperty(`name`); // true
```

프로토타입 체인의 최상위 객체는 언제나 Object.prototype이다 (프로토타입 체인의 종점)

### 프로퍼티 섀도잉

상속 관계에 의해 프로퍼티가 가려지는 현상

### 프로토타입의 교체

- 생성자 함수에 의한 프로토타입 교체
  - 프로토타입으로 교체한 객체 리터럴에는 constructor 프로퍼티 x -> 새로 추가 해 주어야 함
- 인스턴스에 의한 프로토타입 교체
  - \_**\_prototype\_\_** 접근자 프로퍼티를 통해 프로토타입을 교체하는 것은 이미 생성된 객체의 프로토타입을 교체하는 것

![](https://velog.velcdn.com/images/se0kcess/post/701a7c58-e605-4a8f-a53f-900460baaea2/image.png)

### instanceof 연산자

좌변에 객체를 가리키는 식별자, 우변에 생성자 함수를 가리키는 식별자를 피연산자로 받아, 우변의 생성자 함수의 prototype에 바인딩된 객체가 좌변의 객체의 프로토타입 체인 상에 존재하면 true, 없으면 false 반환

**생성자 함수의 prototype에 바인딩된 객체가 체인 상에 존재하는 지 확인**

생성자 함수에 의해 프로토타입이 교체되어 constructor 프로퍼티와 생성자 함수 간의 연결이 파괴되어도 생성자 함수의 prototype 프로퍼티와 프로토타입 간의 연결은 파괴되지 않음

### 정적 프로퍼티/메서드

- 생성자 함수로 인수를 생성하지 않아도 참조/호출 할 수 있는 프로퍼티/메서드
- 정적 메서드는 인스턴스를 생성하지 않아도 호출 가능

### in 연산자 (Reflect.has | Object.prototype.hasOwnProperty)

객체 내에 특정 프로퍼티가 존재하는지 여부를 확인

```javascript
/**
key: 프로퍼티 키를 나타내는 문자열
object: 객체로 평가되는 표현식
*/
key in object;
```

in 연산자는 확인 대상 객체의 프로퍼티뿐만 아니라 확인 대상 객체가 상속 받은 모든 프로토타입의 프로퍼티를 확인함

### for...in 문 (프로퍼티 열거)

- 객체의 프로퍼티 개수만큼 순회하며 for...in 문의 변수 선언문에서 선언한 변수에 프로퍼티 키를 할당한다.
- in 연산자처럼 순회 대상 객체의 프로퍼티뿐만 아니라 상속받은 프로토타입의 프로퍼티까지 열거
- 프로퍼티 키가 심벌인 프로퍼티는 열거하지 않음

**객체의 프로토타입 체인 상에 존재하는 모든 프로토타입의 프로퍼티 중에서 프로퍼티 어트리뷰트[[Enumerable]]의 값이 true인 프로퍼티를 순회하며 열거한다.**

### Object.keys/values/entries 메서드

객체 자신의 고유 프로퍼티만 열거함
