# 모던 자바스크립트 딥다이브 스터디 1회

## 분량

- 1장: 프로그래밍
- 2장: 자바스크립트란?
- 3장: 자바스크립트 개발 환경과 실행 방법
- 4장: 변수
- 5장: 표현식과 문
- 6장: 데이터 타입
- 7장: 연산자

# 정리

## 1장: 프로그래밍

### 1.2 프로그래밍 언어

#### 순서

- 사람 > (프로그래밍 언어) > 컴파일러 또는 인터프리터 > (기계어) > 컴퓨터

## 2장: 자바스크립트란?

### 2.2 자바스크립트의 표준화

#### 경쟁 회사

- 넷스케이프 커뮤니케이션즈
- 마이크로소프트

#### 발생 문제

각 회사가 시장 점유율을 높이기 위해 자사 브라우저에서만 동작하는 기능을 추가하여, 브라우저에 따라 웹페이지가 정상적으로 동작하지 않는 크로스 브라우징 이슈가 발생하기 시작했다.

#### 문제 해결

넷스케이프 커뮤니케이션즈의 요청에 따라 ECMA 인터내셔널(컴퓨터 시스템 표준 관리 비영리 기구)이 자바스크립트 표준화를 진행했다.

자바스크립트는 ECMAScript로 명명되었다.

### 2.3 자바스크립트 성장의 역사

#### Ajax

- 정의: 서버-브라우저가 비동기 방식으로 데이터 교환
- 변화
  - 이전: 완전한 html 코드를 서버로부터 받아 웹페이지 전체를 렌더링하는 방식으로 작동, 화면 전환을 할 때에도 새로운 html을 전송받아 웹페이지 전체 다시 렌더링 진행
  - 등장: 웹페이지에서 변경할 필요가 없는 부분은 다시 렌더링하지 않고, 변경이 필요한 부분만 한정적으로 렌더링 진행

#### jQuery

- 등장: DOM을 더욱 쉽게 제어 가능

#### V8 자바스크립트 엔진

- 변화
  - 이전: 웹 서버에서 수행되던 로직
  - 등장: 클라이언트(브라우저)에서 수행되는 로직

#### Node.js

- 변화
  - 이전: 브라우저 자바스크립트 엔진에서만 자바스크립트 동작
  - 등장: 브라우저 이외 환경에서도 동작할 수 있게, 자바스크립트 엔진을 브라우저에서 독립해 서버 사이드 애플리케이션 개발에 사용 가능
- 장점
  - 비동기 I/O 지원
  - 단일 스레드 이벤트 루프 방식으로 동작
  - I/O 빈번하게 발생하는 SPA에 적합

#### SPA 프레임워크

- 등장: CBD(Component Based Development) 방법론 기반 SPA 대중화

### 2.5 자바스크립트 특징

- 기존: 별도의 컴파일 과정을 수행하지 않는 인터프리터 언어
  - 한 줄씩 바이트코드로 변환하여 즉시 실행
  - 인터프리트 단계와 실행 단계가 구분되어 있지 않아 실행 속도가 컴파일러 언어에 비해 느림
- 모던 브라우저: 인터프리터 언어
  - 복잡한 과정을 거쳐 일부 소스코드를 컴파일하고 실행
  - 하지만 런타임에 실행되고, 실행 파일이 생성되지 않아 컴파일러 언어라고 할 수 없음
- 프로토타입 기반의 객체 지향 언어

## 3장: 자바스크립트 개발 환경과 실행 방법

### 3.1 자바스크립트 실행 환경

- 모든 브라우저는 자바스크립트 엔진 내장

#### 브라우저 VS Node.js

- 브라우저
  - HTML, CSS
  - 웹페이지를 화면에 랜더링
- Node.js
  - 브라우저 외부에서 자바스크립트 환경 제공
- 브라우저와 Node.js가 추가로 제공하는 기능은 서로 호환되지 않음

### 3.3 Node.js

#### 정의

브라우저에서만 동작하던 자바스크립트를 브라우저 이외의 환경에서 동작시킬 수 있는 자바스크립트 실행 환경

#### npm

- 자바스크립트 패키지 매니저
- Node.js에서 사용할 수 있는 모듈을 패키지화한 저장소 역할
- 패키지 설치 및 관리를 위한 CLI 환경 제공

## 4장: 변수

### 4.1 변수란 무엇인가? 왜 필요한가?

#### 컴퓨터 작동 과정

    - CPU: 연산
    - 메모리: 데이터 기억

#### 메모리

- 정의
  - 메모리 셀 집합체
  - 1바이트=8비트
- 자바스크립트에서의 메모리
  - 개발자의 직접적 메모리 제어 허용하지 않음
  - 할당이 해제된 메모리는 가비지 컬렉션에 의해 관리됨

#### 변수

- 정의
  - 하나의 값을 저장하기 위해 확보한 메모리 공간
  - 메모리 공간을 식별하기 위해 붙인 이름
- 사용법
  - 기억하고 싶은 값을 메모리에 저장(할당)
  - 저장된 값을 읽어 재사용(참조)

### 4.2 식별자

#### 활용법

- 식별자는 값이 아니라 메모리 주소를 기억함
- 과정: 변수 이름(식별자) > 메모리 주소 > 메모리

### 4.3 변수 선언

- 값을 저장하기 위한 메모리 공간 확보
- 변수 이름과 확보된 메모리 공간의 주소 연결

#### 과정

- 선언
  - 실행 컨텍스트에 등록
  - 변수 이름을 등록해 자바스킙트 엔진에 변수의 존재 알림
- 초기화
  - 값을 저장하기 위한 메모리 공간 확보하고, undefined를 할당

### 4.4 변수 선언의 실행 시점과 변수 호이스팅

#### 자바스크립트 실행 과정

1. 소스코드 평가 과정(소스코드 실행 준비 단계): 모든 선언문 실행
2. 런타임: 코드 실행

#### 변수 선언 실행 시점

런타임 이전에 먼저 실행이 되기에, 선언문 이전의 위치에 해당 변수를 호출해도 에러가 아닌 undefined 값이 출력됨

#### 변수 호이스팅

변수 선언문이 코드의 최상단에서 실행되는 것처럼 작동하는 특징

### 4.5 값의 할당

```js
console.log(score); //undefined
var score = 80;
console.log(score); //80
```

#### 값 선언 VS 값 할당: 시점

- 값 선언: 런타임 이전
- 값 할당: 런타임

#### 값 선언 VS 값 할당: 메모리

- 값 선언: undefined 할당
- 값 할당: undefined에 해당하는 메모리 공간을 지우는 것이 아닌, 새로운 메모리 공간에 값을 할당

### 4.6 값의 재할당

#### 메모리 측면

- 기존의 메모리 공간에 값을 지우고 쓰는 것X
- 새로운 공간에 값을 할당하고 참조하는 주소값을 변경O

#### 매니지드 언어

메모리의 할당 및 해제를 위한 메모리 관리 기능을 제공

#### 가비지 콜렉터

- 기존의 메모리 공간은 식별자와의 연결이 끊어져, 가비지 콜렉터에 의해 메모리에서 자동 해제
- 단, 해제 시점은 예상 불가능

### 4.7 식별자 네이밍 규칙

- 변수, 함수: 카멜 케이스
  - firstName
- 생성자 함수, 클래스: 파스칼 케이스
  - FirstName

## 5장: 표현식과 문

### 5.1 값

- 값: 표현식이 평가되어 생성된 결과
- 계산하는 부분은 할당 이전에 평가되어 값을 생성해야 함
  - 코드
    ```js
    var sum = 10 + 20;
    ```
  - 10+20은 할당 이전에 평가되어 30이라는 값을 생성

### 5.2 리터럴

- 리터럴: 사람이 이해할 수 있는 기호로 값을 생성하는 표기법
- 런타임에 리터럴을 평가해 값을 생성

### 5.3 표현식

- 표현식: 값으로 평가될 수 있는 문
  - 식별자 참조: 값을 생성하지는 않아도, 값으로 평가되기에 표현식에 해당

### 5.4 문

- 문: 프로그램을 구성하는 기본 단위, 최소 실행 단위
- 토근: 문의 구성 요소
  - 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소

### 5.5 세미 콜론과 세미콜론 자동 삽입 기능

- 자바스크립트 엔진은 세미콜론 자동 삽입 기능(ASI=Automic Semicolon Insertion)을 암묵적으로 실행함

### 5.6 표현식인 문 VS 표현식이 아닌 문

- 표현식인 문: 값으로 평가될 수 있는 문
- 표현식이 아닌 문: 값으로 평가할 수 없는 문
  - 실행하면 undefined 출력

## 6장: 데이터 타입

### 6.3 템플릿 리터럴

- 편리한 문자열 처리 기능 제공
- 백틱(``) 사용하여 표현

### 6.5 undefined 타입

- 변수를 참조했을 떄, undefined인 경우
  - 참조한 변수가 선언 이후 값이 할당된 적이 없음
  - 초기화되지 않은 변수임

### 6.6 null 타입

- 변수에 null 할당
  - 이전에 할당되어 있던 값에 대한 참조 제거
  - 해당 변수는 가비지 콜렉션 수행 대상

### 6.7 심벌(Symbol) 타입

- 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용

### 6.9 데이터 타입의 필요성

- 값 저장: 확보할 메모리 공간 크기 결정을 위해
- 값 참조: 한 번에 읽어 들여야 할 메모리 공간 크기 결정을 위해
- 값 해석: 메모리에서 읽은 2진수 해석 방법 결정을 위해

### 6.10 동적 타이핑

#### 정적 타입 언어 VS 동적 타입 언어

- 정적 타입 언어
  - 컴파일 시점에 타입 체크
- 동적 타입 언어
  - 런타임 중 값 할당 시점에 타입 체크
  - 유연성 높음, 신뢰성 떨어짐

#### 자바스크립트: 동적 타입 언어

선언이 아닌 할당에서 타입이 결정됨

- 선언: 키워드(var, const, let) 사용
- 할당: 데이터 타입에 상관없이 값 자유롭게 할당
- 재할당: 변수의 타입 동적으로 변경 가능

## 7장: 연산자

- 피연산자: 값
- 연산자: 피연산자를 연산하여 새로운 값 생성

### 7.3 비교 연산자

#### NaN

자신과 일치하지 않는 유일한 값

```js
NaN === NaN; //false
```

#### NaN 검사 방법

- isNaN

```js
Number.isNaN(NaN); //true
```

- Object.is

```js
Object.isNaN(NaN, NaN); //true
```

### 7.8 typeof 연산자

```js
typeof null; //object
```

# 질문

## 2장

- 자바스크립트를 객체 지향 언어라고 말할 수 있는 증거가 무엇이 있는가?
