# 28장 Number

# **1. Number 생성자 함수**

표준 빌트인 객체인 Number 객체는 생성자 함수 객체다.

→ new 연산자와 함께 호출하여 Number 인스턴스를 생성할 수 있다.

```jsx
const numObj = new Number();
console.log(numObj); // [Number: 0]
```

Number 생성자 함수의 인수로 숫자를 전달하면서 new 연산자와 함께 호출하면 내부 슬롯에 인수로 전달받은 숫자를 할당한 Number 래퍼 객체를 생성한다.

```jsx
const numObj = new Number(10);
console.log(numObj); // [Number: 10]
```

Number 생성자 함수의 인수로 숫자가 아닌 값을 전달하면 인수를 숫자로 강제 변환한 후, 내부 슬롯에 변환된 숫자를 할당한 Number 래퍼 객체를 생성한다.

인수를 숫자로 변환할 수 없다면 NaN을 내부 슬롯에 할당한 Number 래퍼 객체를 생성한다.

```jsx
let numObj = new Number('10');
console.log(numObj); // [Number: 10]

numObj = new Number('Hello');
console.log(numObj); // [Number: NaN]
```

new 연산자를 사용하지 않고 Number 생성자 함수를 호출하면 Number 생성자 함수를 호출하면 Number 인스턴스가 아닌 숫자를 반환한다.

```jsx
Number('0'); // 0
Number('-1'); // -1
Number('10.53'); // 10.53

Number(true); // 1
Number(false); // 0
```

# **2. Number 프로퍼티**

## **2.1 Number.EPSILON**

ES6에서 도입된 Number.EPSILON은 1과 1보다 큰 숫자 중에서 가장 작은 숫자와의 차이와 같다.

부동소수점 산술 연산에서 사용되며 부동소수점으로 인해 발생하는 오차를 해결하기 위해 사용된다.

```jsx
let a = 0.1 + 0.2;
console.log(a === 0.3); // false

function isEqual(a, b) {
  // a와 b를 뺀 값의 절대값이 Number.EPSILON 보다 작으면 같은 수로 인정한다.
  return Math.abs(a - b) < Number.EPSILON;
}

console.log(isEqual(0.1 + 0.2, 0.3)); // true
```

## **2.2 자바스크립트의 Number 수 표현**

```jsx
// Number.MAX_VALUE 는 자바스크립트에서 표현할 수 있는 가장 큰 양수값이다.
// Number.MAX_VALUE보다 큰 숫자는 Infinity다.
Infinity > Number.MAX_VALUE; // true

// Number.MIN_VALUE 는 자바스크립트에서 표현할 수 있는 가장 작은 양수 값이다.
// Number.MIN_VALUE 보다 작은 숫자는 0이다.
0 < Number.MIN_VALUE; // true

// Number.MAX_SAFE_INTEGER 는 자바스크립트에서 안전하게 표현할 수 있는 가장 큰 정수값이다.
Number.MAX_SAFE_INTEGER; // 9007199254740991

// Number.MIN_SAFE_INTEGER 는 자바스크립트에서 안전하게 표현할 수 있는 가장 작은 정수값이다.
Number.MIN_SAFE_INTEGER; // -9007199254740991

// Number.POSITIVE_INFINITY 는 양의 무한대를 나타내는 숫자값 Infinity와 같다.
Number.POSITIVE_INFINITY; // Infinity

// Number.NEGATIVE_INFINITY 는 음의 무한대를 나타내는 숫자값 -Infinity와 같다.
Number.NEGATIVE_INFINITY; // -Infinity

// Number.NaN 은 숫자가 아님을 나타내는 숫자값이다.
Number.NaN; // NaN
```

# **3. Number 메서드**

## **3.1 Number.isFinite**

ES6에서 도입된 Number.isFinite 정적 메서드는 인수로 전달된 숫자값이 정상적인 유한수, 즉 Infinity 또는 -Infinity가 아닌지 검사하여 그 결과를 불리언 값으로 반환한다.

```jsx
// 인수가 정상적인 유한수이면 true를 반환한다.
Number.isFinite(0); // true
Number.isFinite(Number.MAX_VALUE); // true
Number.isFinite(Number.MIN_VALUE); // true

// 인수가 무한수이면 false를 반환한다.
Number.isFinite(Infinity); // false
Number.isFinite(-Infinity); // false

// 인수가 NaN이면 항상 false를 반환한다.
Number.isFinite(NaN); // false
```

Number.isFinite는 전달받은 인수를 숫자로 암묵적 타입 변환하지 않는다.

→ 숫자가 아닌 인수가 주어졌을 때 반환값은 언제나 false다.

```jsx
// Number.isFinite는 인수를 숫자로 암묵적 타입 반환하지 않는다.
Number.isFinite(null);

// isFinite는 인수를 숫자로 암묵적 타입 반환한다. null은 0으로 암묵적 타입 반환된다.
isFinite(null); // true
```

## **3.2 Number.isInteger**

ES6에서 도입된 Number.isInteger 정적 메서드는 인수로 전달된 숫자값이 정수인지 검사하여 그 결과를 불리언 값으로 반환한다. 검사하기 전에 인수를 숫자로 암묵적 타입 변환하지 않는다.

```jsx
// 인수가 정수이면 true를 반환한다.
Number.isInteger(0); // true
Number.isInteger(123); // true
Number.isInteger(-123); // true

// 0.5는 정수가 아니다.
Number.isInteger(0.5); // false
// "123"을 숫자로 암묵적 타입 변환하지 않는다.
Number.isInteger('123'); // false
// false를 숫자로 암묵적 타입 변환하지 않는다.
Number.isInteger(false); // false
// Infinity/-Infinity 는 정수가 아니다.
Number.isInteger(Infinity); // false
Number.isInteger(-Infinity); // false
```

## **3.3 Number.isNaN**

ES6에서 도입된 Number.isNaN 정적 메서드는 인수로 전달된 숫자값이 NaN인지 검사하여 그 결과를 불리언 값으로 반환한다.

```jsx
// 인수가 NaN이면 true를 반환한다.
Number.isNaN(NaN); // true
```

Number.isNaN 메서드는 빌트인 전역 함수 isNaN과 차이가 있다. 빌트인 전역 함수 isNaN은 전달받은 인수를 숫자로 암묵적 타입 변환하여 검사를 수행하지만 Number.isNaN 메서드는 전달받은 인수를 숫자로 암묵적 타입 변환하지 않는다.

```jsx
// Number.isNaN은 인수를 숫자로 암묵적 타입 변환하지 않는다.
Number.isNaN(undefined); // false

// isNaN은 인수를 숫자로 암묵적 타입 변환한다. undefined는 NaN으로 암묵적 타입 변환된다.
isNaN(undefined); // true
```

## **3.4 Number.isSafeInteger**

ES6에서 도입된 Number.isSafeInteger 정적 메서드는 인수로 전달된 숫자값이 안전한 정수인지 검사하여 그 결과를 불리언 값으로 반환한다.

안전한 정수값은 `-(253 - 1)` 과 `253 - 1` 사이의 정수값이며, 검사전에 인수를 숫자로 암묵적 타입 변환하지 않는다.

```jsx
// 0은 안전한 정수다.
Number.isSafeInteger(0); // true

// 0.5는 정수가 아니다.
Number.isSafeInteger(0.5); // false
// "123"을 숫자로 암묵적 타입 변환하지 않는다.
Number.isSafeInteger('123'); // false
// false를 숫자로 암묵적 타입 변환하지 않는다.
Number.isSafeInteger(false); // false
// Infinity/-Infinity 는 정수가 아니다.
Number.isSafeInteger(Infinity); // false
Number.isSafeInteger(-Infinity); // false
```

## **3.5 Number.prototype.toExponential**

toExponential 메서드는 숫자를 지수 표기법으로 변환하여 문자열로 반환한다.

지수 표기법은 매우 크거나 작은 숫자를 표기할 때 주로 사용하며 e(Exponent) 앞에 있는 숫자에 10의 n승을 곱하는 형식으로 수를 나타내는 방식이다.

```jsx
console.log((77.1234).toExponential()); // 7.71234e+1
console.log((77.1234).toExponential(4)); // 7.7123e+1
console.log((77.1234).toExponential(2)); // 7.71e+1
```

숫자 리터럴과 함께 Number 프로토타입 메서드를 사용할 경우 에러가 발생한다.

```jsx
77.toExponential(); // SyntaxError
```

숫자 리터럴과 함께 메서드를 사용할 경우 혼란을 방지하기 위해 그룹 연산자를 사용해야 한다.

```jsx
(77).toExponential();

// 공백을 두어 사용할 수 있기도 하다.
(77).toExponential();
```

## **3.6 Number.prototype.toFixed**

toFixed 메서드는 숫자를 반올림하여 문자열로 반환한다. 반올림하는 소수점 이하 자리수를 나타내는 0~20 사이의 정수값을 인수로 전달할 수 있다. 인수를 생략하면 기본값 0이 지정된다.

```jsx
// 소수점 이하 반올림. 인수를 생략하면 기본값 0이 지정된다.
(12345.6789).toFixed(); // 12345
// 소수점 이하 1자릿수 유효, 나머지 반올림
(12345.6789).toFixed(1); // 12345.7
// 소수점 이하 2자릿수 유효, 나머지 반올림
(12345.6789).toFixed(2); // 12345.68
```

## **3.7 Number.prototype.toPrecision**

toPrecision 메서드는 인수로 전달받은 전체 자리수까지 유효하도록 나머지 자리수를 **반올림 하여 문자열로 반환**한다. 인수로 전달받은 전체 자릿수로 표현할 수 없는 경우 지수 표기법으로 결과를 반환한다.

전체 자릿수를 나타내는 0~21 사이의 정수값을 인수로 전달할 수 있다.

```jsx
// 전체 자릿수 유효. 인수를 생략하면 기본값 0이 지정된다.
(12345.6789).toPrecision(); // "12345.6789"
// 전체 1자릿수 유효, 나머지 반올림
(12345.6789).toPrecision(1); // "1e+4"
// 전체 2자릿수 유효, 나머지 반올림
(12345.6789).toPrecision(2); // "1.2e+4"
// 전체 6자릿수 유효, 나머지 반올림
(12345.6789).toPrecision(6); // "12345.7"
```

## **3.8 Number.prototype.toString**

toString 메서드는 숫자를 문자열로 변환하여 반환한다. 진법을 나타내는 2~36 사이의 정수값을 인수로 전달할 수 있다. 인수를 생략하면 기본값 10진법이 지정된다.

```jsx
// 인수를 생략하면 10진수 문자열을 반환한다.
(10).toString(); // "10"
// 2진수
(16).toString(2); // "10000"
// 8진수
(16).toString(8); // "20
// 16진수
(16).toString(16); // "10"
```

---

# 29장  Math

# **1. Math 프로퍼티**

- 표준 빌트인 객체인 Math는 수학적인 상수와 함수를 위한 프로퍼티와 메서드를 제공한다.
- Math는 생성자 함수가 아니다. 따라서 정적 프로퍼티와 정적 메서드만 제공한다.

## **1.1 Math.PI**

원주율 PI값(3.14)을 반환한다.

```jsx
Math.PI; //  -> 3.141592653589793
```

# **2. Math 메서드**

```jsx
// Math.abs 메서드는 인수로 전달된 숫자의 절대값을 반환한다. 
// 절대값은 반드시 0 또는 양수다.
Math.abs(-1); // 1
Math.abs('1'); // 1
Math.abs(''); // 0
Math.abs([]); // 0
Math.abs(null); // 0

// NaN으로 표기된다.
Math.abs(undefined);
Math.abs({});
Math.abs('string');
Math.abs();

// Math.Round 메서드는 인수로 전달된 숫자의 소수점 이하를 반올림한 정수를 반환한다.
Math.round(1.4); // 1
Math.round(1.6); // 2
Math.round(-1.4); // -1
Math.round(-1.6); // -2
Math.round(1); // 1
Math.round(); // NaN

// Math.ceil 메서드는 인수로 전달된 숫자의 소수점 이하를 올림한 정수를 반환한다.
Math.ceil(1.4); // 2
Math.ceil(1.6); // 2

// Math.floor 메서드는 인수로 전달된 숫자의 소수점 이하를 내림한 정수를 반환한다.
// 인수가 양수인 경우 소수점 이하를 떼어 버린 다음 정수를 반환한다.
Math.floor(1.4); // 1
Math.floor(2.6); // 2
// 인수가 음수인 경우 소수점 이하를 떼어 버린 다음 -1을 곱한 정수를 반환한다.
Math.floor(-1.9); // -2
Maht.floor(-9.1); // 10

// Math.sqrt 메서드는 인수로 전달된 숫자의 제곱근을 반환한다.
Math.sqrt(9); // 3
Math.sqrt(-9); // NaN
Math.sqrt(2); // 1.414213....
Math.sqrt(1); // 1
Math.sqrt(0); // 0
Math.sqrt(); // NaN
```

## **2.6 Math.random**

Math.random 메서드는 임의의 난수(랜덤 숫자)를 반환한다. Math.random 메서드가 반환한 난수는 0에서 1미만의 실수다. → 0은 포함되지만 1은 포함되지 않는다.

```jsx
Math.random(); // 0 ~ 1 미만의 랜덤 실수

const random = Math.floor(Math.random() * 10 + 1);
console.log(random); // 1 ~ 10 범위의 정수
```

## **2.7 Math.pow**

Math.pow 메서드는 첫 번째 인수를 밑으로, 두 번째 인수를 지수로 거듭제곱한 결과를 반환한다.

```jsx
Math.pow(2, 8); // 256
Math.pow(2 - 1); // 0.5
Math.pow(2); // NaN

// **Math.pow 대신** ES7에서 도입된 지수 연산자를 사용하면 가독성이 더 좋다.
2 ** (2 ** 2); // 16
Math.pow(Math.pow(2, 2), 2); // 16
```

## **2.8 Math.max // Math.min**

Math.max 메서드는 전달받은 인수 중에서 가장 큰 수를 반환한다. 인수가 전달되지 않으면 -Infinity를 반환한다.

Math.min 메서드는 전달받은 인수 중에서 가장 작은 수를 반환한다. 인수가 전달되지 않으면 Infinity를 반환한다.

```jsx
Math.max(1); // 1
Math.max(1, 2); // 2
Math.max(1, 2, 3); // 3
Math.max(); // -Infinity

Math.min(1); // 1
Math.min(1, 2); // 1
Math.min(1, 2, 3); // 1
Math.min(); // Infinity
```

배열로 인수로 전달받아 배열의 요소 중에서 최대값/최소값을 구하려면 `Function.prototype.apply` 메서드나 스프레드 문법을 사용해야 한다.

```jsx
Math.max.apply(null, [1, 2, 3]); // 3
Math.max(...[1, 2, 3]); // 3

Math.min.apply(null, [1, 2, 3]); // 1
Math.min(...[[1, 2, 3]); // 1
```

---

# 30장 Date

- 표준 객체인 Date는 날짜와 시간을 위한 메서드를 제공하는 빌트인 객체이면서 생성자 함수다.
- UTC는 국제 표준시를 말하며 GMT로 불리기도 한다.
- KST는 UTC에 9시간을 더한 시간이다.
- 현재 날짜와 시간은 자바스크립트 코드가 실행된 시스템의 시계에 의해 결정된다.

# **1. Date 생성자 함수**

Date는 **생성자 함수**다. 

Date 생성자 함수로 생성한 Date 객체는 기본적으로 현재 날짜와 시간을 나타내는 정수값을 가진다.

현재 날짜와 시간이 아닌 다른 날짜와 시간을 다루고 싶은 경우 Date 생성자 함수에 명시적으로 **해당 날짜와 시간 정보를 인수로 지정**한다.

## **1.1 new Date()**

Date 생성자 함수를 인수 없이 new 연산자와 함께 호출하면 현재 날짜와 시간을 가지는 Date 객체를 반환한다.

Date 객체는 내부적으로 날짜와 시간을 나타내는 정수값을 갖지만 Date 객체를 호출하면 기본적으로 날짜와 시간 정보를 출력한다.

```jsx
new Date(); // 2023-08-15T12:50:28.906Z
```

Date 생성자 함수를 new 연산자 없이 호출하면 Date 객체를 반환하지 않고 날짜와 시간 정보를 나타내는 문자열을 반환한다.

```jsx
Date(); // Tue Aug 15 2023 21:52:47 GMT+0900 (Korean Standard Time)
```

## **1.2 new Date(milliseconds)**

Date 생성자 함수에 숫자 타입의 밀리초를 인수로 전달하면 UTC 기점으로 인수로 전달된 밀리초만큼 경과한 날짜와 시간을 나타내는 Date 객체를 반환한다.

```jsx
// 한국 표준시 KST는 협정 세계시 UTC에 9시간을 더한 시간이다.
new Date(0); // -> Thu Jan 01 1970 09:00:00 GMT+0900 (대한민국 표준시)

/*
86400000ms는 1day를 의미한다.
1s = 1,000ms
1m = 60s * 1,000ms = 60,000ms
1h = 60m * 60,000ms = 3,600,000ms
1d = 24h * 3,600,000ms = 86,400,000ms
*/
new Date(86400000); // -> Fri Jan 02 1970 09:00:00 GMT+0900 (대한민국 표준시)
```

## **1.3 new Date(dateString)**

Date 생성자 함수에 날짜와 시간을 나타내는 문자열을 인수로 전달하면 지정된 날짜와 시간을 Date 객체를 반환한다. 이때 인수로 전달한 문자열은 Date.parse 메서드에 의해 해석 가능한 형식이어야 한다.

```jsx
new Date('May 26, 2020 10:00:00');
// -> Tue May 26 2020 10:00:00 GMT+0900 (대한민국 표준시)

new Date('2020/03/26/10:00:00');
// -> Thu Mar 26 2020 10:00:00 GMT+0900 (대한민국 표준시)
```

## **1.4 new Date(year, month, day…)**

Date 생성자 함수에 연, 월, 일, 시, 분, 초, 밀리초를 의미하는 숫자를 인수로 전달하면 지정된 날짜와 시간을 나타내는 Date 객체를 반환한다. 이때 연, 월은 반드시 지정해야 한다.

| **인수** | **내용** |
| --- | --- |
| year | 연을 나타내는 1900년 이후의 정수. 0부터 99는 1900부터 1999로 처리된다. |
| month | 월을 나타내는 0 ~ 11까지의 정수(주의: 0부터 시작, 0 = 1월) |
| day | 일을 나타내는 1 ~ 31까지의 정수 |
| hour | 시를 나타내는 0 ~ 23까지의 정수 |
| minute | 분을 나타내는 0 ~ 59까지의 정수 |
| second | 초를 나타내는 0 ~ 59까지의 정수 |
| millisecond | 밀리초를 나타내는 0 ~ 999까지의 정수 |

```jsx
new Date(2020, 2); // 2020-02-29T15:00:00.000Z
new Date(2020, 2, 26, 10, 0, 0, 0); // 2020-03-26T01:00:00.000Z

// 가독성이 훨씬 좋다.
new Date('2020/2/26/10:00:00:00'); // 2020-02-26T01:00:00.000Z
```

# **2. Date 메서드**

## **2.1 Date.now**

1970년 1월 1일 00:00:00(UTC) 을 기점으로 현재 시간까지 경과한 밀리초를 숫자로 반환한다.

```jsx
Date.now(); // 1692105562943
```

## **2.2 Date.parse**

1970년 1월 1일 00:00:00(UTC)을 기점으로 인수로 전달된 지정시간(new Date(dateString)) 까지의 밀리초를 숫자로 반환한다.

```jsx
Date.parse('Jan 2, 1970 00:00:00 UTC'); // 86400000
Date.parse('Jan 2, 1970 00:00:00'); // 54000000
Date.parse('2023/08/16/10:00:00'); // 1692147600000
```

## **2.3 Date.UTC**

1970년 1월 1일 00:00:00(UTC)을 기점으로 인수로 전달된 지정 시간까지의 밀리초를 숫자로 반환한다.

Date.UTC 메서드는 new Date(year, month[, day…]와 같은 형식의 인수를 사용해야 한다.

```jsx
Date.UTC(1970, 0, 2); // 86400000
Date.UTC('2020/02/02'); // NaN
```

## **2.4 Date 메서드들**

```jsx
// Date.prototype.getFullYear
// Date 객체의 연도를 나타내는 정수를 반환한다.
new Date('2020/07/23').getFullYear(); // 2020

// Date.prototype.setFullYear
// Date 객체의 연도를 나타내는 정수를 설정한다. 연도 이외에 옵션으로 월, 일도 설정할 수 있다.
const today = new Date();

// 년도 지정
today.setFullYear(2000);
today.getFullYear(); // 2000

// 년도/월/일 지정
today.setFullYear(2023, 0, 2);
today.getFullYear(); // 2023

// Date.prototype.getMonth
// Date 객체의 월을 나타내는 0 ~ 11의 정수를 반환한다. 1월은 0, 12월은 11이다.
new Date('2023/08/14').getMonth(); // 6

// Date.prototype.setMonth
// Date 객체의 월을 나타내는 0 ~ 11의 정수를 설정한다.
const today = new Date();

// 월 지정
today.setMonth(0); // 1월
today.getMonth(); // 0

// 월/일 지정
today.setMonth(11, 1); // 12월 1일
today.getMonth(); // 11

// Date.prototype.getDate
// Date 객체의 날짜(1 ~ 31)를 나타내는 정수를 반환한다.
new Date('2023/08/15').getDate(); // 24

// Date.prototype.setDate
// Date 객체의 날짜(1 ~ 31)를 나타내는 정수를 설정한다.
const today = new Date();

// 날짜 지정
today.setDate(1);
today.getDate(); // 1

// Date.prototype.getDay
// Date 객체의 요일(0 ~ 6)을 나타내는 정수를 반환한다.
new Date('2023/08/15').getDay(); // 2

// Date.prototype.getHours
// Date 객체의 시간(0 ~ 23)을 나타내는 정수를 반환한다.
new Date('2023/08/15/12:00').getHours(); // 12

// Date.prototype.setHours
// Date 객체의 시간(0 ~ 23)을 나타내는 정수를 설정한다
// 시간 이외에 옵션으로 분, 초, 밀리초도 설정할 수 있다.
const today = new Date();

// 시간 지정
today.setHours(7);
today.getHours(); // 0

// 시간/분/초/밀리초 지정
today.setHours(0, 0, 0, 0); // 00:00:00:00
today.getHours();

// Date.prototype.getMinutes
// Date 객체의 분(0 ~ 59)을 나타내는 정수를 반환한다.
new Date('2023/08/15/12:20').getMinutes(); // 20

// Date.prototype.setMinutes
// Date 객체에 분(0 ~ 59)을 나타내는 정수를 설정한다.
// 분 이외에 옵션으로 초, 밀리초도 설정할 수 있다.
const today = new Date();

// 시간 지정
today.setMinutes(5);
today.getMinutes(); // 5

// 시간/분/초/밀리초 지정
today.setMinutes(5, 10, 0); // HH:05:10:00
today.getMinutes(); // 5

// Date.prototype.getSeconds
// Date 객체의 초(0 ~ 59)를 나타내는 정수를 반환한다.
new Date('2023/08/15/12:20:10').getSeconds(); // 10

// Date.prototype.setSeconds
// Date 객체의 초(0 ~ 59)를 나타내는 정수를 설정한다.
const today = new Date();

// 시간 지정
today.setSeconds(5);
today.getSeconds(); // 5

// 시간/분/초/밀리초 지정
today.setSeconds(5, 10); // HH:MM:05:10
today.getSeconds(); // 5

// Date.prototype.getMilliseconds
// Date 객체의 밀리초(0 ~ 999)를 나타내는 정수를 반환한다.
new Date('2023/08/15/12:20:10:150').getMilliseconds(); // 150
```

## **2.5 Date Time, Timezone 메서드들**

```jsx
// Date.prototype.getTime
// 1970년 1월 1일 00:00:00(UTC)를 기점으로 Date 객체의 시간까지 경과된 밀리초를 반환한다.
new Date("2023/08/15/12:30").getTime(); // 1692070200000

// Date.prototype.setTime
// 1970년 1월 1일 00:00:00(UTC)를 기점으로 Date 객체의 시간까지 경과된 밀리초를 설정한다.
const today = new Date();

today.setTime(86400000); // 86400000은 1day를 의미

// Date.prototype.getTimezoneOffset
// UTC와 Date 객체에 지정된 locale 시간과의 차이를 분 단위로 반환한다.
// KST는 UTC에 9시간을 더한 시간이다.
const today = new Date();

today.getTimezoneOffset() / 60; // -9

// Date.prototype.toDateString
// 사람이 읽을 수 있는 문자열로 Date 객체의 날짜를 반환한다.
const today = new Date("2023/08/15/12:30");

today.toString(); // Tue Aug 15 2023 12:30:00 GMT+0900 (Korean Standard Time)
today.toDateString(); // Tue Aug 15 2023

// Date.prototype.toTimeString
// 사람이 읽을 수 있는 문자열로 Date 객체의 날짜를 반환한다.
const today = new Date("2023/08/15/12:30");

today.toTimeString(); // 12:30:00 GMT+0900 (Korean Standard Time)

// Date.prototype.toISOString
// ISO 8601 형식으로 Date 객체의 날짜와 시간을 표현한 문자열을 반환한다.
const today = new Date("2023/08/15/12:30");

today.toISOString(); // 2023-08-15T03:30:00.000Z
today.toISOString().slice(0, 10); // 2023-08-15
today.toISOString().slice(0, 10).replace(/-/g, ""); // 20230815

// Date.prototype.toLocaleString
// 인수로 전달한 로캘을 기준으로 Date 객체의 날짜와 시간을 문자열을 반환한다.
// 인수를 생략한 경우 브라우저가 동작 중인 시스템의 로캘을 적용한다.
const today = new Date("2023/08/15/12:30");

today.toLocaleString(); // 8/15/2023, 12:30:00 PM
today.toLocaleString("ko-KR"); // 2023. 8. 15. 오후 12:30:00
today.toLocaleString("en-US"); // 8/15/2023, 12:30:00 PM
today.toLocaleString("ja-JP"); // 2023/8/15 12:30:00

// Date.prototype.toLocaleTimeString
// 인수로 전달한 로캘을 기준으로 Date 객체의 시간을 문자열을 반환한다.
// 인수를 생략한 경우 브라우저가 동작 중인 시스템의 로캘을 적용한다.
const today = new Date("2023/08/15/12:30");

today.toLocaleTimeString()); // 12:30:00 PM
today.toLocaleTimeString("ko-KR"); // 오후 12:30:00
today.toLocaleTimeString("en-US"); // 12:30:00 PM
today.toLocaleTimeString("ja-JP"); // 12:30:00
```

---

# 31장 정규표현식

# **1. 정규 표현식이란?**

정규 표현식(Regular expression)은 일정한 패턴을 가진 문자열의 집합을 표현하기 위해 사용하는 형식 언어다.

정규 표현식은 문자열을 대상으로 패턴 매칭 기능을 제공한다.

```jsx
// 사용자로부터 입력받은 휴대폰 전화번호
const tel = '010-1234-567팔';

// 정규 표현식 리터럴로 휴대폰 전화번호 패턴 정의
const regExp = /^\d{3}-\d{4}-\d{4}$/;

// 패턴 매칭 확인
regExp.test(tel); // false
```

# **2. 정규 표현식의 생성**

정규 표현식 객체를 생성하기 위해서는 정규 표현식 리터럴과 RegExp 생성자 함수를 사용할 수 있다.

일반적인 방식은 정규 표현식 리터럴을 사용하는 것이다.

```jsx
const target = 'Is this all there is?';

// 패턴: is
// 플래그: i => 대소문자를 구별하지 않고 검색한다.
const regexp = /is/i;

// test 메서드는 target 문자열에 대해 정규 표현식 regexp의 패턴을 검색하여
// 매칭 결과를 불리언 값으로 반환한다.
regexp.test(target); // true

// RegExp 생성자 함수를 사용하여 RegExp 객체를 생성할 수도 있다.
const target = 'Is this all there is?';

const regexp = new RegExp(/is/i); // ES6

regexp.test(target); // true
```

# **3. RegExp 메서드**

## **3.1 RegExp.prototype.exec**

exec 메서드는 인수로 전달받은 문자열에 대해 정규 표현식의 패턴을 검색하여 매칭 결과를 배열로 반환한다.

매칭 결과가 없으면 null을 반환한다.

```jsx
const target = 'Is this all there is?';
const regexp = /is/i;

regexp.exec(target);
// [ 'Is', index: 0, input: 'Is this all there is?', groups: undefined ]
```

exec 메서드는 문자열 내의 모든 패턴을 검색하는 g 플래그를 지정해도 첫 번째 매칭 결과만 반환하므로 주의해야 한다.

## **3.2 RegExp.prototype.test**

test 메서드는 인수로 전달받은 문자열에 대해 정규 표현식의 패턴을 검색하여 매칭 결과를 불리언으로 반환한다.

```jsx
const target = 'Is this all there is?';
const regexp = /is/i;

regexp.test(target); // true
```

## **3.3 RegExp.prototype.match**

String 표준 빌트인 객체가 제공하는 match 메서드는 대상 문자열과 인수로 전달받은 정규 표현식과의 매칭 결과를 배열로 반환한다.

```jsx
const target = 'Is this all there is?';
const regexp = /is/;

target.match(regexp);

/*
[
  'Is this all there is',
  index: 0,
  input: 'Is this all there is?',
  groups: undefined
]
*/
```

- exec 메서드는 문자열 내의 모든 패턴을 검색하는 g 플래그를 지정해도 첫 번째 매칭 결과를 반환한다.
- 하지만 String.prototype.match 메서드는 g 플래그를 지정되면 모든 매칭 결과를 배여롤 반환한다.

```jsx
const target = 'Is this all there is?';
const regexp = /is/g;

target.match(regexp); // ["is", "is"]
```

# **4. 플래그**

| **플래그** | **의미** | **설명** |
| --- | --- | --- |
| i | Ignore case | 대소문자를 구별하지 않고 패턴을 검색한다. |
| g | Global | 대상 문자열 내에서 패턴과 일치하는 모든 문자열을 전역 검색한다. |
| m | Multi line | 문자열의 행이 바뀌더라도 패턴 검색을 계속한다. |

```jsx
const target = 'Is this all there is?';

// target 문자열에서 is 문자열을 대소문자를 구별하여 한 번 만 검색한다.
target.match(/is/);
// [ 'is', index: 5, input: , groups: undefined ]?'

// target 문자열에서 is 문자열을 대소문자를 구별하지 않고 한 번 만 검색한다.
target.match(/is/i);
// [ 'Is', index: 0, input: 'Is this all there is?', groups: undefined ]

// target 문자열에서 is 문자열을 대소문자를 구별하여 전역 검색한다.
target.match(/is/g); // [ 'is', 'is' ]

// target 문자열에서 is 문자열을 대소문자를 구별하지 않고 전역 검색한다.
target.match(/is/gi); // [ 'Is', 'is', 'is' ]
```

# **5. 패턴**

패턴은 / 로 열고 닫으며 문자열의 따옴표는 생략한다.

## **5.1 문자열 검색**

정규 표현식의 패턴에 문자 또는 문자열을 지정하면 검색 대상 문자열에서 패턴으로 지정한 문자 또는 문자열을 검색한다.

```jsx
const target = 'Is this all there is?';

// target 문자열에서 is 문자열을 대소문자를 구별하여 한 번 만 검색한다.
target.match(/is/);
// [ 'is', index: 5, input: , groups: undefined ]?'

// target 문자열에서 is 문자열을 대소문자를 구별하지 않고 한 번 만 검색한다.
target.match(/is/i);
// [ 'Is', index: 0, input: 'Is this all there is?', groups: undefined ]

// target 문자열에서 is 문자열을 대소문자를 구별하여 전역 검색한다.
target.match(/is/g); // [ 'is', 'is' ]

// target 문자열에서 is 문자열을 대소문자를 구별하지 않고 전역 검색한다.
target.match(/is/gi); // [ 'Is', 'is', 'is' ]
```

## **5.2 임의의 문자열 검색**

`.` 은 임의의 문자 한 개를 의미한다.

```jsx
const target = 'Is this all there is?';

// 임의의 3자리 문자열을 대소문자를 구별하여 전역 검색한다.
const regExp = /.../g;

console.log(target.match(regExp));

/*
[
  'Is ', 'thi',
  's a', 'll ',
  'the', 're ',
  'is?'
]
*/
```

## **5.3 반복 검색**

{m, n} 은 앞선 패턴이 최소 m번, 최대 n번 반복되는 문자열을 의미한다. 콤마 뒤에 공백이 있으면 정상 동작하지 않으므로 주의해야 한다.

```jsx
const target = 'A AA B BB Aa Bb AAA';

// A가 최소 1번, 최대 2번 반복되는 문자열을 전역 검색한다.
let regExp = /A{1,2}/g;

target.match(regExp) // [ 'A', 'AA', 'A', 'AA', 'A' ]

// {n}은 앞선 패턴이 n번 반복되는 문자열을 의미한다.
// -> {n} === {n, n}
regExp = /A{2}/g;

target.match(regExp); // ['AA', 'AA']

// {n,}은 앞선 패턴이 최소 n번 이상 반복되는 문자열을 의미한다.
regExp = /A{2,}/g;

target.match(regExp); // ['AA', 'AAA']

// +는 앞선 패턴이 최소 한번 이상 반복되는 문자열을 의미한다. +는 {1,}
// 'A'가 최소 한 번 이상 반복되는 문자열('A', 'AA', 'AAA',....)을 전역 검색한다.
regExp = /A+/g;

target.match(regExp); // [ 'A', 'AA', 'A', 'AAA' ]

// ?는 앞선 패턴이 최대 한 번(0번 이상) 이상 반복되는 문자열을 의미한다.
// ?는 {0,1}과 같다.
// 'colo' 다음 'u'가 최대 한 번(0번 포함) 이상 반복되고 'r'이 이어지는
// 문자열 'color', 'colour'를 전역 검색한다.
const target = 'color colour';

const regExp = /colou?r/g;
target.match(regExp); // ['color', 'colour']
```

## **5.4 OR 검색**

`|` 은 OR의 의미를 갖는다.

```jsx
const target = 'A AA B BB Aa Bb';

// 'A' 또는 'B'를 전역 검색한다.
let regExp = /A|B/g;

target.match(regExp);

/*
[
  'A', 'A', 'A',
  'B', 'B', ,B'
  'A', 'B'
]
*/

// 분해되지 않은 단어 레벨로 검색하기 위해서는 +를 함께 사용한다.
// 'A', 'AA', 'AAA', 'B', 'BB'...
regExp = /A+|B+/g;

target.match(regExp); // [ 'A', 'AA', 'B', 'BB', 'A', 'B' ]

// []내의 문자는 or로 동작한다. 그 뒤에 +를 사용하면 앞선 패턴을 한 번 이상 반복한다.
regExp = /[AB]+/g;

target.match(regExp); // [ 'A', 'AA', 'B', 'BB', 'A', 'B' ]

// 범위를 지정하려면 []내에 -를 사용한다.
const target = 'A AA BB ZZ Aa Bb';

// 'A' ~ 'Z'가 한 번 이상 반복되는 문자열을 전역 검색한다.
regExp = /[A-Z]+/g;

target.match(regExp); // [ 'A', 'AA', 'BB', 'ZZ', 'A', 'B' ]

// 대소문자를 구별하지 않고 알파벳을 검색하는 방법은 다음과 같다.
const target = 'AA BB Aa Bb 12';

// 'A' ~ 'Z' 또는 'a' ~ 'z'가 한 번 이상 반복되는 문자열을 전역 검색한다.
regExp = /[A-Za-z]+/g;

target.match(regExp); // [ 'AA', 'BB', 'Aa', 'Bb' ]
```

숫자를 검색하는 방법

```jsx
const target = 'AA BB 12,345';

// '0' ~ '9'가 한 번 이상 반복되는 문자열을 전역 검색한다.
let regExp = /[0-9]+/g;

target.match(regExp); // ['12', '345']

// 쉼표를 패턴에 포함한다면
regExp = /[0-9,]+/g;

target.match(regExp); // ['12,345']

// \d는 숫자를 의미한다.
let regExp = /[\d,]+/g;

target.match(regExp); // ['12,345']

// \D는 숫자가 아닌 문자를 의미한다.
// 숫자가 아닌 문자 또는 ','가 한 번 이상 반복되는 문자열을 전역 검색한다.
regExp = /[\D,]+/g;

target.match(regExp); // [ 'AA BB ', ',' ]

// \w는 알파벳, 숫자, 언더스코어를 의미한다.
// \w는 [A-Za-z0-9_]와 같다.
const target = 'Aa Bb 12,345 _$%&';

// 알파벳, 숫자, 언더스코어, ','가 한 번 이상 반복되는 문자열을 전역 검색한다.
let regExp = /[\w,]+/g;

target.match(regExp); // [ 'Aa', 'Bb', '12,345', '_' ]

// 알파벳, 숫자, 언더스코어가 아닌 문자 또는 ','가 한 번 이상 반복되는 문자열을 전역 검색한다.
regExp = /[\W,]+/g;

target.match(regExp); // [ ' ', ' ', ',', ' ', '$%&' ]
```

## **5.5 NOT 검색**

[…] 내의 ^은 **not**의 의미를 갖는다.

```jsx
const target = 'AA BB 12 Aa Bb';

// 숫자를 제외한 문자열을 전역 검색한다.
const regExp = /[^\d]+/g;

target.match(regExp); // [ 'AA BB ', ' Aa Bb' ]
```

## **5.6 시작 위치로 검색**

[…] 밖의 ^은 **문자열의 시작**을 의미한다. 단, […]내의 ^은 **not**의 의미를 가진다.

```jsx
const target = 'https://naver.com';

// 'https'로 시작되는지 검사한다.
const regExp = /^https/g;

regExp.test(target); // true
```

## **5.7 마지막 위치로 검색**

$는 문자열의 마지막을 의미한다.

```jsx
const target = 'https://naver.com';

// 'com'로 시작되는지 검사한다.
const regExp = /com$/g;

regExp.test(target); // true
```

# **6. 자주 사용하는 정규 표현식**

## **6.1 특정 단어로 시작하는지 검사**

```jsx
const url = 'https://naver.com';

// 'http://' 또는 'https://'로 시작하는지 검사한다.
const regExp = /^https?:\/\//;

regExp.test(target); // true
```

## **6.2 특정 단어로 끝나는지 검사**

```jsx
const fileName = 'index.html';

const regExp = /html$/;

regExp.test(fileName); // true
```

## **6.3 숫자로만 이루어진 문자열인지 검사**

처음과 끝이 숫자이고 최소 한 번 이상 반복되는 문자열검사는 다음과 같다.

```jsx
const target = '12345';

const regExp = /^\d+$/;

regExp.test(target); // true
```

## **6.4 하나 이상의 공백으로 시작하는지 검사**

`\s` 는 여러 가지 공백 문자(스페이스, 탭 등)를 의미한다.

```jsx
const target = ' Hi!';

const regExp = /^[\s]+/;

regExp.test(target); // true
```

## **6.5 아이디로 사용 가능한지 검사**

알파벳 대소문자 또는 숫자로 시작하고 끝나며 4~10자리인지 검사한다.

```jsx
const id = 'abc123';

const regExp = /^[A-Za-z0-9]{4,10}$/;

regExp.test(id); // true
```

## **6.6 메일 주소 형식에 맞는지 검사**

인터넷 메시지 형식 규약인 RFC 5322에 맞는 정교한 패턴 매칭을 사용한다면 무척이나 복잡한 패턴을 가진다.

```jsx
const email = 'abc123@gmail.com';

const regExp = /^[-0-9A-Za-z!#$%&'*+/=?^_`{|}~.]+@[-0-9A-Za-z!#$%&'*+/=?^_`{|}~]+[.]{1}[0-9A-Za-z]/;

regExp.test(email); // true
```

## **6.7 휴대폰 번호 형식에 맞는지 검사**

```jsx
const cellPhone = "010-1234-5678";

const regExp = /^\d{3,4}-\d{3,4}-\d{4,4}$;

regExp.test(cellPhone); // true
```

## **6.8 특수 문자 포함 여부 검사**

```jsx
const target = 'abc#123';

const regExp = /[^A-Za-z0-9]/gi;

regExp.test(target); // true

// 특수 문자를 제거한다면 String.prototype.replace 메서드를 사용한다.
target.replace(regExp, ''); // abc123
```

---

# 32장 String

표준 빌트인 객체인 String 객체는 생성자 함수 객체다.

→ new 연산자와 함께 호출하여 String 인스턴스를 생성할 수 있다.

```jsx
const strObj = new String();
console.log(strObj) // [String: '']
```

String 생성자 함수의 인수로 문자열을 전달하면서 new 연산자와 함께 호출하면 StringData 내부 슬롯에 인수로 전달받은 문자열을 할당한 String 래퍼 객체를 생성한다.

```jsx
const strObj = new String();
console.log(strObj); // [String: 'Son']
```

String 래퍼 객체는 배열과 마찬가지로 length 프로퍼티와 인덱스를 나타내는 숫자 형식의 문자열을 프로퍼티 키로, 각 문자를 프로퍼티 값으로 갖는 유사 배열 객체이면서 이터러블이다.

→ 배열과 유사하게 인덱스를 사용해서 각 문자에 접근할 수 있다.

```jsx
console.log(strObj[0]); // S
```

단, 문자열은 원시 값이므로 변경할 수 없다. 이때 에러는 발생하지 않는다.

```jsx
const strObj = new String('Son');
strObj[0] = 'K';
console.log(strObj); // [String: 'Son']
```

String 생성자 함수의 인수로 문자열이 아닌 값을 전달하면 인수를 문자열로 강제 변환한 후, StringData 내부 슬롯에 변환된 문자열을 할당한 String 객체 래퍼를 생성한다.

```jsx
let strObj = new String(123);
console.log(strObj); // [String: '123']

strObj = new String(null);
console.log(strObj); // [String: 'null']
```

new 연산자를 사용하지 않고 String 생성자 함수를 호출하면 String 인스턴스가 아닌 문자열을 반환한다.

→ 명시적으로 타입을 변환하기도 한다.

```jsx
// 숫자 타입 -> 문자열 타입
String(1); // "1"
String(NaN); // "NaN"
String(Infinity); // "Infinity"

// 불리언 타입 -> 문자열 타입
String(true); // "true"
String(false); // "false
```

# **2. length 프로퍼티**

length 프로퍼티는 문자열의 문자 개수를 반환한다.

```jsx
'Hello'.length; // 5
'안녕하세요!'.length; // 6
```

# **3. String 메서드**

String 객체에는 원본 String 래퍼 객체를 직접 변경하는 메서드는 존재하지 않는다.

→ String 객체의 메서드는 언제나 새로운 문자열을 반환한다.

문자열은 변경 불가능한 원시 값이기 때문에 String 래퍼 객체도 읽기 전용 객체로 제공된다.

## **3.1 String.prototype.indexOf**

indexOf 메서드는 대상 문자열에서 인수로 전달받은 문자열을 검색하여 첫 번째 인덱스를 반환한다.

검색에 실패하면 -1을 반환한다.

```jsx
const str = 'Hello World';

// 문자열 str에서 'l'을 검색하여 첫 번째 인덱스를 반환
str.indexOf('l'); // 2

// 문자열 str에서 'or'을 검색하여 첫 번째 인덱스를 반환
str.indexOf('or'); // 7

// 문자열 str에서 'x'을 검색하여 첫 번째 인덱스를 반환. 검색을 실패하여 -1 반환
str.indexOf('x'); // -1

// indexOf 메서드의 2번째 인수로 검색을 시작할 인덱스를 전달할 수 있다.

// 문자열 str에서 인덱스 3부터 'l'을 검색하여 첫 번째 인덱스를 반환
str.indexOf('l', 3); // 3
```

indexOf 메서드는 대상 문자열에 특정 문자열이 존재하는지 확인할 때 유용하다.

ES6에서 도입된 String.prototype.includes 메서드를 사용하면 가독성이 더 좋다.

```jsx
if (str.indexOf("Hello") !== -1) {
        // 문자열 str에 'Hello'가 포함되어 있는 경우에 처리할 내용
}

if (str.includes("Hello")) {
        // 문자열 str에 'Hello'가 포함되어 있는 경우에 처리할 내용
}
```

## **3.2 String.prototype.search**

search 메서드는 대상 문자열에서 인수로 전달받은 정규 표현식과 매치하는 문자열을 검색하여 일치하는 문자열의 인덱스를 반환한다. 검색에 실패하면 -1을 반환한다.

```jsx
const str = 'Hello World';

// 문자열 str에서 정규 표현식과 매치하는 문자열을 검색하여 일치하는 문자열의 인덱스를 반환
str.search(/o/); // 4
str.search(/x/); // -1
```

## **3.3 String.prototype.includes**

ES6에서 도입된 inlucdes 메서드는 대상 문자열에 인수로 전달받은 문자열이 포함되어 있는지 확인하여 그 결과를 true 또는 false로 반환한다.

```jsx
const str = 'Hello World';

str.includes('Hello'); // true
str.includes(' '); // true
str.includes('x'); // false
str.includes(); // false
```

includes 메서드에 2번째 인수로 검색을 시작할 인덱스를 전달할 수 있다.

```jsx
const str = 'Hello World';

str.includes('l', 3); // true
str.includes('H', 3); // false
```

## **3.4 String.prototype.startsWith**

ES6에서 도입된 startsWith 메서드는 대상 문자열이 인수로 전달받은 문자열로 시작하는지 확인하여 그 결과를 true or false로 반환한다.

```jsx
const str = 'Hello World';

str.startsWith('He'); // true
str.startsWith('x'); // false

// startsWith 메서드의 2번째 인수로 검색을 시작할 인덱스를 전달할 수 있다.
str.startsWith(' ', 5); // true
```

## **3.5 String.prototype.endsWith**

ES6에서 도입된 endsWith 메서드는 대상 문자열이 인수로 전달받은 문자열로 끝나는지 확인하여 그 결과를 true or false로 반환한다.

```jsx
const str = 'Hello World';

str.endsWith('ld'); // true
str.endsWith('x'); // false

// endsWith 메서드의 2번째 인수로 검색할 문자열의 길이를 전달할 수 있다.
// 문자열 str의 처음부터 5자리까지("Hello")가 "lo"로 끝나는지 확인
str.startsWith('lo', 5); // true
```

## **3.6 String.prototype.charAt**

charAt 메서드는 대상 문자열에서 인수로 전달받은 인덱스에 위치한 문자를 검색하여 반환한다.

```jsx
const str = 'Hello';

for (let i = 0; i < str.length; i++) {
  console.log(str.charAt(i)); // H e l l o
}

// 인덱스가 문자열의 범위를 벗어난 경우 빈 문자열을 반환한다.
str.charAt(5); // ""
```

## **3.7 String.prototype.substring**

substring 메서드는 대상 문자열에서 첫 번째 인수로 전달받은 인덱스에 위치하는 문자부터 두 번째 인수로 전달받은 인덱스에 위치하는 문자의 바로 이전 문자까지의 부분 문자열을 반환한다.

```jsx
const str = 'Hello World';

// 인덱스 1부터 인덱스 4 이전까지의 부분 문자열을 반환한다.
str.substring(1, 4); // ell

// substring 메서드의 두번째 인수는 생략할 수 있다.
// 이때, 첫 번째 인수로 전달한 인덱스에 위치하는 문자부터 마지막 문자까지 부분 문자열을 반환한다.
str.substring(1); // ello World
```

substring 메서드의 첫 번째 인수는 두 번째 인수보다 큰 정수이어야 정상이지만 다음과 같이 인수를 전달하여도 정상 동작한다.

```jsx
const str = 'Hello World';

// 첫 번째 인수 > 두 번째 인수인 경우 두 인수는 교환된다.
str.substring(4, 1); // ell

// 인수 < 0 또는 NaN인 경우 0으로 취급된다.
str.substring(-2); // Hello World

// 인수 > 문자열의 길이인 경우 인수는 문자열의 길이로 취급된다.
str.substring(1, 20); // ello World
str.substring(20); // ""
```

String.prototype.indexOf 메서드와 함께 사용하면 특정 문자열을 기준으로 앞뒤에 위치한 부분 문자열을 얻을 수 있다.

```jsx
const str = 'Hello World';

// 스페이스를 기준으로 앞에 있는 부분 문자열 취득
str.substring(0, str.indexOf(' ')); // Hello

// 스페이스를 기준으로 뒤에 있는 부분 문자열 취득
str.substring(str.indexOf(' ') + 1, str.length); // World
```

## **3.8 String.prototype.slice**

slice 메서드는 substring 메서드와 동일하게 동작한다.

단, slice 메서드에서는 음수인 인수를 전달할 수 있다. 음수인 인수를 전달하면 대상 문자열의 가장 뒤에서부터 시작하여 문자열을 잘라내어 반환한다.

```jsx
const str = 'Hello World';

str.substring(0, 5); // Hello
str.slice(0, 5); // Hello

str.substring(2); // llo World
str.slice(2); // llo World

// 음수인 경우 0으로 취급된다.
str.substring(-5); // Hello World
// 음수인 경우 뒤에서 5자리를 잘라낸다.
str.slice(-5); // World
```

## **3.9 String.prototype.toUpperCase // toLowerCase**

toUpperCase/toLowerCase 메서드는 대상 문자열을 모두 대문자/소문자로 변경한 문자열을 반환한다.

```jsx
const str1 = 'hello world';

str1.toUpperCase(); // HELLO WORLD

const str2 = 'HELLO WORLD';

str2.toLowerCase(); // hello world
```

## **3.11 String.prototype.trim**

trim 메서드는 대상 문자열 앞뒤에 공백 문자가 있을 경우 제거한 문자열을 반환한다.

```jsx
const str = '      foo    ';

str.trim(); // foo
```

String.prototype.trimStart, String.prototype.trimEnd를 사용하면 대상 문자열 앞 또는 뒤에 공백 문자가 있을 경우 이를 제거한 문자열을 반환한다.

```jsx
const str = '      foo    ';

str.trimStart(); // "foo    "
str.trimEnd(); // "      foo"
```

String.prototype.replace 메서드에 정규표현식을 인수로 전달하여 공백 문자를 제거할 수도 있다.

```jsx
const str = '      foo    ';

str.replace(/\s/g, ''); // "foo"
str.replace(/^\s+/g, ''); // "foo    "
str.replace(/\s+$/g, ''); // "      foo"
```

## **3.12 String.prototype.repeat**

ES6에서 도입된 repeat 메서드는 대상 문자열을 인수로 전달받은 정수만큼 반복해 연결한 새로운 문자열을 반환한다. 인수로 전달받은 정수가 0이면 빈 문자열을 반환하고, 음수이면 RangeError를 발생시킨다.

인수를 생략하면 기본값 0이 설정된다.

```jsx
const str = 'abc';

str.repeat(); // ""
str.repeat(0); // ""
str.repeat(1); // "abc"
str.repeat(2); // "abcabc"
str.repeat(2.5); // "abcabc" => (2.5 -> 2)
str.repeat(-1); // RangeError
```

## **3.13 String.prototype.replace**

replace 메서드는 대상 문자열에서 첫 번째 인수로 전달받은 문자열 또는 정규 표현식을 검색하여 두 번째 인수로 전달한 문자열로 치환한 문자열을 반환한다.

```jsx
const str = 'Hello world';

// str에서 첫 번째 인수 'world'를 검색하여 두 번째 인수 'Son'으로 치환한다.
str.replace('world', 'Son'); // Hello Son

// 검색된 문자열이 여럿 존재할 경우 첫 번째로 검색된 문자열만 치환한다.
const str = 'Hello world world';
str.replace('world', 'Son'); // Hello Son world

// 특수한 교체 패턴을 사용할 수 있다.
const str = 'Hello world';

// 특수한 교체 패턴을 사용할 수 있다. ($& -> 검색된 문자열
str.replace('world', '<string>$&</string>');

// replace 메서드의 첫 번째 인수로 정규 표현식을 전달할 수 있다.
const str = 'Hello hello';

// 'Hello"를 대소문자를 구별하지 않고 전역 검색
str.replace(/hello/gi, 'Son'); // Son Son
```

## **3.14 String.prototype.split**

split 메서드는 대상 문자열에서 첫 번째 인수로 전달한 문자열 또는 정규 표현식을 검색하여 문자열을 구분한 후 분리된 각 문자열로 이루어진 배열을 반환한다.

인수로 빈 문자열을 전달하면 각 문자를 모두 분리하고, 인수를 생략하면 대상 문자열 전체를 단일 요소로 하는 배열을 반환한다.

```jsx
const str = 'How are you doing?';

// 공백으로 구분
str.split(' '); // [ 'How', 'are', 'you', 'doing?' ]

// \s 는 여러 가지 공백 문자(스페이스, 탭 등)를 의미
str.split(/\s/); // [ 'How', 'are', 'you', 'doing?' ]

// 인수로 빈 문자열을 전달하면 각 문자를 모두 분리
str.split('');
/*
[
  'H', 'o', 'w', ' ', 'a',
  'r', 'e', ' ', 'y', 'o',
  'u', ' ', 'd', 'o', 'i',
  'n', 'g', '?'
]
*/

// 인수를 생략하면 대상 문자열 전체를 단일 요소로 하는 배열 반환
str.split(); // [ 'How are you doing?' ]

// 두 번째 인수로 배열의 길이를 지정
str.split(' ', 2); // [ 'How', 'are' ]

// 문자열 역순 만들기(Array.prototype.reverse, Array.prototype.join)
function reverseString(str) {
  return str
    .split('')
    .reverse()
    .join('');
}

reverseString(str); // ?gniod uoy era woH
```

---

# 33장 7번째 데이터 타입 Symbol

# **1. 심벌이란?**

심벌은 ES6에서 도입된 7번째 데이터 타입으로 변경 불가능한 원시 타입의 값이다.

심벌 값은 다른 값과 중복되지 않는 유일무이한 값이다. 주로 이름의 충돌 위험이 없는 유일한 프로퍼티 키를 만들기 위해 사용한다.

# **2. 심벌 값의 생성**

## **2.1 Symbol 함수**

심벌 값은 Symbol 함수를 호출하여 생성한다.

**이때 생성한 심벌 값은 외부로 노출되지 않아 확인할 수 없으며, 다른 값과 절대 중복되지 않는 유일무이한 값이다.**

```jsx
// Symbol 함수를 호출하여 유일무이한 심벌 값을 생성한다.
const mySymbol = Symbol();
console.log(typeof mySymbol); // symbol

// 심벌 값은 외부로 노출되지 않아 확인할 수 없다.
console.log(mySymbol); // Symbol()
```

Symbol 함수는 String, Number, Boolean 생성자 함수와 달리 **new 연산자와 함께 호출하지 않는다.**

```jsx
new Symbol(); // TypeError
```

Symbol 함수에는 선택적으로 문자열을 인수로 전달할 수 있다. 이 문자열은 생성된 심벌 값에 대한 설명으로 디버깅 용도로만 사용되며, 심벌 값 생성에 어떠한 영향을 주지 않는다.

→ 심벌 값에 대한 설명이 같더라도 생성된 심벌 값은 유일무이한 값이다.

```jsx
// 심벌 값에 대한 설명이 같더라도 유일무이한 심벌 값을 생성한다.
const mySymbol1 = Symbol('mySymbol');
const mySymbol2 = Symbol('mySymbol');

console.log(mySymbol1 === mySymbol2); // false

```

심벌 값도 문자열, 숫자, 불리언과 같이 객체처럼 접근하면 암묵적으로 래퍼 객체를 생성한다.

```jsx
const mySymbol = Symbol('mySymbol!!');

// 심벌도 래퍼 객체를 생성한다.
console.log(mySymbol.description); // mySymbol!!
console.log(mySymbol.toString()); // Symbol(mySymbol!!)
```

심벌 값은 암묵적으로 문자열이나 숫자 타입으로 변환되지 않는다.

```jsx
const mySymbol = Symbol();

// 심벌 값은 암묵적으로 문자열이나 숫자 타입으로 변환되지 않는다.
console.log(mySymbol + ''); // TypeError
console.log(+mySymbol); // TypeError
```

단, 불리언 타입으로는 암묵적으로 타입 변환된다. → if 문 등에서 존재 확인이 가능

```jsx
const mySymbol = Symbol();

// 불리언 타입으로는 암묵적으로 타입 변환된다.
console.log(!!mySymbol); // true

// if 문 등에서 존재 확인이 가능하다.
if (mySymbol) {
  console.log('mySymbol is not empty.');
}
// mySymbol is not empty.
```

## **2.2 Symbol.for / Symbol.keyFor 메서드**

Symbol.for 메서드는 인수로 전달받은 문자열을 키로 사용하여 키와 심벌 값의 쌍들이 저장되어 있는 전역 심벌 레지스트리에서 해당 키와 일치하는 심벌 값을 검색한다.

- 검색에 성공하면 새로운 심벌 값을 생성하지 않고 검색된 심벌 값을 반환한다.
- 검색에 실패하면 새로운 심벌 값을 생성하여 Symbol.for 메서드의 인수로 전달된 키로 전역 심벌 레지스트리에 저장한 후, 생성된 심벌 값을 반환한다.

```jsx
// 전역 심벌 레지스트리에 mySymbol 이라는 키로 저장된 심벌 값이 없으면 새로운 심벌 값을 생성
const s1 = Symbol.for('mySymbol');
// 전역 심벌 레지스트리에 mySymbol 이라는 키로 저장된 심벌 값이 있으면 해당 심벌 값을 반환
const s2 = Symbol.for('mySymbol');

console.log(s1 === s2); // true
```

Symbol 함수는 호출될 때마다 유일무이한 심벌 값을 생성한다. 이때 자바스크립트 엔진이 관리하는 심벌 값 저장소인 전역 심벌 레지스트리에서 심벌 값을 검색할 수 있는 키를 지정할 수 없으므로 전역 심벌 레지스트리에 등록되어 관리되지 않는다.

Symbol.for 메서드를 사용하면 애플리케이션 전역에서 중복되지 않는 유일무이한 상수인 심벌 값을 단 하나만 생성하여 전역 심벌 레지스트리를 통해 공유할 수 있다.

Symbol.keyFor 메서드를 사용하면 전역 심벌 레지스트리에 저장된 심벌 값의 키를 추출할 수 있다.

```jsx
// 전역 심벌 레지스트리에 mySymbol 이라는 키로 저장된 심벌 값이 없으면 새로운 심벌 값을 생성
const s1 = Symbol.for('mySymbol');
// 전역 심벌 레지스트리에 저장된 심벌 값의 키를 추출
Symbol.keyFor(s1); // mySymbol

// Symbol 함수를 호출하여 생성한 심벌 값은 전역 심벌 레지스트리에 등록되어 관리되지 않는다.
const s2 = Symbol('foo');
Symbol.keyFor(s2); // undefined
```

# **3. 심벌과 상수**

4방향, 즉 위, 아래, 왼쪽, 아래쪽을 나타내는 상수를 심벌로 정의한다면

```jsx
const Direction = {
  UP: Symbol('up'),
  DOWN: Symbol('down'),
  LEFT: Symbol('left'),
  RIGHT: Symbol('right'),
};

const myDirection = Direction.UP;

if (myDirection === Direction.UP) {
  console.log('위로 갑니다.'); // 위로 갑니다.
}
```

# **4. 심벌과 프로퍼티 키**

객체의 프로퍼티 키는 빈 문자열을 포함하는 모든 문자열 또는 심벌 값으로 만들 수 있으며, 동적으로 생성할 수도 있다.

심벌 값으로 프로퍼티 키를 동적 생성하여 프로퍼티를 만든다면 다음과 같다.

심벌 값을 프로퍼티 키로 사용하려면 프로퍼티 키로 사용할 심벌 값에 대괄호를 사용해야 한다.

프로퍼티에 접근할 때도 마찬가지로 대괄호를 사용해야 한다.

```jsx
const obj = {
  // 심벌 값으로 프로퍼티 키를 생성
  [Symbol.for('mySymbol')]: 1,
};

console.log(obj[Symbol.for('mySymbol')]); // 1
```

**심벌 값은 유일무이한 값이므로 심벌 값으로 프로퍼티 키를 만들면 다른 프로퍼티 키와 절대 충돌하지 않는다.**

# **5. 심벌과 프로퍼티 은닉**

심벌 값을 프로퍼티 키로 생성한 프로퍼티는 `for…in` , `Object.keys` , `Object.getOwnPropertyNames` 메서드로 찾을 수 없다.

이처럼 심벌 값을 프로퍼티 키로 사용하여 프로퍼티를 생성하면 외부에 노출할 필요가 없는 프로퍼티를 은닉할 수 있다.

```jsx
const obj = {
  // 심벌 값으로 프로퍼티 키를 생성
  [Symbol('mySymbol')]: 1,
};

for (const key in obj) {
  console.log(key); // 아무것도 출력되지 않는다.
}

console.log(Object.keys(obj)); // []
console.log(Object.getOwnPropertyNames(obj)); // []
```

ES6에서 도입된 Object.getOwnPropertySymbols 메서드를 사용하면 심벌 값을 프로퍼티 키로 사용하여 생성한 프로퍼티를 찾을 수 있다.

```jsx
const obj = {
  // 심벌 값으로 프로퍼티 키를 생성
  [Symbol('mySymbol')]: 1,
};

console.log(Object.getOwnPropertySymbols(obj)); // [Symbol(mySymbol)]

// getOwnPropertySymbols 메서드로 심벌 값도 찾을 수 있다.
const symbolKey = Object.getOwnPropertySymbols(obj)[0];
console.log(obj[symbolKey]); // 1
```

# **6. 심벌과 표준 빌트인 객체 확장**

표준 빌트인 객체는 읽기 전용으로 사용하는 것이 좋다.

```jsx
// 표준 빌트인 객체를 확장하는 것은 권장하지 않는다.
Array.prototype.sum = function() {
  return this.reduce((acc, cur) => acc + cur, 0);
}
[1, 2].sum(); // 3
```

- 이유 : 개발자가 직접 추가한 메서드와 미래에 표준 사용으로 추가될 메서드의 이름이 중복될 수 있기 때문이다.
- 하지만 중복될 가능성이 없는 심벌 값으로 프로퍼티 키를 생성하여 표준 빌트인 객체를 확장하면 표준 빌트인 객체의 기존 프로퍼티 키와 충돌하지 않는 것은 물론, 표준 사양의 버전이 올라감에 따라 추가될지 모르는 어떤 프로퍼티 키와도 충돌할 위험이 없어 안전하게 표준 빌트인 객체를 확장할 수 있다.

```jsx
Array.prototype[Symbol.for('sum')] = function() {
  return this.reduce((acc, cur) => acc + cur, 0)
}
[1, 2][Symbol.for('sum')](); // 3
```

# **7. Well-known Symbol**

자바스크립트가 기본 제공하는 빌트인 심벌 값이 있다.

브라우저 콘솔에서 Symbol 함수를 참조하면 다음과 같다.

https://github.com/kses1010/sunny-devlog/assets/49144662/de509a12-0b9e-46eb-b9de-08fbff58c562

자바스크립트가 기본 제공하는 심벌 값을 ECMAScript 사양에서는 **Well-known Symbol** 이라 부른다.

Well-known Symbol 은 자바스크립트 엔진의 내부 알고리즘에 사용된다.

> 심벌은 중복되지 않는 상수 값을 생성하는 것은 물론 기존에 작성된 코드에 영향을 주지 않고 새로운 프로퍼티를 추가하기 위해, 즉 하위 호환성을 보장하기 위해 도입되었다.
> 

---

# 34장 이터러블

# **1. 이터레이션 프로토콜**

ES6에서 도입된 이터레이션 프로토콜은 순회 가능한 데이터 컬렉션을 만들기 위해 ECMAScript 사양에 정의하여 미리 약속한 규칙이다.

이터레이션 프로토콜에는 이터러블 프로토콜과 이터레이터 프로토콜이 있다.

## **1.1 이터러블**

이터러블 프로토콜은 준수한 객체를 이터러블이라 한다.

→ 이터러블은 Symbol.iterator를 프로퍼티 키로 사용한 메서드를 직접 구현하거나 프로토타입 체인을 통해 상속받은 객체를 말한다.

```jsx
const isIterable = v => v !== null && typeof v[Symbol.iterator] === 'function';

// 배열, 문자열, Map, Set 등은 이터러블이다.
isIterable([]); // true
isIterable(''); // true
isIterable(new Map()); // true
isIterable(new Set()); // true
isIterable({}); // false
```

이터러블은 `for...of` 문으로 순회할 수 있으며, 스프레드 문법과 배열 디스트럭처링 할당의 대상으로 사용할 수 있다.

```jsx
const array = [1, 2, 3];

// 배열은 Array.prototype 의 Symbol.iterator 메서드를 상속받은 이터러블이다.
console.log(Symbol.iterator in array); // true

// 이터러블인 배열은 for...of 문으로 순회 가능하다.
for (const item of array) {
  console.log(item);
}

// 이터러블인 배열은 스프레드 문법의 대상으로 사용할 수 있다.
console.log([...array]); // [1, 2, 3]

// 이터러블인 배열은 배열 디스트럭처링 할당의 대상으로 사용할 수 있다.
const [a, ...rest] = array;
console.log(a, rest); // 1, [2, 3]
```

Symbol.iterator 메서드를 직접 구현하지 않거나 상속받지 않은 일반 객체는 이터러블 프로토콜을 준수한 이터러블이 아니다.

→ 일반 객체는 `for...of` 문으로 순회할 수 없으며 스프레드 문법과 배열 디스트럭처링 할당의 대상으로 사용할 수 없다.

```jsx
const obj = { a: 1, b: 2 };

// 일반 객체는 Symbol.iterator 메서드를 구현하거나 상속받지 않는다.
// 일반 객체는 이터러블 프로토콜을 준수한 이터러블이 아니다.
console.log(Symbol.iterator in obj); // false

// 이터러블이 아닌 일반 객체는 for...of 문으로 순회할 수 없다.
for (const item of obj) {
  // TypeError
  console.log(item);
}

// 이터러블이 아닌 일반 객체는 배열 디스트럭처링 할당의 대상으로 사용할 수 없다.
const [a, b] = obj; // TypeError
```

2020년 7월 현재, 스프레드 프로퍼티 제안은 일반 객체에 스프레드 문법의 사용을 허용한다.

```jsx
const obj = { a: 1, b: 2 };

// 스프레드 프로퍼티 제안은 객체 리터럴 내부에서 스프레드 문법의 사용을 허용한다.
console.log({ ...obj }); // { a: 1, b: 2 }
```

## **1.2 이터레이터**

이터러블의 Symbol.iterator 메서드가 반환한 이터레이터는 next 메서드를 갖는다.

```jsx
// 배열은 이터러블 프로토콜을 준수한 이터러블이다.
const array = [1, 2, 3];

// Symbol.iterator 메서드는 이터리이터를 반환한다.
const iterator = array[Symbol.iterator]();

// Symbol.iterator 메서드가 반환한 이터리이터는 next 메서드를 갖는다.
console.log('next' in iterator); // true
```

next 메서드를 호출하면 이터러블을 순차적으로 한 단계씩 순회하며 순회 결과를 나타내는 **이터레이터 리절트 객체**를 반환한다.

```jsx
// 배열은 이터러블 프로토콜을 준수한 이터러블이다.
const array = [1, 2, 3];

// Symbol.iterator 메서드는 이터리이터를 반환한다.
const iterator = array[Symbol.iterator]();

// 이터레이터 리절트 객체는 value 와 done 프로퍼티를 갖는 객체다.
console.log(iterator.next());
console.log(iterator.next());
console.log(iterator.next());
console.log(iterator.next());

/*
    { value: 1, done: false }
    { value: 2, done: false }
    { value: 3, done: false }
    { value: undefined, done: true }
*/
```

# **2. 빌트인 이터러블**

표준 빌트인 객체들은 빌트인 이터러블이다.

- Array
- String
- Map
- Set
- TypedArray
- arguments
- DOM 컬렉션

# **3. for…of 문**

`for...of` 문은 이터러블을 순회하면서 이터러블의 요소를 변수에 할당한다.

`for...of` 문은 내부적으로 이터레이터의 next 메서드를 호출하여 이터러블을 순회하며 next 메서드가 반환한 이터레이터 리절트 객체의 value 프로퍼티 값을 `for...of` 문의 변수에 할당한다.

이터레이터 리절트 객체의 done 프포퍼티 값이 false이면 이터러블의 순회를 계속하고 true면 이터러블의 순회를 중단한다.

```jsx
for (const item of [1, 2, 3]) {
  // item 변수에 순차적으로 1, 2, 3 이 할당
  console.log(item); // 1, 2, 3
}
```

위 예제의 내부동작은 다음과 같다.

```jsx
// 이터러블
const iterable = [1, 2, 3];

// 이터러블의 Symbol.iterator 메서드를 호출하여 이터레이터를 생성한다.
const iterator = iterable[Symbol.iterator]();

for (;;) {
  // 이터레이터의 next 메서드를 호출하여 이터러블을 순회한다.
  const res = iterator.next();

  // next 메서드가 반환한 이터레이터 리절트 객체의 done 프로퍼티 값이 true 이면 이터러블의 순회를 중단한다.
  if (res.done) break;

  // 이터레이터 리절트 객체의 value 프로퍼티 값을 item 변수에 할당한다.
  const item = res.value;
  console.log(item); // 1, 2, 3
}
```

# **4. 이터러블과 유사 배열 객체**

유사 배열 객체는 length 프로퍼티를 갖기 때문에 for 문으로 순회할 수 있고, 인덱스를 나타내는 숫자 형식의 문자열을 프로퍼티 키로 가지므로 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있다.

```jsx
// 유사 배열 객체
const arrayLike = {
  0: 1,
  1: 2,
  2: 3,
  length: 3,
};

// 유사 배열 객체는 length 프로퍼티를 갖기 때문에 for 문으로 순회할 수 있다.
for (let i = 0; i < arrayLike.length; i++) {
  // 유사 배열 객체는 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있다.
  console.log(arrayLike[i]); // 1 2 3
}
```

유사 배열 객체는 이터러블이 아닌 일반 객체다.

→ 유사 배열 객체에는 Symbol.iterator 메서드가 없기 때문에 `for...of` 문으로 순회할 수 없다.

```jsx
for (const item of arrayLike) {
  console.log(item); // TypeError
}
```

ES6에서 도입된 Array.from 메서드를 사용하여 배열로 간단히 변환할 수 있다.

Array.from 메서드는 유사 배열 객체 또는 이터러블을 인수로 전달받아 배열로 변환하여 반환한다.

```jsx
// 유사 배열 객체
const arrayLike = {
  0: 1,
  1: 2,
  2: 3,
  length: 3,
};

// Array.from은 유사 배열 객체 또는 이터러블을 배열로 반환한다.
const arr = Array.from(arrayLike);
console.log(arr); // [1, 2, 3]
```

# **5. 이터레이션 프로토콜의 필요성**

이터레이션 프로토콜은 다양한 데이터 공급자가 하나의 순회 방식을 갖도록 규정하여 데이터 소비자가 효율적으로 다양한 데이터 공급자를 사용할 수 있도록 **데이터 소비자와 데이터 공급자를 연결하는 인터페이스의 역할을 한다.**

# **6. 사용자 정의 이터러블**

## **6.1 사용자 정의 이터러블 구현**

```jsx
// 피보나치 수열을 구현한 사용자 정의 이터러블
const fibonacci = {
  // Symbol.iterator 메서드를 구현하여 이터러블 프로토콜을 준수한다.
  [Symbol.iterator]() {
    let [pre, cur] = [0, 1];
    const max = 10; // 수열의 최대값

    // next 메서드는 이터레이터 리절트 객체를 반환한다.
    return {
      next() {
        [pre, cur] = [cur, pre + cur];
        // 이터레이터 리절트 객체를 반환한다.
        return { value: cur, done: cur >= max };
      },
    }
  },
};

// 이터러블인 fibonacci 객체를 순회할 때마다 next 메서드가 호출한다.
for (const num of fibonacci) {
  console.log(num); // 1 2 3 5 8
}
```

이터러블은 `for...of` 문뿐만 아니라 스프레드 문법, 배열 디스트럭처링 할당에도 사용할 수 있다.

```jsx
// 이터러블은 스프레드 문법의 대상이 될 수 있다.
const arr = [...fibonacci];
console.log(arr); // [1, 2, 3, 5, 8]

// 이터러블은 배열 디스트럭처링 할당의 대상이 될 수 있다.
const [first, second, ...rest] = fibonacci;
console.log(first, second, rest); // 1 2 [3, 5, 8]
```

## **6.2 이터러블을 생성하는 함수**

수열의 최대값을 인수로 전달받아 이터러블을 반환하는 함수를 만들 수 있다.

```jsx
// 피보나치 수열을 구현한 사용자 정의 이터러블
const fibonacci = function(max) {
  let [pre, cur] = [0, 1];

  // Symbol.iterator 메서드를 구현한 이터러블을 반환한다.
  return {
    [Symbol.iterator]() {
      return {
        next() {
          [pre, cur] = [cur, pre + cur];
          return { value: cur, done: cur >= max };
        },
      }
    },
  }
};

for (const num of fibonacci(10)) {
  console.log(num); // 1 2 3 5 8
}
```

## **6.3 이터러블이면서 이터레이터인 객체를 생성하는 함수**

이터러블이면서 이터레이터 객체를 생성하여 반환하는 함수는 다음과 같다.

```jsx
const fibonacci = function (max) {
    let [pre, cur] = [0, 1];

    // Symbol.iterator 메서드를 구현한 이터러블을 반환한다.
    return {
        [Symbol.iterator]() {
            return this;
        },
        // next 메서드는 이터레이터 리절트 객체를 반환
        next() {
            [pre, cur] = [cur, pre + cur];
            return {value: cur, done: cur >= max};
        }

    }
};

// iter는 이터러블이면서 이터레이터
let iter = fibonacci(10);

for (const num of iter) {
    console.log(num); // 1 2 3 5 8
}

iter = fibonacci(10);

// iter는 이터레이터이므로 이터레이션 리절트 객체를 반환하는 next 메서드르 소유한다.
console.log(iter.next());
console.log(iter.next());
console.log(iter.next());
console.log(iter.next());
console.log(iter.next());
console.log(iter.next());

/*
    { value: 1, done: false }
    { value: 2, done: false }
    { value: 3, done: false }
    { value: 5, done: false }
    { value: 8, done: false }
    { value: 13, done: true }
/*
```

## **6.4 무한 이터러블과 지연 평가**

```jsx
const fibonacci = function() {
  let [pre, cur] = [0, 1];

  // Symbol.iterator 메서드를 구현한 이터러블을 반환한다.
  return {
    [Symbol.iterator]() {
      return this;
    },
    // next 메서드는 이터레이터 리절트 객체를 반환
    next() {
      [pre, cur] = [cur, pre + cur];
      // 무한을 구현하므로 done 프로퍼티를 생략
      return { value: cur };
    },
  }
}

for (const num of fibonacci()) {
  if (num > 10000) break;
  console.log(num); // 1 2 3 5 8... 4181 6765
}

// 배열 디스트럭처링 할당을 통해 무한 이터러블에서 3개의 요소만 취득한다.
const [f1, f2, f3] = fibonacci();
console.log(f1, f2, f3); // 1 2 3
```

---

# **35장 스프레드 문법**

ES6에서 도입된 스프레드 문법 `...` 은 하나로 뭉쳐 있는 여러 값들의 집합을 펼쳐서 개별적인 값들의 목록으로 만든다.

스프레드 문법을 사용할 수 있는 대상은 `for...of` 문으로 순회할 수 있는 이터러블에 한정된다.

```jsx
// ...[1, 2, 3]은 [1, 2, 3]을 개별 요소로 분리한다.(-> 1, 2, 3)
console.log(...[1, 2, 3]); // 1 2 3

// 문자열은 이터러블이다.
console.log(...'Hello'); // H e l l o

// Map과 Set은 이터러블이다.
console.log(
  ...new Map([
    ['a', '1'],
    ['b', '2'],
  ]);
) // [ 'a', '1' ] [ 'b', '2' ]
console.log(...new Set([1, 2, 3])); // 1 2 3

// 이터러블이 아닌 일반 객체는 스프레드 문법의 대상이 될 수 없다.
console.log(...{ a: 1, b: 2 }); // TypeError
```

스프레드 문법의 결과는 값이 아니라 변수에 할당할 수 없다.

```jsx
// 스프레드 문법의 결과는 값이 아니다.
const list = ...[1, 2, 3]; // SyntaxError
```

사용하는 문맥은 다음과 같다.

# **1. 함수 호출문의 인수 목록에서 사용하는 경우**

```jsx
const arr = [1, 2, 3];

// 배열 arr의 요소 중에서 최대값을 구하기 위해 Math.max를 사용한다.
const max = Math.max(arr); // NaN
```

Math.max 메서드는 매개변수 개수를 확정할 수 없는 가변 인자 함수다.

Math.max 메서드에 숫자가 아닌 배열을 인수로 전달하면 최대값을 구할 수 없어 NaN을 반환한다.

이 같은 문제를 해결하기 위해 배열을 펼쳐서 요소들을 개별적인 값들의 목록으로 만들고 Math.max 메서드의 인수로 전달해야 한다.

```jsx
var arr = [1, 2, 3];

var max = Math.max.apply(null, arr); // 3

// 스프레드 문법을 사용한다면
const arr = [1, 2, 3];

const max = Math.max(...arr); // 3
```

스프레드 문법은 Rest 파라미터와 형태가 동일하여 혼동할수 있으므로 주의할 필요가 있다.

```jsx
// Rest 파라미터는 인수들의 목록을 배열로 전달 받는다.
function foo(...rest) {
    console.log(rest); // 1, 2, 3 -> [1, 2, 3]
}

// 스프레드 문법은 배열과 같은 이터러블을 펼쳐서 개별적인 값들의 목록을 만든다.
// 1, 2, 3
foo(...[1, 2, 3];
```

# **2. 배열 리터럴 내부에서 사용하는 경우**

ES5에서 사용하는 방식과 비교하여 좀 더 간결하고 가독성좋게 표현할 수 있다.

## **2.1 concat**

```jsx
// ES5
var arr = [1, 2].concat([3, 4]);
console.log(arr); // [1, 2, 3, 4]

// ES6
const arr = [...[1, 2], ...[3, 4]];
console.log(arr); // [1, 2, 3, 4];
```

## **2.2 splice**

```jsx
// ES5
var arr1 = [1, 4];
var arr2 = [2, 3];

// 세 번째 인수 arr2를 해체하여 전달해야 한다.
// 그렇지 않으면 arr1에 arr2 배열 자체가 추가된다.
arr1.splice(1, 0, arr2);

// 기대값은 [1, 2, 3, 4]지만
console.log(arr1); // [1, [2, 3], 4];

// 다음처럼 코드가 추가되어야 한다.
Array.prototype.splice.apply(arr1, [1, 0].concat(arr2));
console.log(arr1); // [1, 2, 3, 4]
```

스프레드 문법을 사용하면 더욱 간결하고 가독성 좋게 표현할 수 있다.

```jsx
let arr1 = [1, 4]
let arr2 = [2, 3]

arr1.splice(1, 0, ...arr2);
console.log(arr1); // [1, 2, 3, 4];
```

## **2.3 배열 복사**

ES5에선 배열을 복사하려면 slice 메서드를 사용해야 한다.

```jsx
var origin = [1, 2];
var copy = origin.slice();

console.log(copy); // [1, 2]
console.log(origin === copy); // false
```

스프레드 문법 사용

```jsx
let origin = [1, 2];
let copy = [...origin];

console.log(copy) // [1, 2];
console.log(origin === copy); // false
```

## **2.4 이터러블을 배열로 변환**

ES5에서 이터러블을 배열로 변환하려면 apply 또는 call 메서드를 사용하여 slice 메서드를 호출해야 한다.

```jsx
function sum() {
  // 이터러블이면서 유사 배열 객체인 arguments 를 배열로 변환
  var args = Array.prototype.slice.call(arguments);

  return args.reduce(function(pre, cur) {
    return pre + cur;
  }, 0);
}

console.log(sum(1, 2, 3)); // 6
```

이터러블뿐만 아니라 이터러블이 아닌 유사 배열 객체도 배열로 변환할 수 있다.

```jsx
const arrayLike = {
  0: 1,
  1: 2,
  2: 3,
  length: 3,
};

const arr = Array.prototype.slice.call(arrayLike); // [1, 2, 3]
console.log(Array.isArray(arr)); // true
```

스프레드 문법을 사용하면 좀 더 간편하게 이터러블을 배열로 변환할 수 있다.

```jsx
function sum() {
  // 이터러블이면서 유사 배열 객체인 arguments 를 배열로 변환
  return [...arguments].reduce((pre, cur) => pre + cur, 0);
}

console.log(sum(1, 2, 3)); // 6
```

이보다 더 나은 방법은 Rest 파라미터를 사용하는 것이다.

```jsx
const sum = (...args) => args.reduce((pre, cur) => pre + cur, 0);

console.log(sum(1, 2, 3));
```

단, 이터러블이 아닌 유사 배열 객체는 스프레드 문법의 대상이 될 수 없다.

```jsx
const arrayLike = {
  0: 1,
  1: 2,
  2: 3,
  length: 3,
};

const arr = [...arrayLike]; // TypeError
```

이터러블이 아닌 유사 배열 객체를 배열로 변경하려면 ES6에서 도입된 Array.from 메서드를 사용한다.

```jsx
// Array.from 은 유사 배열 객체 또는 이터러블을 배열로 변환한다.
Array.from(arrayLike); // [1, 2, 3]
```

# **3. 객체 리터럴 내부에서 사용하는 경우**

스프레드 문법의 대상은 이터러블이어야 하지만 스프레드 프로퍼티 제안은 일반 객체를 대상으로도 스프레드 문법의 사용을 허용한다.

```jsx
// 스프레드 프로퍼티
// 객체 복사(얕은 복사)
const obj = { x: 1, y: 2 };
const copy = { ...obj };
console.log(copy); // { x: 1, y: 2 }
console.log(obj === copy); // false

// 객체 병합
const merged = { x: 1, y: 2, ...{ a: 3, b: 4 } };
console.log(merged); // { x: 1, y: 2, a: 3, b: 4 }
```

스프레드 프로퍼티는 Object.assign 메서드를 대체할 수 있는 간편한 문법이다.

```jsx
// 객체 병합, 프로퍼티가 중복되는 경우 뒤에 위치한 프로퍼티가 우선권을 갖는다.
const merged = { ...{ x: 1, y: 2 }, ...{ y: 10, z: 3 } };
console.log(merged); // { x: 1, y: 10, z: 3 }

// 특정 프로퍼티 변경
const changed = { ...{ x: 1, y: 2 }, y: 100 };
console.log(changed) // { x: 1, y: 100 }

// 프로퍼티 추가
const added = { ...{ x: 1, Y: 2 }, z: 0 };
console.log(added) // { x: 1, Y: 2, z: 0 }
```

---

# **36장 디스트럭처링 할당**

디스트럭처링 할당은 구조화된 배열과 같은 이터러블 또는 객체를 destructuring하여 1개 이상의 변수에 개별적으로 할당하는 것을 말한다.

배열과 같은 이터러블 또는 객체 리터럴에서 필요한 값만 추출하여 변수에 할당할 때 유용하다.

# **1. 배열 디스트럭처링 할당**

ES5에서 구조화된 배열을 디스트럭처링 하여 1개 이상의 변수에 할당하는 방법은 다음과 같다.

```jsx
var arr = [1, 2, 3];

var one = arr[0];
var two = arr[1];
var three = arr[2];

console.log(one, two, three); // 1 2 3
```

**ES6 배열 디스트럭처링 할당의 대상은 이터러블이어야 하며, 할당 기준은 배열의 인덱스다.**

```jsx
const arr = [1, 2, 3];

const [one, two, three] = arr;

console.log(one, two, three); // 1 2 3
```

배열 디스트럭처링 할당을 위해서는 할당 연산자 왼쪽에 값을 할당받을 변수를 선언해야 한다.

이때 배열 리터럴 형태로 선언한다.

```jsx
const [x, y] = [1, 2];

// 우변에 이터러블을 할당하지 않으면 에러가 발생한다.
const [x, y]; // SyntaxError

const [a, b] = {}; // TypeError
```

배열 디스트럭처링 할당의 변수 선언문은 다음처럼 선언과 할당을 분리할 수도 있다. const 키워드는 변수를 선언할 수 없으므로 권장하지 않는다.

```jsx
let x, y;
[x, y] = [1, 2];
```

배열 디스트럭처링 할당의 기준은 배열의 인덱스다. 즉, 순서대로 할당된다.

```jsx
const [a, b] = [1, 2];
console.log(a, b) // 1 2

const [c, d] = [1];
console.log(c, d); // 1 undefined

const [e, f] = [1, 2, 3];
console.log(e, f); // 1 2

const [g, , h] = [1, 2, 3];
console.log(g, h); // 1 3
```

배열 디스트럭처링 할당을 위한 변수에 기본값을 설정할 수 있다.

```jsx
// 기본값
const [a, b, c = 3] = [1, 2];
console.log(a, b, c); // 1 2 3

// 기본값보다 할당된 값이 우선한다.
const [e, f = 10, g = 3] = [1, 2];
console.log(e, f, g); //  1 2 3
```

배열 디스트럭처링 할당을 위한 변수에 Rest 파라미터와 유사하게 Rest 요소를 사용할 수 있다.

```jsx
// Rest 요소
const [x, ...y] = [1, 2, 3];
console.log(x, y); // 1 [2, 3]
```

# **2. 객체 디스트럭처링 할당**

ES5에서 객체의 각 프로퍼티를 객체로부터 디스트럭처링하여 변수에 할당하기 위해서는 프로퍼티 키를 사용해야 한다.

```jsx
var user = {
  firstName: 'Sunny',
  lastName: 'Son',
};

var firstName = user.firstName;
var lastName = user.lastName;

console.log(firstName, lastName); // Sunny Son
```

ES6의 객체 디스트럭처링 할당은 객체의 각 프로퍼티를 객체로부터 추출하여 1개 이상의 변수에 할당한다.

객체 디스트럭처링 할당의 대상은 객체이어야 하며, **할당 기준은 프로퍼티 키다.**

```jsx
const user = {
  firstName: 'Sunny',
  lastName: 'Son',
};

// 프로퍼티 키를 기준으로 디스트럭처링 할당이 이루어진다. 순서는 의미가 없다.
const { lastName, firstName } = user;

console.log(firstName, lastName); // Sunny Son
```

객체 디스트럭처링 할당을 위해서는 할당 연산자 왼쪽에 프로퍼티 값을 할당받을 변수를 선언해야 한다.

```jsx
const { lastName, firstName } = { firstName: 'Sunny', lastName: 'Son' };
```

우변에 객체 또는 객체로 평가될 수 있는 표현식을 할당하지 않으면 에러가 발생한다.

```jsx
const {lastName, firstName}; // SyntaxError

const {lastName, firstName} = null; // TypeError
```

객체 리터럴 형태로 선언한 lastName, firstName이다. 프로퍼티 축약 표현을 통해 선언한 것이다.

```jsx
const { lastName, firstName } = user;
// 위와 아래는 동치다.
const { lastName: lastName, firstName: firstName } = user;
```

객체의 프로퍼티 키와 다른 변수 이름으로 프로퍼티 값을 할당받으려면 다음과 같이 변수를 선언한다.

```jsx
const user = {
  firstName: 'Sunny',
  lastName: 'Son',
};

// 프로퍼티 키를 기준으로 디스트럭처링 할당이 이루어진다.
// 프로퍼티 키를 변수 선언과 함께 따로 할당한다.
const { lastName: ln, firstName: fn } = user;

console.log(fn, ln); // Sunny Son
```

객체 디스트럭처링 할당을 위한 변수에 기본값을 설정할 수 있다.

```jsx
const { firstName = 'Cloud', lastName } = { lastName: 'Kim' };
console.log(firstName, lastName); // Cloud Kim

const { lastName: ln, firstName: fn = 'Sunny' } = { lastName: 'Son' };
console.log(fn, ln); // Sunny Son
```

객체 디스트럭처링 할당은 객체에서 프로퍼티 키로 필요한 프로퍼티 값만 추출하여 변수에 할당하고 싶을 때 유용하다.

```jsx
const str = 'Hello';
// String 래퍼 객체로부터 length 프로퍼티만 추출한다.
const { length } = str;
console.log(length); // 5

const todo = { id: 1, content: 'HTML', completed: true };
// todo 객체로부터 id 프로퍼티만 추출한다.
const { id } = todo;
console.log(id); // 1
```

객체 디스트럭처링 할당은 객체를 인수로 전달받은 함수의 매개변수에도 사용할 수 있다.

```jsx
function printTodo(todo) {
  console.log(
    `할일 ${todo.content}은 ${todo.completed ? '완료' : '비완료'} 상태입니다.`);
}

printTodo({ id: 1, content: 'HTML', completed: true });
// 할일 HTML은 완료 상태입니다.
```

매개변수 todo에 객체 디스트럭처링 할당을 사용하면 좀 더 간단하고 가독성 좋게 표현할 수 있다.

```jsx
function printTodo(content, completed) {
  console.log(`할일 ${content}은 ${completed ? '완료' : '비완료'} 상태입니다.`);
}

printTodo({ id: 1, content: 'HTML', completed: true });
// 할일 HTML은 완료 상태입니다.
```

배열의 요소가 객체인 경우 배열 디스트럭처링 할당과 객체 디스트럭처링 할당을 혼용할 수 있다.

```jsx
const todos = [
  { id: 1, content: 'HTML', completed: true },
  { id: 2, content: 'CSS', completed: false },
  { id: 3, content: 'JS', completed: false },
];

// todos 배열의 두 번째 요소인 객체로부터 id 프로퍼티만 추출한다.
const [, { id }] = todos;
console.log(id); // 2
```

중첩 객체의 경우는 다음과 같이 사용한다.

```jsx
const user = {
  name: 'Sunny',
  address: {
    zipCode: '01023',
    city: 'Seoul',
  },
};

// address 프로퍼티 키로 객체를 추출하고 이 객체의 city 프로퍼티 키로 값을 추출한다.
const {
  address: { city },
} = user;
console.log(city); // Seoul
```

객체 디스트럭처링 할당을 위한 Rest 파라미터나 Rest 요소와 유사하게 Rest 프로퍼티 `...` 을 사용할 수 있다.

```jsx
const { x, ...rest } = { x: 1, y: 2, z: 3 };
console.log(x, rest); // 1 {y: 2, z: 3}
```

---

# **37장 Set과 Map**

# **1. Set**

**Set 객체는 중복되지 않는 유일한 값들의 집합이다.**

## **1. 1 Set 객체의 생성**

```jsx
const set = new Set();
	console.log(set); // Set(0) {}
```

**Set 생성자 함수는 이터러블을 인수로 전달받아 Set 객체를 생성한다. 이때 이터러블의 중복된 값은 Set 객체에 요소로 저장되지 않는다.**

```jsx
const set1 = new Set([1, 2, 3, 3]);
console.log(set1); // Set(3) {1, 2, 3}

const set2 = new Set('hello');
console.log(set2); // Set(4) { 'h', 'e', 'l', 'o' }
```

중복을 허용하지 않는 Set 객체의 특성을 활용하여 배열에서 중복된 요소를 제거할 수 있다.

```jsx
const array = [2, 1, 2, 3, 4, 3, 4];

const uniq1 = array => array.filter((v, i, self) => self.indexOf(v) === i);
console.log(uniq1(array)); // [2, 1, 3, 4]

const uniq2 = array => [...new Set(array)];
console.log(uniq2(array)); // [2, 1, 3, 4]
```

## **1.2 요소 개수 확인**

Set 객체의 요소 개수를 확인할 때는 Set.prototype.size 프로퍼티를 사용한다.

```jsx
const { size } = new Set([2, 1, 3, 3]);
console.log(size); // 3
```

size 프로퍼티는 getter 함수만 존재하는 접근자 프로퍼티다.

size 프로퍼티에 숫자를 할당하여 Set 객체의 요소 개수를 변경할 수 없다.

```jsx
const set = new Set([1, 2, 3]);

set.size = 10; // 무시됨.
console.log(set.size);
```

## **1.3 요소 추가**

Set 객체에 요소를 추가할 때는 Set.prototype.add 메서드를 사용한다.

```jsx
const set = new Set();
console.log(set); // Set(0) {}

set.add(1);
console.log(set); // Set(1) {1}

// add 메서드는 새로운 요소가 추가된 Set 객체를 반환한다.
// add 메서드를 연속적으로 호출이 가능하다.
set.add(1).add(2);
console.log(set); // Set(2) { 1, 2 }

----
const set = new Set();

// 일치 비교 연산자 ===을 사용하면 NaN과 NaN을 다르다고 평가한다.
// Set 객체는 NaN과 NaN을 같다고 평가하여 중복 추가를 허용하지 않는다.
// +0, -0은 일치 비교 연산자 ===와 마찬가지로 같다고 평가한다.
console.log(NaN === NaN); // false
console.log(+0 === -0); // true

set.add(NaN).add(NaN);
console.log(set); // Set(1) { NaN }

set.add(0).add(-0);
console.log(set); // Set(1) { 0 }
```

Set 객체는 객체나 배열과 같이 자바스크립트의 모든 값을 요소로 저장할 수 있다.

```jsx
const set = new Set();
set
  .add(1)
  .add('a')
  .add(true)
  .add(undefined)
  .add(null)
  .add({})
  .add([])
  .add(() => {});

console.log(set);

/*
    Set(8) {
      1,
      'a',
      true,
      undefined,
      null,
      {},
      [],
      [Function (anonymous)]
    }
*/
```

## **1.4 요소 존재 여부 확인**

Set 객체에 특정 요소가 존재하는지 확인하려면 Set.prototype.has 메서드를 사용한다.

has 메서드는 특정 요소의 존재 여부를 나타내는 불리언 값을 반환한다.

```jsx
const set = new Set([1, 2, 3]);

console.log(set.has(2)); // true
console.log(set.has(4)); // false
```

## **1.5 요소 삭제**

Set 객체에 특정 요소를 삭제하려면 Set.prototype.delete 메서드를 사용한다.

delete 메서드는 삭제 성공 여부를 나타내는 불리언 값을 반환한다. delete 메서드는 인덱스가 아니라 삭제하려는 요소값을 인수로 전달해야 한다.

```jsx
const set = new Set([1, 2, 3]);

// 요소 2 삭제
set.delete(2);
console.log(set); // Set(2) { 1, 3 }

// 존재하지 않는 요소 0을 삭제하면 무시된다.
set.delete(0);
console.log(set); // Set(2) { 1, 3 }
```

## **1.6 요소 일괄 삭제**

Set 객체에 모든 요소를 일괄 삭제하려면 Set.prototype.clear 메서드를 사용한다.

clear 메서드는 언제나 undefined를 반환한다.

```jsx
const set = new Set([1, 2, 3]);

set.clear();
console.log(set); // Set(0) {}
```

## **1.7 요소 순회**

Set 객체에 요소를 일괄 순회하려면 Set.prototype.forEach 메서드를 사용한다.

Array의 forEach 메서드처럼 3개의 인수와 함께 콜백 함수를 전달한다.

- 현재 순회 중인 요소값
- 현재 순회 중인 요소값
- 현재 순회 중인 Set 객체 자체
- 

```jsx
const set = new Set([1, 2, 3]);

set.forEach((v, v2, set) => console.log(v, v2, set));

/*
    1 1 Set(3) { 1, 2, 3 }
    2 2 Set(3) { 1, 2, 3 }
    3 3 Set(3) { 1, 2, 3 }
*/
```

**Set 객체는 이터러블이다.**

- `for…of` 문
- 스프레드 문법
- 배열 디스트럭처링

대상이 될 수 있다.

```jsx
const set = new Set([1, 2, 3]);

// for...of 문
for (const value of set) {
  console.log(value); // 1 2 3
}

// 스프레드 문법
console.log([...set]); // [1, 2, 3]

// 배열 디스트럭처링
const [a, ...rest] = set;
console.log(a, rest); // 1 [2, 3]
```

Set 객체는 요소의 순서에 의미를 갖지 않지만 Set 객체를 순회하는 순서는 요소가 추가된 순서를 따른다.

## **1.8 집합 연산**

Set 객체는 수학적 집합을 구현하기 위한 자료구조다.

집합 연산을 수행하는 프로토타입 메서드를 구현하면 다음과 같다.

### **교집합**

집합 A와 집합 B의 공통 요소로 구성한다.

```jsx
Set.prototype.intersection = function(set) {
  const result = new Set();

  for (const value of set) {
    // 2개의 set의 요소가 공통되는 요소이면 교집합의 대상이다.
    if (this.has(value)) {
      result.add(value);
    }
  }

  return result;
}

const setA = new Set([1, 2, 3, 4]);
const setB = new Set([2, 4]);

console.log(setA.intersection(setB)); // Set(2) { 2, 4 }
console.log(setB.intersection(setA)); // Set(2) { 2, 4 }

// 다음과 같은 방법으로도 가능하다.
Set.prototype.intersection = function(set) {
  return new Set([...this].filter(v => set.has(v)));
}
```

### **합집합**

집합 A와 집합 B의 중복 없는 모든 요소로 구성된다.

```jsx
Set.prototype.usage = function(set) {
  // this(Set 객체 복사)
  const result = new Set(this);

  for (const value of set) {
    // 중복된 요소는 포함되지 않도록 한다.
    result.add(value);
  }

  return result;
}

const setA = new Set([1, 2, 3, 4]);
const setB = new Set([2, 4]);

console.log(setA.usage(setB)); // Set(4) { 1, 2, 3, 4 }
console.log(setB.usage(setA)); // Set(4) { 2, 4, 1, 3 }

// 다음과 같은 방법으로도 가능하다.
Set.prototype.usage = function(set) {
  return new Set([...this, ...set]);
}
```

### **차집합**

A-B 는 집합 A에는 존재하지만 집합 B에는 존재하지 않는 요소로 구성된다.

```jsx
Set.prototype.difference = function(set) {
  // this(Set 객체 복사)
  const result = new Set(this);

  for (const value of set) {
    // 어느 한쪽 집합에는 존재하지만 다른 한쪽 집합에는 존재하지 않는 요소로 구성한 집합이다.
    result.delete(value);
  }

  return result;
}

const setA = new Set([1, 2, 3, 4]);
const setB = new Set([2, 4]);

console.log(setA.difference(setB));
console.log(setB.difference(setA));

// 다음과 같은 방법으로도 가능하다.
Set.prototype.difference = function(set) {
  return new Set([...this].filter(v => !set.has(v)));
}`
```

### **부분집합과 상위 집합**

```jsx
Set.prototype.isSuperset = function(subset) {
  for (const value of subset) {
    // superset의 모든 요소가 subset의 모든 요소를 포함하는지 확인
    if (!this.has(value)) {
      return false;
    }
  }
  return true;
}

const setA = new Set([1, 2, 3, 4]);
const setB = new Set([2, 4]);

console.log(setA.isSuperset(setB));
console.log(setB.isSuperset(setA));

// 다음과 같은 방법으로도 가능하다.
Set.prototype.isSuperset = function(subset) {
  const supersetArr = [...this];
  return [...subset].every(v => supersetArr.includes(v));
}
```

# **2. Map**

**Map 객체는 키와 쌍으로 이루어진 컬렉션이다.** Map 객체는 객체와 유사하나 다음과 같은 차이가 있다.

| **구분** | **객체** | **Map 객체** |
| --- | --- | --- |
| 키로 사용할 수 있는 값 | 문자열 또는 심벌 값 | 객체를 포함한 모든 값 |
| 이터러블 | X | O |
| 요소 개수 확인 | Object.keys(obj).length | map.size |

## **2.1 Map 객체의 생성**

Map 객체는 Map 생성자 함수로 생성한다. Map 생성자 함수에 인수를 전달하지 않으면 빈 Map이 생성된다.

```jsx
const map = new Map();
console.log(map); // Map(0) {}
```

Map 생성자 함수는 이터러블을 인수로 전달받아 Map 객체를 생성한다.

인수로 전달되는 이터러블은 키와 쌍으로 이루어진 요소로 구성되어야 한다.

```jsx
const map1 = new Map([
  ['key1', 'value1'],
  ['key2', 'value2'],
]);
console.log(map1); // Map(2) { 'key1' => 'value1', 'key2' => 'value2' }

const map2 = new Map([1, 2]); // TypeError
```

중복된 키는 Map 객체에 요소로 저장되지 않는다.

```jsx
const map = new Map([
  ['key1', 'value1'],
  ['key1', 'value2'],
]);
console.log(map); // Map(1) { 'key1' => 'value2'}
```

## **2.2 요소 개수 확인**

Map 객체의 요소 개수를 확인할 때는 Map.prototype.size 프로퍼티를 사용한다.

```jsx
const { size } = new Map([
  ['key1', 'value1'],
  ['key2', 'value2'],
]);
console.log(size); // 2
```

size 프로퍼티는 getter 함수만 존재하는 접근자 프로퍼티다.

size 프로퍼티에 숫자를 할당하여 Set 객체의 요소 개수를 변경할 수 없다.

```jsx
const map = new Map([
  ['key1', 'value1'],
  ['key2', 'value2'],
]);

map.size = 10;
console.log(map.size); // 2
```

## **2.2 요소 추가**

Map 객체의 요소를 추가할 때는 Map.prototype.set 프로퍼티를 사용한다.

```jsx
const map = new Map();
console.log(map); // Map(0) {}

map.set('key1', 'value1');
console.log(map) // Map(1) { 'key1' => 'value1' }

// set 메서드는 새로운 요소가 추가된 Map 객체를 반환한다.
// set 메서드는 연속적으로 호출할 수 있다.
map.set('key1', 'value1').set('key2', 'value2');
console.log(map) // Map(2) { 'key1' => 'value1', 'key2' => 'value2' }

// Map 객체에 중복된 키를 갖는 요소의 추가는 허용되지 않는다.
// 에러는 발생하지 않고 무시한다.
map.set('key1', 'value1').set('key1', 'value2');
console.log(map) // Map(1) { 'key1' => 'value2' }

// NaN, +0,, -0도 Set과 마찬가지로 같다고 평가하여 중복 추가를 허용하지 않는다.
map.set(NaN, 'value1').set(NaN, 'value2');
console.log(map); // Map(1) { NaN => 'value2' }

map.set(0, 'value1').set(-0, 'value2');
console.log(map); // Map(1) { 0 => 'value2' }
```

객체는 문자열 또는 심벌 값만 키로 사용할 수 있다.

Map 객체는 키 타입에 제한이 없다. → 객체를 포함한 모든 값을 키로 사용할 수 있다.

```jsx
const map = new Map();

const lee = { name: 'Lee' };
const son = { name: 'Son' };

map.set(lee, 'developer').set(son, 'designer');
console.log(map);

/*
    Map(2) 
    {
      { name: 'Lee' } => 'developer',
      { name: 'Son' } => 'designer'
    }
*/
```

## **2.4 요소 취득**

Map 객체에서 특정 요소를 취득하려면 Map.prototype.get 메서드를 사용한다.

get 메서드의 인수로 키를 전달하면 Map 객체에서 인수로 전달한 키를 갖는 값을 반환한다.

존재하지 않으면 undefined를 반환한다.

```jsx
const map = new Map();

const lee = { name: 'Lee' };
const son = { name: 'Son' };

map.set(lee, 'developer').set(son, 'designer');

console.log(map.get(lee)); // developer
console.log(map.get('key')); // undefined
```

## **2.5 요소 존재 여부 확인**

Map 객체에서 특정 요소가 존재하는지 확인하려면 Map.prototype.has 메서드를 사용한다.

has 메서드는 특정 요소의 존재 여부를 나타내는 불리언 값을 반환한다.

```jsx
const map = new Map()

const lee = { name: 'Lee' };
const son = { name: 'Son' };

map.set(lee, 'developer').set(son, 'designer');

console.log(map.has(lee)); // true
console.log(map.has('key')); // false
```

## **2.6 요소 삭제**

Map 객체에서 요소를 삭제하려면 Map.prototype.delete 메서드를 사용한다.

delete 메서드는 삭제 성공 여부를 나타내는 불리언 값을 반환한다.

```jsx
const map = new Map();

const lee = { name: 'Lee' };
const son = { name: 'Son' };

map.set(lee, 'developer').set(son, 'designer');

map.delete(lee);
console.log(map); // Map(1) { { name: 'Son' } => 'designer' }

// 만약 존재하지 않는 키로 삭제하려하면 에러 없이 무시된다.
const map = new Map();

const lee = { name: 'Lee' };
const son = { name: 'Son' };

map.set(lee, 'developer').set(son, 'designer');

map.delete('key2');
console.log(map);

/*
    Map(2) 
    {
      { name: 'Lee' } => 'developer',
      { name: 'Son' } => 'designer'
    }
*/

// delete 메서드는 연속적으로 호출할 수 없다.
map.delete(lee).delete(son); // TypeError
```

## **2.7 요소 일괄 삭제**

Map 객체에서 요소를 일괄 삭제하려면 Map.prototype.clear 메서드를 사용한다.

clear 메서드는 언제나 undefined 를 반환한다.

```jsx
const map = new Map();

const lee = { name: 'Lee' };
const son = { name: 'Son' };

map.set(lee, 'developer').set(son, 'designer');

map.clear();
console.log(map); // Map(0) {}
```

## **2.8 요소 순회**

Map 객체에서 요소를 순회하려면 Map.prototype.forEach 메서드를 사용한다.

Array의 forEach 메서드처럼 3개의 인수와 함께 콜백 함수를 전달한다.

- 현재 순회 중인 요소값
- 현재 순회 중인 요소키
- 현재 순회 중인 Map 객체 자체

```jsx
const map = new Map();

const lee = { name: 'Lee' };
const son = { name: 'Son' };

map.set(lee, 'developer').set(son, 'designer');

map.forEach((v, k, map) => console.log(v, k, map));

/*
    developer { name: 'Lee' } Map(2) {
      { name: 'Lee' } => 'developer',
      { name: 'Son' } => 'designer'
    }
    designer { name: 'Son' } Map(2) {
      { name: 'Lee' } => 'developer',
      { name: 'Son' } => 'designer'
    }
*/
```

Map 객체는 이터러블이다.

- `for…of` 문
- 스프레드 문법
- 배열 디스트럭처링

대상이 될 수 있다.

```jsx
const map = new Map();

const lee = { name: 'Lee' };
const son = { name: 'Son' };

map.set(lee, 'developer').set(son, 'designer');

// for...of 문
for (const entry of map) {
  console.log(entry);
  // [ { name: 'Lee' }, 'developer' ]
  // [ { name: 'Son' }, 'designer' ]
}

// 스프레드 문법
console.log([...map]);
// [ [ { name: 'Lee' }, 'developer' ], [ { name: 'Son' }, 'designer' ] ]

// 배열 디스트럭처링
const [a, b] = map;
console.log(a, b);
// [ { name: 'Lee' }, 'developer' ] [ { name: 'Son' }, 'designer' ]
```

Map 객체는 이터러블이면서 동시에 이터레이터인 객체를 반환하는 메서드를 제공한다.

| **Map 메서드** | **설명** |
| --- | --- |
| Map.prototype.keys | Map 객체에서 요소키를 값으로 갖는 이터러블 / 이터레이터인 객체를 반환한다. |
| Map.prototype.values | Map 객체에서 요소값을 값으로 갖는 이터러블 / 이터레이터인 객체를 반환한다. |
| Map.prototype.entries | Map 객체에서 요소키와 요소값을 값으로 갖는 이터러블 / 이터레이터인 객체를 반환한다. |

```jsx
const map = new Map();

const lee = { name: 'Lee' };
const son = { name: 'Son' };

map.set(lee, 'developer').set(son, 'designer');

// Map.prototype.keys 문
for (const key of map.keys()) {
  console.log(key); // { name: 'Lee' } { name: 'Son' }
}

// Map.prototype.values 문
for (const value of map.values()) {
  console.log(value); // developer, designer
}

// Map.prototype.entries 문
for (const entry of map.entries()) {
  console.log(entry);
  // [ { name: 'Lee' }, 'developer' ] [ { name: 'Son' }, 'designer' ]
}
```

Map 객체는 요소의 순서에 의미를 갖지 않지만 Map 객체를 순회하는 순서는 요소가 추가된 순서를 따른다.