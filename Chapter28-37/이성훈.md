# 28.1 Number 생성자 함수

표준 빌트인 객체로서 생성자 함수 객체.

new 연산자와 함께 Number 인스턴스를 생성할 수 있다.

```jsx
const numObj = new Number();
console.log(numObj); // Number {[[PrimitiveValue]]: 0}
```

인수를 전달하지 않고 호출하면 `[[NumberData]]` 내부 슬롯에 0을 할당한 Number 래퍼 객체를 생성.

인수로 숫자를 전달하면 `[[NumberData]]` 내부 슬롯에 인수를 할당한 Number 래퍼 객체를 생성.

```jsx
const numObj = new Number(10);
console.log(numObj); // Number {[[PrimitiveValue]]: 10}
```

인수로 숫자가 아닌 값을 전달하면 숫자로 강제 변환 후 전달한다.

```jsx
let numObj = new Number('10');
console.log(numObj); // Number {[[PrimitiveValue]]: 10}

numObj = new Number('Hello');
console.log(numObj); // Number {[[PrimitiveValue]]: NaN}
```

명시적 타입 변환 수단으로 사용할 수 있다.

```jsx
// 문자열 타입 => 숫자 타입
Number('0');     // -> 0
Number('-1');    // -> -1
Number('10.53'); // -> 10.53

// 불리언 타입 => 숫자 타입
Number(true);  // -> 1
Number(false); // -> 0
```

# 28.2 Number 프로퍼티

## 28.2.1 Number.EPSILON

1과 1보다 큰 숫자 중에서 가장 작은 숫자와의 차이와 같다.

하지만 구조적인 한계 덕분에 부동소수점 산술 연산은 정확한 결과를 기대하기 어렵다.

```jsx
0.1 + 0.2;         // -> 0.30000000000000004
0.1 + 0.2 === 0.3; // -> false
```

Number.EPSILON은 이러한 오차를 해결하기 위해 사용한다.

```jsx
function isEqual(a, b){
  // a와 b를 뺀 값의 절대값이 Number.EPSILON보다 작으면 같은 수로 인정한다.
  return Math.abs(a - b) < Number.EPSILON;
}

isEqual(0.1 + 0.2, 0.3); // -> true
```

## 28.2.2 Number.MAX_VALUE

자바스크립트에서 표현할 수 있는 가장 큰 양수 값.

이보다 더 큰 숫자는 Infinity 이다.

```jsx
Number.MAX_VALUE; // -> 1.7976931348623157e+308
Infinity > Number.MAX_VALUE; // -> true
```

## 28.2.3 Number.MIN_VALUE

자바스크립트에서 표현할 수 있는 가장 작은 양수 값.

이보다 더 작은 숫자는 0.

```jsx
Number.MIN_VALUE; // -> 5e-324
Number.MIN_VALUE > 0; // -> true
```

## 28.2.4 Number.MAX_SAFE_INTEGER

자바스크립트에서 안전하게 표현할 수 있는 가장 큰 정수값.

```jsx
Number.MAX_SAFE_INTEGER; // -> 9007199254740991
```

## 28.2.5 Number.MIN_SAFE_INTEGER

자바스크립트에서 안전하게 표현할 수 있는 가장 작은 정수값.

```jsx
Number.MIN_SAFE_INTEGER; // -> -9007199254740991
```

## 28.2.6 Number.POSITIVE_INFINITY

양의 무한대를 나타내는 숫자값 Infinity.

```jsx
Number.POSITIVE_INFINITY; // -> Infinity
```

## 28.2.7 Number.NEGATIVE_INFINITY

음의 무한대를 나타내는 숫자값 -Infinity.

```jsx
Number.NEGATIVE_INFINITY; // -> -Infinity
```

## 28.2.8 Number.NaN

숫자가 아님 (Not-a-Number)을 나타내는 숫자값.

```jsx
Number.NaN; // -> NaN
```

# 28.3 Number 메서드

## 28.3.1 Number.isFinite

인수로 전달된 숫자값이 Infinity 또는 -Infinity인지 여부를 검사하여 불리언 값으로 반환.

```jsx
// 인수가 정상적인 유한수이면 true를 반환한다.
Number.isFinite(0);                // -> true
Number.isFinite(Number.MAX_VALUE); // -> true
Number.isFinite(Number.MIN_VALUE); // -> true

// 인수가 무한수이면 false를 반환한다.
Number.isFinite(Infinity);  // -> false
Number.isFinite(-Infinity); // -> false
```

```jsx
Number.isFinite(NaN); // -> false
```

빌트인 전역 함수 isFinite는 인수를 암묵적 형변환하여 검사하지만, Number의 정적 메서드인 isFinite는 형변환하지 않기 때문에 숫자가 아닌 값이 주어지면 언제나 false 이다.

```jsx
// Number.isFinite는 인수를 숫자로 암묵적 타입 변환하지 않는다.
Number.isFinite(null); // -> false

// isFinite는 인수를 숫자로 암묵적 타입 변환한다. null은 0으로 암묵적 타입 변환된다.
isFinite(null); // -> true
```

## 28.3.2 Number.isInteger

인수로 전달된 숫자값이 정수인지 여부를 불리언 값으로 반환.

암묵적 형변환이 없다.

```jsx
// 인수가 정수이면 true를 반환한다.
Number.isInteger(0)     // -> true
Number.isInteger(123)   // -> true
Number.isInteger(-123)  // -> true

// 0.5는 정수가 아니다.
Number.isInteger(0.5)   // -> false
// '123'을 숫자로 암묵적 타입 변환하지 않는다.
Number.isInteger('123') // -> false
// false를 숫자로 암묵적 타입 변환하지 않는다.
Number.isInteger(false) // -> false
// Infinity/-Infinity는 정수가 아니다.
Number.isInteger(Infinity)  // -> false
Number.isInteger(-Infinity) // -> false
```

## 28.3.3 Number.isNaN

인수로 전달된 숫자값이 NaN인지 여부를 불리언 값으로 반환.

```jsx
// 인수가 NaN이면 true를 반환한다.
Number.isNaN(NaN); // -> true
```

빌트인 전역 함수 isNaN은 인수를 암묵적 형변환하여 검사하지만, Number의 정적 메서드인 isNaN은 형변환하지 않기 때문에 숫자가 아닌 값이 주어지면 언제나 false 이다.

```jsx
// Number.isNaN은 인수를 숫자로 암묵적 타입 변환하지 않는다.
Number.isNaN(undefined); // -> false

// isFinite는 인수를 숫자로 암묵적 타입 변환한다. undefined는 NaN으로 암묵적 타입 변환된다.
isNaN(undefined); // -> true
```

## 28.3.4 Number.isSafeInteger

인수로 전달된 숫자값이 안전한 정수인지 여부를 불리언 값으로 반환.

암묵적 타입 변환은 없다.

```jsx
// 0은 안전한 정수이다.
Number.isSafeInteger(0); // -> true
// 1000000000000000은 안전한 정수이다.
Number.isSafeInteger(1000000000000000); // -> true

// 10000000000000001은 안전하지 않다.
Number.isSafeInteger(10000000000000001); // -> false
// 0.5은 정수가 아니다.
Number.isSafeInteger(0.5); // -> false
// '123'을 숫자로 암묵적 타입 변환하지 않는다.
Number.isSafeInteger('123'); // -> false
// false를 숫자로 암묵적 타입 변환하지 않는다.
Number.isSafeInteger(false); // -> false
// Infinity/-Infinity는 정수가 아니다.
Number.isSafeInteger(Infinity); // -> false
```

## 28.3.5 Number.prototype.toExponential

숫자를 지수 표기법으로 변환하여 문자열로 반환.

```jsx
(77.1234).toExponential();  // -> "7.71234e+1"
(77.1234).toExponential(4); // -> "7.7123e+1"
(77.1234).toExponential(2); // -> "7.71e+1"
```

```jsx
77.toExponential(); // -> SyntaxError: Invalid or unexpected token
```

## 28.3.6 Number.prototype.toFixed

숫자를 반올림하여 문자열로 반환.

반올림하는 소수점 이하 자릿수를 나타내는 0 ~ 20 사이의 정수값을 인수로 전달 가능.

생략하면 기본값 0 이 적용.

```jsx
// 소수점 이하 반올림. 인수를 생략하면 기본값 0이 지정된다.
(12345.6789).toFixed(); // -> "12346"
// 소수점 이하 1자리수 유효, 나머지 반올림
(12345.6789).toFixed(1); // -> "12345.7"
// 소수점 이하 2자리수 유효, 나머지 반올림
(12345.6789).toFixed(2); // -> "12345.68"
// 소수점 이하 3자리수 유효, 나머지 반올림
(12345.6789).toFixed(3); // -> "12345.679"
```

## 28.3.7 Number.prototype.toPrecision

인수로 전달받은 전체 자릿수까지 유효하도록 나머지 자릿수를 반올림하여 문자열로 반환.

```jsx
// 전체 자리수 유효. 인수를 전달하지 않으면 기본값 0이 전달된다.
(12345.6789).toPrecision(); // -> "12345.6789"
// 전체 1자리수 유효, 나머지 반올림
(12345.6789).toPrecision(1); // -> "1e+4"
// 전체 2자리수 유효, 나머지 반올림
(12345.6789).toPrecision(2); // -> "1.2e+4"
// 전체 6자리수 유효, 나머지 반올림
(12345.6789).toPrecision(6); // -> "12345.7"
```

## 28.3.8 Number.prototype.toString

숫자를 문자열로 변환하여 반환.

진법을 나타내는 2 ~ 36 사이의 정수를 인수로 전달할 수 있다.

기본값은 10진법.

```jsx
// 인수를 생략하면 10진수 문자열을 반환한다.
(10).toString(); // -> "10"
// 2진수 문자열을 반환한다.
(16).toString(2); // -> "10000"
// 8진수 문자열을 반환한다.
(16).toString(8); // -> "20"
// 16진수 문자열을 반환한다.
(16).toString(16); // -> "10"
```

# 29장 Math

수학적인 상수 및 함수를 위한 프로퍼티와 메서드를 제공하는 표준 빌트인 객체.

생성자 함수가 아니며 정적 프로퍼티 및 정적 메서드를 제공한다.

# 29.1 Math 프로퍼티

## 29.1.1 Math.PI

원주율 PI 값 제공.

```jsx
Math.PI; // -> 3.141592653589793
```

# 29.2 Math 메서드

## 29.2.1 Math.abs

인수로 전달된 숫자의 절대값을 반환.

```jsx
Math.abs(-1);        // -> 1
Math.abs('-1');      // -> 1
Math.abs('');        // -> 0
Math.abs([]);        // -> 0
Math.abs(null);      // -> 0
Math.abs(undefined); // -> NaN
Math.abs({});        // -> NaN
Math.abs('string');  // -> NaN
Math.abs();          // -> NaN
```

## 29.2.2 Math.round

인수로 전달된 숫자의 소수점 이하를 반올림한 정수 반환.

```jsx
Math.round(1.4);  // -> 1
Math.round(1.6);  // -> 2
Math.round(-1.4); // -> -1
Math.round(-1.6); // -> -2
Math.round(1);    // -> 1
Math.round();     // -> NaN
```

## 29.2.3 Math.ceil

인수로 전달된 숫자의 소수점 이하를 올림한 정수 반환.

```jsx
Math.ceil(1.4);  // -> 2
Math.ceil(1.6);  // -> 2
Math.ceil(-1.4); // -> -1
Math.ceil(-1.6); // -> -1
Math.ceil(1);    // -> 1
Math.ceil();     // -> NaN
```

## 29.2.4 Math.floor

인수로 전달된 숫자의 소수점 이하를 내림한 정수 반환.

```jsx
Math.floor(1.9);  // -> 1
Math.floor(9.1);  // -> 9
Math.floor(-1.9); // -> -2
Math.floor(-9.1); // -> -10
Math.floor(1);    // -> 1
Math.floor();     // -> NaN
```

## 29.2.5 Math.sqrt

인수로 전달된 숫자의 제곱근 반환.

```jsx
Math.sqrt(9);  // -> 3
Math.sqrt(-9); // -> NaN
Math.sqrt(2);  // -> 1.414213562373095
Math.sqrt(1);  // -> 1
Math.sqrt(0);  // -> 0
Math.sqrt();   // -> NaN
```

## 29.2.6 Math.random

임의의 난수를 반환.

0에서 1 미만의 실수.

```jsx
Math.random(); // 0에서 1 미만의 랜덤 실수(0.8208720231391746)

/*
1에서 10 범위의 랜덤 정수 취득
1) Math.random으로 0에서 1 미만의 랜덤 실수를 구한 다음, 10을 곱해 0에서 10 미만의
랜덤 실수를 구한다.
2) 0에서 10 미만의 랜덤 실수에 1을 더해 1에서 10 범위의 랜덤 실수를 구한다.
3) Math.floor로 1에서 10 범위의 랜덤 실수의 소수점 이하를 떼어 버린 다음 정수를 반환한다.
*/
const random = Math.floor((Math.random() * 10) + 1);
console.log(random); // 1에서 10 범위의 정수
```

## 29.2.7 Math.pow

첫 번째 인수를 밑으로, 두 번째 인수를 지수로 거듭제곱하여 반환.

```jsx
Math.pow(2, 8);  // -> 256
Math.pow(2, -1); // -> 0.5
Math.pow(2);     // -> NaN
```

ES7에서 도입된 지수 연산자를 사용할 수도 있다.

```jsx
// ES7 지수 연산자
2 ** 2 ** 2; // -> 16
Math.pow(Math.pow(2, 2), 2); // -> 16
```

## 29.2.8 Math.max

전달받은 인수 중에서 가장 큰 수를 반환.

인수가 없으면 -Infinity를 반환한다.

```jsx
Math.max(1); // -> 1
Math.max(1, 2); // -> 2
Math.max(1, 2, 3); // -> 3
Math.max(); // -> -Infinity
```

## 29.2.9 Math.min

전달받은 인수 중에서 가장 작은 수를 반환.

인수가 없으면 Infinity를 반환한다.

```jsx
Math.min(1); // -> 1
Math.min(1, 2); // -> 1
Math.min(1, 2, 3); // -> 1
Math.min(); // -> Infinity
```

# 30장 Date 생성자 함수

표준 객체인 Date는 날짜와 시간을 위한 메서드를 제공하는 빌트인 객체이면서 생성자 함수다.

UTC는 국제 표준시를 말하며 GMT로 불리기도 한다.

KST는 UTC에 9시간을 더한 시간이다.

현재 날짜와 시간은 자바스크립트 코드가 실행된 시스템의 시계에 의해 결정된다.

# **1. Date 생성자 함수**

Date는 생성자 함수다. Date 생성자 함수로 생성한 Date 객체는 기본적으로 현재 날짜와 시간을 나타내는 정수값을 가진다.

현재 날짜와 시간이 아닌 다른 날짜와 시간을 다루고 싶은 경우 Date 생성자 함수에 명시적으로 해당 날짜와 시간 정보를 인수로 지정한다.

## **1.1 new Date()**

Date 생성자 함수를 인수 없이 new 연산자와 함께 호출하면 현재 날짜와 시간을 가지는 Date 객체를 반환한다.

Date 객체는 내부적으로 날짜와 시간을 나타내는 정수값을 갖지만 Date 객체를 호출하면 기본적으로 날짜와 시간 정보를 출력한다.

```jsx
new Date(); // 2023-08-15T12:50:28.906Z
```

Date 생성자 함수를 new 연산자 없이 호출하면 Date 객체를 반환하지 않고 날짜와 시간 정보를 나타내는 문자열을 반환한다.

```jsx
Date(); // Tue Aug 15 2023 21:52:47 GMT+0900 (Korean Standard Time)
```

## **1.2 new Date(milliseconds)**

Date 생성자 함수에 숫자 타입의 밀리초를 인수로 전달하면 UTC 기점으로 인수로 전달된 밀리초만큼 경과한 날짜와 시간을 나타내는 Date 객체를 반환한다.

```jsx
new Date(0); // 1970-01-01T00:00:00.000Z

new Date(86400000); // 1970-01-02T00:00:00.000Z
```

## **1.3 new Date(dateString)**

Date 생성자 함수에 날짜와 시간을 나타내는 문자열을 인수로 전달하면 지정된 날짜와 시간을 Date 객체를 반환한다. 이때 인수로 전달한 문자열은 Date.parse 메서드에 의해 해석 가능한 형식이어야 한다.

```jsx
new Date('May 26, 2020 10:00:00'); // 2020-05-26T01:00:00.000Z

new Date('2023/08/15/10:00:00'); // 2023-08-15T01:00:00.000Z
```

## **1.4 new Date(year, month, day…)**

Date 생성자 함수에 연, 월, 일, 시, 분, 초, 밀리초를 의미하는 숫자를 인수로 전달하면 지정된 날짜와 시간을 나타내는 Date 객체를 반환한다. 이때 연, 월은 반드시 지정해야 한다.

| **인수** | **내용** |
| --- | --- |
| year | 연을 나타내는 1900년 이후의 정수. 0부터 99는 1900부터 1999로 처리된다. |
| month | 월을 나타내는 0 ~ 11까지의 정수(주의: 0부터 시작, 0 = 1월) |
| day | 일을 나타내는 1 ~ 31까지의 정수 |
| hour | 시를 나타내는 0 ~ 23까지의 정수 |
| minute | 분을 나타내는 0 ~ 59까지의 정수 |
| second | 초를 나타내는 0 ~ 59까지의 정수 |
| millisecond | 밀리초를 나타내는 0 ~ 999까지의 정수 |

```jsx
new Date(2020, 2); // 2020-02-29T15:00:00.000Z
new Date(2020, 2, 26, 10, 0, 0, 0); // 2020-03-26T01:00:00.000Z

// 가독성이 훨씬 좋다.
new Date('2020/2/26/10:00:00:00'); // 2020-02-26T01:00:00.000Z
```

# **2. Date 메서드**

## **2.1 Date.now**

1970년 1월 1일 00:00:00(UTC) 을 기점으로 현재 시간까지 경과한 밀리초를 숫자로 반환한다.

```jsx
Date.now(); // 1692105562943
```

## **2.2 Date.parse**

1970년 1월 1일 00:00:00(UTC)을 기점으로 인수로 전달된 지정시간(new Date(dateString)) 까지의 밀리초를 숫자로 반환한다.

```jsx
Date.parse('Jan 2, 1970 00:00:00 UTC'); // 86400000
Date.parse('Jan 2, 1970 00:00:00'); // 54000000
Date.parse('2023/08/16/10:00:00'); // 1692147600000
```

## **2.3 Date.UTC**

1970년 1월 1일 00:00:00(UTC)을 기점으로 인수로 전달된 지정 시간까지의 밀리초를 숫자로 반환한다.

Date.UTC 메서드는 new Date(year, month[, day…]와 같은 형식의 인수를 사용해야 한다.

```jsx
Date.UTC(1970, 0, 2); // 86400000
Date.UTC('2020/02/02'); // NaN
```

## **2.4 Date 메서드들**

```jsx
// Date.prototype.getFullYear
// Date 객체의 연도를 나타내는 정수를 반환한다.
new Date('2020/07/23').getFullYear(); // 2020

// Date.prototype.setFullYear
// Date 객체의 연도를 나타내는 정수를 설정한다. 연도 이외에 옵션으로 월, 일도 설정할 수 있다.
const today = new Date();

// 년도 지정
today.setFullYear(2000);
today.getFullYear(); // 2000

// 년도/월/일 지정
today.setFullYear(2023, 0, 2);
today.getFullYear(); // 2023

// Date.prototype.getMonth
// Date 객체의 월을 나타내는 0 ~ 11의 정수를 반환한다. 1월은 0, 12월은 11이다.
new Date('2023/08/14').getMonth(); // 6

// Date.prototype.setMonth
// Date 객체의 월을 나타내는 0 ~ 11의 정수를 설정한다.
const today = new Date();

// 월 지정
today.setMonth(0); // 1월
today.getMonth(); // 0

// 월/일 지정
today.setMonth(11, 1); // 12월 1일
today.getMonth(); // 11

// Date.prototype.getDate
// Date 객체의 날짜(1 ~ 31)를 나타내는 정수를 반환한다.
new Date('2023/08/15').getDate(); // 24

// Date.prototype.setDate
// Date 객체의 날짜(1 ~ 31)를 나타내는 정수를 설정한다.
const today = new Date();

// 날짜 지정
today.setDate(1);
today.getDate(); // 1

// Date.prototype.getDay
// Date 객체의 요일(0 ~ 6)을 나타내는 정수를 반환한다.
new Date('2023/08/15').getDay(); // 2

// Date.prototype.getHours
// Date 객체의 시간(0 ~ 23)을 나타내는 정수를 반환한다.
new Date('2023/08/15/12:00').getHours(); // 12

// Date.prototype.setHours
// Date 객체의 시간(0 ~ 23)을 나타내는 정수를 설정한다
// 시간 이외에 옵션으로 분, 초, 밀리초도 설정할 수 있다.
const today = new Date();

// 시간 지정
today.setHours(7);
today.getHours(); // 0

// 시간/분/초/밀리초 지정
today.setHours(0, 0, 0, 0); // 00:00:00:00
today.getHours();

// Date.prototype.getMinutes
// Date 객체의 분(0 ~ 59)을 나타내는 정수를 반환한다.
new Date('2023/08/15/12:20').getMinutes(); // 20

// Date.prototype.setMinutes
// Date 객체에 분(0 ~ 59)을 나타내는 정수를 설정한다.
// 분 이외에 옵션으로 초, 밀리초도 설정할 수 있다.
const today = new Date();

// 분 지정
today.setMinutes(5);
today.getMinutes(); // 5

// 분/초/밀리초 지정
today.setMinutes(5, 10, 0); // HH:05:10:00
today.getMinutes(); // 5

// Date.prototype.getSeconds
// Date 객체의 초(0 ~ 59)를 나타내는 정수를 반환한다.
new Date('2023/08/15/12:20:10').getSeconds(); // 10

// Date.prototype.setSeconds
// Date 객체의 초(0 ~ 59)를 나타내는 정수를 설정한다.
const today = new Date();

// 초 지정
today.setSeconds(5);
today.getSeconds(); // 5

// 초/밀리초 지정
today.setSeconds(5, 10); // HH:MM:05:10
today.getSeconds(); // 5

// Date.prototype.getMilliseconds
// Date 객체의 밀리초(0 ~ 999)를 나타내는 정수를 반환한다.
new Date('2023/08/15/12:20:10:150').getMilliseconds(); // 150
```

## **2.5 Date Time, Timezone 메서드들**

```jsx
// Date.prototype.getTime
// 1970년 1월 1일 00:00:00(UTC)를 기점으로 Date 객체의 시간까지 경과된 밀리초를 반환한다.
new Date("2023/08/15/12:30").getTime(); // 1692070200000

// Date.prototype.setTime
// 1970년 1월 1일 00:00:00(UTC)를 기점으로 Date 객체의 시간까지 경과된 밀리초를 설정한다.
const today = new Date();

today.setTime(86400000); // 86400000은 1day를 의미

// Date.prototype.getTimezoneOffset
// UTC와 Date 객체에 지정된 locale 시간과의 차이를 분 단위로 반환한다.
// KST는 UTC에 9시간을 더한 시간이다.
const today = new Date();

today.getTimezoneOffset() / 60; // -9

// Date.prototype.toDateString
// 사람이 읽을 수 있는 문자열로 Date 객체의 날짜를 반환한다.
const today = new Date("2023/08/15/12:30");

today.toString(); // Tue Aug 15 2023 12:30:00 GMT+0900 (Korean Standard Time)
today.toDateString(); // Tue Aug 15 2023

// Date.prototype.toTimeString
// 사람이 읽을 수 있는 문자열로 Date 객체의 날짜를 반환한다.
const today = new Date("2023/08/15/12:30");

today.toTimeString(); // 12:30:00 GMT+0900 (Korean Standard Time)

// Date.prototype.toISOString
// ISO 8601 형식으로 Date 객체의 날짜와 시간을 표현한 문자열을 반환한다.
const today = new Date("2023/08/15/12:30");

today.toISOString(); // 2023-08-15T03:30:00.000Z
today.toISOString().slice(0, 10); // 2023-08-15
today.toISOString().slice(0, 10).replace(/-/g, ""); // 20230815

// Date.prototype.toLocaleString
// 인수로 전달한 로캘을 기준으로 Date 객체의 날짜와 시간을 문자열을 반환한다.
// 인수를 생략한 경우 브라우저가 동작 중인 시스템의 로캘을 적용한다.
const today = new Date("2023/08/15/12:30");

today.toLocaleString(); // 8/15/2023, 12:30:00 PM
today.toLocaleString("ko-KR"); // 2023. 8. 15. 오후 12:30:00
today.toLocaleString("en-US"); // 8/15/2023, 12:30:00 PM
today.toLocaleString("ja-JP"); // 2023/8/15 12:30:00

// Date.prototype.toLocaleTimeString
// 인수로 전달한 로캘을 기준으로 Date 객체의 시간을 문자열을 반환한다.
// 인수를 생략한 경우 브라우저가 동작 중인 시스템의 로캘을 적용한다.
const today = new Date("2023/08/15/12:30");

today.toLocaleTimeString()); // 12:30:00 PM
today.toLocaleTimeString("ko-KR"); // 오후 12:30:00
today.toLocaleTimeString("en-US"); // 12:30:00 PM
today.toLocaleTimeString("ja-JP"); // 12:30:00
```

# 31장 RegExp

## 31.1 정규 표현식이란?

- 자바스크립트의 고유 문법x
- 대부분의 프로그래밍 언어와 코드 에디터에 내장o

---

## 31.2 정규 표현식의 생성

!https://velog.velcdn.com/images/aneb/post/c3830f58-6a51-41a4-804b-590f3d209881/image.png

- 정규 표현식 리터럴은 패턴과 플래그로 구성

---

## 31.3 RegExp 메서드

### 31.3.1 RegExp.prototype.exec

- exec 메서드는 인수로 전달받은 문자열에 대해 정규 표현식의 패턴을 검색하여 매칭 결과를 배열로 반환한다.
- 매칭 결과가 없는 경우 null을 반환

```jsx
const target = `Is this all there is?`;
cosnt regExp = /is/;

regExp.exec(target); // ["is", index: 5,input: "Is this ....]
```

- 문자열 내의 모든 패턴을 검색하는 `g플래그` 를 지정해도 첫 번째 매칭 결과만 반환하므로 주의해야함

---

### 31.3.2 RegExp.prototype.test

- test 메서드는 인수로 전달받은 문자열에 대해 정규 표현식의 패턴을 검색하여 매칭결과를 불리언 값으로 반환한다.

```jsx
const target = `Is this all there is?`;
cosnt regExp = /is/;

regExp.test(target); // true
```

---

### 31.3.2 RegExp.prototype.match

- match 메서드는 인수로 전달받은 문자열과 인수로 전달받은 정규 표현식과의 매칭 결과를 배열로 반환한다.

```jsx
const target = `Is this all there is?`;
cosnt regExp = /is/;

target.match(regExp); //["is", index: 5,input: "Is this ....]
```

- exec메서드와 달리 `g플래그` 를 지정하면 모든 매칭 결과를 배열로 반환한다.

---

## 31.4 플래그

플래그는 총 6개가 있으며 그중 중요한 3개의 플래그를 살펴보도록 한다.

| 플래그 | 의미 | 설명 |
| --- | --- | --- |
| i | ignore | 대소문자를 구별하지 않고 패턴을 검색한다. |
| g | Global | 대상 문자열 내에서 패턴과 일치하는 모든 문자열을 전역 검색한다. |
| m | Multi line | 문자열의 행이 바뀌더라도 패턴 검색을 계속한다. |
- 플래그는 옵션이므로 선택적으로 사용할 수 있으며, 순서와 상관없이 하나 이상의 플래그를 동시에 설정 할 수있다.

---

## 31.5 패턴

- 패턴은 `/` 로 열고 닫으며 문자열의 따옴표는 생략한다.
- 따옴표를 포함하면 따옴표까지도 패턴에 포함되어 검색된다.
- 어떤 문자열 내에 패턴과 일치하는 문자열이 존재할때 ‘정규 표현식과 매치한다'고 표현한다.

아래에서는 패턴을 표현하는 몇 가지 방법에 대해 살펴보도록 한다.

---

### 31.5.1 문자열 검색

```jsx
const target = `Is this all there is?`;
cosnt regExp = /is/ig;

// 플래그 i를 추가하여 대소문자를 구별하지 않고 검색
// 플래그 g를 추가하여 모든 문자열 전역 검색
target.match(regExp); // ["Is", "is", "is"]
```

---

### 31.5.2 임의의 문자열 검색

- `.` 은 임의의 문자 한 개를 의미한다.
- `.` 을 3개 연속하여 패턴을 생성하면 내용과 상관없이 3자열과 매치한다.

```jsx
const target = `Is this all there is?`;
cosnt regExp = /.../g;

target.match(regExp); // ["Is ", "thi", "s a", "ll ", "the", "re ", "is?"]
```

---

### 31.5.3 반복 검색

- `{m,n}` 은 앞선 패턴이 최소 `m` 번, 최대 `n` 번 반복되는 문자열을 의미한다.
- 콤마(,) 뒤에 공백이 있으면 정상 동작하지 않으니 주의해야한다.
- `{n,}` 은 앞선 패턴이 최소 `n`번 이상 반복되는 문자열을 의미한다.

```jsx
const target = `A AA B BB Aa Bb AAA`;
cosnt regExp = /A{1,2}/g;

// A가 최소 1번 최대 2번 반복되는 문자열을 전역 검색
target.match(regExp); // ["A", "AA", "A", "AA", A"]
```

- `+` 는 앞선 패턴이 최소 한번 이상 반복되는 문자열을 의미한다. = `{1,}`
- `?` 는 앞선 패턴이 최대 한 번(0번 포함) 이상 반복되는 문자열을 의미한다. = `{0,1}`

---

### 31.5.4 OR 검색

- `|` 는 `or` 의 의미를 갖는다.

```jsx
const target = `A AA B BB Aa Bb`;
cosnt regExp = /A|B/g;

// A또는 B를 전역 검색
target.match(regExp); // ["A", "A", "A", "B", "B", "B", "A", "B"]
```

- [ ]  `[ ]` 내의 문자는 or로 동작한다.
- 범위를 지정하려면 `[ ]`내에 `` 를 사용한다.

```jsx
const target = `AA BB Aa Bb`;
cosnt regExp = /[A-Za-z]+/g;

// A~Z, a~z 가 1번 이상 반복되는 문자열을 전역 검색
target.match(regExp); // ["A", "BB", "Aa", "Bb"]
```

- `\d`는 `숫자` 를 의미한다.
- `\D` 는 `\d` 와 반대로 동작한다. (즉, 숫자가 아닌 문자를 의미)
- `\w` 는 `알파벳, 숫자, 언더스코어` 를 의미한다.
- `\W` 는 `\w` 와 반대로 동작한다. (즉, 알파벳, 숫자, 언더스코어가 아닌 문자를 의미)

---

### 31.5.5 NOT 검색

`[...]` `내`의 `^` 은 `not` 의 의미를 갖는다.

### 31.5.6 시작 위치로 검색

`[...]` `밖`의 `^` 은 `문자열의 시작` 을 의미 한다.

### 31.5.7 마지막 위치로 검색

`$` 은 `문자열의 마지막` 을 의미 한다.

---

## 31.6 자주 사용하는 정규표현식

### 31.6.1 특정 단어로 시작하는지 검사

- ‘[http://’](http://xn--evg/) 또는 ‘[https://’로](https://xn--evgx901d/) 시작하는지 검사

```jsx
const url= 'https://example.com';

// [...]밖의 ^는 문자열의 시작을 의미
// | 는 or
// ? 는 앞선 패턴('s')가 0~1번 반복
/^https?:\/\//.test(url); // true
```

### 31.6.2 특정 단어로 끝나는지 검사

- ‘html’로 끝나는지 검사

```jsx
const fileName= 'idnex.html';

// $는 문자열의 마지막을 의미
/html$/.test(fileName); // true
```

### 31.6.3 숫자로만 이루어진 문자열인지 검사

- 숫자로만 시작하고 끝나는지 검사
    
    ```jsx
    const target= '12345';
    
    // [...]밖의 ^는 문자열의 시작
    // $ 는 문자열의 마지막
    // \d 는 숫자
    // + 는 앞선 패턴이 최소 한 번 이상 반복되는 문자열을 의미
    /^\d+$/.test(target); // true
    ```
    

### 31.6.4 하나 이상의 공백으로 시작하는지 검사

`\s` 는 여러 가지 공백문자를 의미한다.

```jsx
const target= '  hi!';

/^[\s]+/.test(target); // true
```

### 31.6.5 아이디로 사용 가능한지 검사

- 알파벳 대소문자 또는 숫자로 시작하고 끝나며, 4~10자리인지 검사
    
    ```jsx
    const id= 'abc1234';
    
    // [...]밖의 ^는 문자열의 시작
    // $ 는 문자열의 마지막
    // \d 는 숫자
    // + 는 앞선 패턴이 최소 한 번 이상 반복되는 문자열을 의미
    /^[A-Za-z0-9]{4,10}$/.test(id); // true
    ```
    

# **32장 String**

- 원시 타입인 문자열을 다룰 때 유용한 프로퍼티와 메서드를 제공한다.

## 32-1. String 생성자 함수

- String 생성자 함수에 인수를 전달하지 않고 new 연산자와 함께 호출하면 [[StringData]] 내부 슬롯에 빈 문자열을 할당한 String 래퍼 객체를 생성한다.
- 문자열은 원시 값이므로 변경 불가
- 문자열이 아닌 값을 전달하면 문자열로 강제 변환한 후 [[StringData]] 내부 슬롯에 변환된 문자열을 할당한 String 래퍼 객체를 생성한다.

```lua
const strObj = new String();
console.log(strObj); // String { length: 0, [[PrimitiveValue]]: "" }

const strObj = new String('Lee');
console.log(strObj); // String {0: "L", 1: "e", 2: "e", length: 3, [[PrimitiveValue]]: "Lee" }

const strObj = new String(123);
console.log(strObj); // String {0: "1", 1: "2", 2: "3", length: 3, [[PrimitiveValue]]: "123" }

const strObj = new String(null);
console.log(strObj); // String {0: "n", 1: "u", 2: "l", 3: "l", length: 4, [[PrimitiveValue]]: "null" }

// 형변환
String(1); // '1'
String(NaN); // 'NaN'
String(Infinity); // 'Infinity'

String(true); // 'true'
String(false); // 'false'

```

## 32-2. length 프로퍼티

- String 래퍼 객체는 유사 배열 객체다.

```csharp
'Hello'.length;// 5'Bye'.length;// 3
```

## 33-3. String 메서드

- String 객체의 메서드는 언제나 새로운 문자열을 반환한다.
- 문자열은 immutable한 원시값이기에 String 래퍼 객체도 읽기전용 객체로 제공된다.

### String.prototype.indexOf

- 인수로 전달받은 문자열을 검색하여 첫 번째 인덱스 반환, 실패시 -1 반환

```rust
const str = 'Hello World';
str.indexOf('l');// 2
str.indexOf('or');// 7
str.indexOf('x');// -1// 검색을 시작할 인덱스 지정
str.indexOf('l', 3);// 3// 검색할 문자열이 존재하는지 확인할 때
if (str.indexOf('Hello') === -1)
if (str.includes('Hello'))

```

### String.prototype.search

- 인수로 전달받은 정규 표현식과 매치하는 문자열을 검색하여 일치하는 인덱스 반환, 실패시 -1 반환

```jsx
const str = 'Hello World';
str.search(/o/);// 4
str.search(/x/);// -1
```

### String.prototype.includes

- 포함하고 있는지 확인, boolean 반환

```rust
const str = 'Hello World';
str.includes('Hello');// truestr.includes('xxx');// false// 검색을 시작할 인덱스 지정str.includes('l', 3);// true
```

### String.prototype.startsWith

- 인수로 전달받은 문자열로 시작하는지 확인하여 boolean 반환
- 2번째 인수로 검색을 시작 할 인덱스 지정 가능

### String.prototype.endWith

- 인수로 전달받은 문자열로 끝나는지 확인하여 boolean 반환

```rust
const str = 'Hello World';
str.endsWith('ld');// true// str의 처음부터 5자리까지 ('Hello')가 'lo'로 끝나는지 확인str.endsWith('lo', 5);// true
```

### String.prototype.charAt

- 인수로 전달받은 인덱스에 위치한 문자 반환

```rust
const str = 'Hello World';
str.charAt(0);// Hstr.charAt(5);// ''
```

### String.prototype.substring

- 첫 번째 인수로 전달받은 인덱스에 위치하는 문자부터 두 번째 인수로 전달받은 인덱스에 위치하는 문자의 바로 이전 문자까지의 부분 문자열 반환

```sql
const str = 'Hello World';
str.substring(1, 4); // 'ell'
str.substring(1); // 'ello World'

// 첫 번째 인수 > 두 번째 인수인 경우 두 인수 교환됨.
str.substring(4, 1); // 'ell'

// 인수 < 0 또는 NaN인 경우 0으로 취급됨.
str.substring(-2); // 'Hello World'

// 인수 > 문자열의 길이 인 경우 문자열의 길이로 취급됨.
str.substring(1, 100); // 'ello World'
str.substring(20); // ''

```

### String.prototype.slice

- substring과 동일하게 동작한다. 단, slice 메서드에는 음수인 인수를 전달할 수 있다.

```python
const str = 'Hello World';

str.slice(0, 5); // 'Hello'
str.slice(2); // 'llo World'
str.slice(-5); // 'World'

```

### String.prototype.toUpperCase, toLowerCase

```rust
const str = 'Hello World';

str.toUpperCase();// 'HELLO WORLD'
str.toLowerCase();// 'hello world'
```

### String.prototype.trim

- 앞 뒤 공백 문자 제거한 문자열 반환

```perl
const str = '  foo  ';
str.trim(); // 'foo'

str.trimStart(); // 'foo  '
str.trimEnd(); // '  foo'

str.replace(/\\s/g, ''); // 'foo'
str.replace(/^\\s+/g, ''); // 'foo  '
str.replace(/\\s+$/g, ''); // '  foo'

```

### String.prototype.repeat

```rust
const str = 'abc';

str.repeat();// ''str.repeat(0);// ''str.repeat(1);// 'abc'str.repeat(2);// 'abcabc'str.repeat(-1);// RangeError: Invalid count value
```

### String.prototype.replace

```rust
const str = 'Hello World';
str.replace('World', 'Lee');// 'Hello Lee'
const str = 'Hello world world';
str.replace('world', 'Lee');// 'Hello Lee world'
const str = 'Hello Hello';
str.replace(/hello/gi, 'Lee');// 'Lee Lee'
```

### String.prototype.split

```perl
const str = 'How are you doing?';

str.split(' '); // ['How', 'are', 'you', 'doing?']

str.split(/\\s/); // ['How', 'are', 'you', 'doing?']

str.split(''); // ['H', 'o', ... '?']

str.split(); // ['How are you doing?']

str.split(' ', 3); // ['How', 'are', 'you']
```

# 33장 7번째 데이터 타입 Symbol

### 심벌이란?

ES6에 도입된 7번째 데이터 타입으로 변경 불가능한 원시 타입의 값이다.

다른 값과 중복되지 않는 유일무이한 값이다.

이름 충돌 위험이 없는 유일한 프로퍼티 키를 만들기 위해 사용한다.

심벌은 중복되지 않는 상수 값을 생성하는 것은 물론 기존에 작성된 코드에 영향을 주지 않고 새로운 프로퍼티를 추가하기 위해, 즉 하위 호환성을 보장하기 위해 도입되었다.

### 심벌 값의 생성

Symbol 함수를 호출하여 생성한다.

생성된 심벌 값은 외부로 노출되지 않아 확인할 수 없으며, 다른 값과 절대 중복되지 않는다.

Symbol 함수에는 문자열을 인자로 전달할 수 있는데, 이 문자열은 생성된 심벌 값에 대한 설명으로 디버깅 용도로만 사용되고 심벌 값 생성에 어떠한 영향도 주지 않는다.

심벌 값도 다른 원시값처럼 객체처럼 접근하면 암묵적으로 래퍼 객체를 생성한다.

심벌 값은 암묵적으로 문자열이나 숫자 타입으로 변환되지 않는다. 단, 불리언 타입으로는 암묵적으로 타입 변환된다. 이를 통해 if문 등에서 존재 확인이 가능하다.

| **메서드** | **설명** |
| --- | --- |
| Symbol.for | 인자로 전달받은 문자열을 키로 사용하여 전역 심벌 레지스트리에서 해당 키와 일치하는 심벌 값을 검색한다.검색에 성공하면 해당 값을 반환하고, 실패하면 새로운 심벌 값을 생성하여 인자로 전달된 키로 전역 심벌 레지스트리에 저장한 후 생성된 심벌 값을 반환한다. |
| Symbol.keyFor | 전역 심벌 레지스트리에 저장된 심벌 값의 키를 추출할 수 있다. |

### 심벌과 상수

상수를 정의할 때 중복 가능성이 없는 유일무이한 심벌 값을 사용할 수 있다.

### 심벌과 프로퍼티 키

심벌 값으로 프로퍼티 키를 만들면 다른 프로퍼티 키와 절대 충돌하지 않는다.

심벌 값을 프로퍼티 키로 사용하려면 프로퍼티 키로 사용할 심벌 값에 대괄호를 사용해야 한다.

### 심벌과 프로퍼티 은닉

심벌 값을 프로퍼티 키로 사용하여 생성한 프로퍼티는 for ... in 문이나 Object.keys, Object.getOwnPropertyNames 메서드로 찾을 수 없다. 하지만 ES6에 도입된 Object.getOwnPropertySymbols 메서드를 사용하면 심벌 값을 프로퍼티 키로 사용하여 생성한 프로퍼티를 찾을 수 있다.

### 심벌과 표준 빌트인 객체 확장

중복될 가능성이 없는 심벌 값으로 프로퍼티 키를 생성하여 표준 빌트인 객체를 확장하면 표준 빌트인 객체의 기존 프로퍼티 키와 충돌하지 않는 것은 물론, 표준 사양의 버전이 올라가도 안전하게 확장할 수 있다.

### Well-known Symbol

자바스크립트가 기본 제공하는 빌트인 심벌 값이다. 자바스크립트 엔진의 내부 알고리즘에 사용된다.

빌트인 이터러블은 Well-known Symbol인 Symbol.iterator를 키로 갖는 메서드를 가지며, Symbol.iterator 메서드를 호출하면 이터레이터를 반환하도록 ECMAScript 사양에 규정되어 있다.

# 34장 이터러블

### 이터레이션 프로토콜

ES6에 도입된 순회 가능한(iterable) 데이터 컬렉션(자료구조)을 만들기 위해 ECMAScript 사양에 정의하여 미리 약속한 규칙이다.

ES6 이전의 순회 가능한 데이터 컬렉션(배열, 문자열, 유사 배열 객체, DOM 컬렉션 등)은 통일된 규약 없이 각자 구조를 가지고 다양한 방법으로 순회할 수 있었다.

ES6부터 순회 가능한 데이터 컬렉션을 이터레이션 프로토콜을 준수하는 이터러블로 통일하여 for ... of 문, 스프레드 문법, 배열 디스트럭처링 할당의 대상으로 사용할 수 있도록 일원화했다.

이터레이션 프로토콜에는 이터러블 프로토콜과 이터레이터 프로토콜이 있다.

| **이터러블 프로토콜(iterable protocol)** | **이터레이터 프로토콜(iterator protocol)** |
| --- | --- |
| Well-known Symbol인 Symbol.iterator를 프로퍼티 키로 사용한 메서드를 직접 구현하거나 프로토타입 체인을 통해 상속받은 Symbol.iterator 메서드를 호출하면 이터레이터 프로토콜을 준수한 이터레이터를 반환한다.위 규약을 준수한 객체를 이터러블이라 한다.이터러블은 for ... of 문으로 순회할 수 있으며, 스프레드 문법과 배열 디스트럭처링 할당의 대상으로 사용할 수 있다. | 이터러블의 Symbol.iterator 메서드를 호출하면 이터레이터 프로토콜을 준수한 이터레이터를 반환한다.이터레이터는 next 메서드를 소유하며 next 메서드를 호출하면 이터러블을 순회하며 value와 done 프로퍼티를 갖는 이터레이터 리절트 객체를 반환한다. value 프로퍼티는 현재 순회 중인 이터러블의 값을, done 프로퍼티는 이터러블의 순회 완료 여부를 나타낸다.위 규약을 준수한 객체를 이터레이터라 한다.이터레이터는 이터러블의 요소를 탐색하기 위한 포인터 역할을 한다. |

Symbol.iterator 메서드가 없는 일반 객체는 for ... of 문으로 순회할 수 없으며 배열 디스트럭처링 할당의 대상으로 사용할 수 없다. 단, 일반 객체에 스프레드 문법 사용은 허용한다.

### 빌트인 이터러블

Array, String, Map, Set, TypedArray, arguments, DOM 컬렉션(NodeList, HTMLCollection)이 빌트인 이터러블로 제공된다.

### for ... of 문

이터러블을 순회하면서 이터러블의 요소를 변수에 할당한다.

for ... in 문은 객체의 프로토타입 체인 상에 존재하는 모든 프로토타입 프로퍼티 중에서 [[Enumerable]]의 값이 true인 프로퍼티를 순회하며 열거한다. 프로퍼티 키가 심벌인 프로퍼티는 열거하지 않는다.

for ... of 문은 내부적으로 이터레이터의 next 메서드를 호출하여 순회하며 next 메서드의 반환값의 value 프로퍼티 값을 for ... of 문의 변수에 할당한다. done 프로퍼티 값이 true면 이터러블 순회를 중단한다.

### 이터러블과 유사 배열 객체

유사 배열 객체는 다음과 같은 특징을 가진다.

- 인덱스로 프로퍼티 값에 접근할 수 있다.
- length 프로퍼티를 갖는 객체다.
- 따라서 for 문으로 순회할 수 있다.

유사 배열 객체는 이터러블이 아닌 일반 객체다. 단, ES6부터 arguments, NodeList, HTMLCollection은 유사 배열 객체이면서 이터러블이다.

### 이터레이션 프로토콜의 필요성

다양한 데이터 공급자가 각자의 순회 방식을 갖는다면 데이터 소비자는 다양한 데이터 공급자의 순회 방식을 모두 지원해야 한다. 이는 비효율적이다. 하지만 다양한 데이터 공급자가 특정 프로토콜을 준수한다면 데이터 소비자는 해당 프로토콜만 지원하도록 구현하면 된다.

ES6부터 순회 가능한 데이터 컬렉션을 이터레이션 프로토콜을 준수하는 이터러블로 통일하여 for ... of 문, 스프레드 문법, 배열 디스트럭처링 할당의 대상으로 사용할 수 있도록 일원화했다.

이터레이션 프로토콜은 다양한 데이터 공급자가 하나의 순회 방식을 갖도록 규정하여 데이터 소비자가 효율적으로 다양한 데이터 공급자를 사용할 수 있도록 데이터 소비자와 데이터 공급자를 연결하는 인터페이스 역할을 한다.

### 사용자 정의 이터러블

이터레이션 프로토콜을 준수하지 않는 일반 객체를 이터레이션 프로토콜을 준수하도록 구현하면 사용자 정의 이터러블이 된다.

이터러블을 생성하는 함수, 이터러블이면서 이터레이터인 객체를 생성하는 함수, 무한 이터러블을 생성하는 함수를 만들 수 있다.

이터러블은 지연 평가를 통해 데이터를 생성한다. 데이터 소비자인 for ... of 문이나 배열 디스트럭처링 할당이 실행되기 이전까지는 데이터를 생성하지 않다가 next 메서드를 호출할 때 데이터가 생성된다.

> 🍎
> 
> 
> **지연 평가(lazy evaluation)**
> 

# 스프레드 문법

ES6에 도입된 스프레드 문법(spread syntax) ...은 하나로 뭉쳐 있는 여러 값들의 집합을 펼쳐서 개별적인 값들의 목록으로 만든다.

Array, String, Map, Set, DOM 컬렉션(NodeList, HTMLCollection), arguments와 같은 이터러블에 한정되어 사용할 수 있다.

스프레드 문법의 결과는 값이 아닌 값들의 목록이다. 따라서 스프레드 문법의 결과는 변수에 할당할 수 없다.

스프레드 문법의 결과물은 다음과 같이 쉼표로 구분한 값의 목록을 사용하는 문맥에서만 사용할 수 있다.

- 함수 호출문의 인수 목록
- 배열 리터럴의 요소 목록
- 객체 리터럴의 프로퍼티 목록

Rest 파라미터와 형태가 동일하지만, Rest 파라미터와 스프레드 문법은 서로 반대의 개념이다.

스프레드 문법으로 얕은 복사를 수행할 수 있다. 이터러블을 배열로 변환할 때도 사용할 수 있다.

일반 객체를 대상으로 사용하여 Object.assign 메서드를 대체할 수 있다.

# 디스트럭처링 할당

이터러블 또는 객체를 비구조화(destructuring)하여 1개 이상의 변수에 개별적으로 할당하는 것을 말한다.

필요한 값만 추출하여 변수에 할당할 때 유용하다.

### 배열 디스트럭처링 할당

배열 디스트럭처링 할당의 대상은 이터러블이어야 하며, 할당 기준은 배열의 인덱스다. 즉, 순서대로 할당된다. 변수의 개수와 이터러블의 요소 개수가 반드시 일치할 필요는 없다.

이터러블이 아니면 TypeError가 발생한다.

할당을 위한 변수에 기본값을 설정할 수 있다. 할당값이 있으면 기본값보다 우선된다.

Rest 파라미터와 유사하게 Rest 요소(Rest element)를 사용할 수 있다. 반드시 마지막에 위치해야 한다.

### 객체 디스트럭처링 할당

프로퍼티 키를 사용해서 디스트럭처링하여 변수에 할당한다. 즉, 순서는 의미가 없으며 선언된 변수 이름과 프로퍼티 키가 일치하면 할당된다.

변수는 객체 리터럴 형태로 선언한다. 디스트럭처링 대상으로 객체 또는 객체로 평가될 수 있는 표현식이 아니면 TypeError가 발생한다.

할당을 위한 변수에 기본값을 설정할 수 있다.

Rest 파라미터나 Rest 요소와 유사하게 Rest 프로퍼티(Rest property)를 사용할 수 있다. 반드시 마지막에 위치해야 한다.

# Set과 Map

### Set

중복되지 않는 유일한 값들의 집합이다. 수학적 집합의 특성과 일치한다.

배열과 유사하지만 동일한 값을 중복하여 포함할 수 없고, 요소 순서에 의미가 없고, 인덱스로 요소에 접근할 수 없다.

Set 생성자 함수는 이터러블을 인수로 전달받아 Set 객체를 생성한다. 이터러블의 중복된 값은 저장되지 않는다.

| **메서드와 프로퍼티** | **설명** |
| --- | --- |
| Set.prototype.size | Set 객체의 요소 개수를 확인할 때 사용한다.getter 함수만 존재하는 접근자 프로퍼티다. 따라서 요소 개수는 변경할 수 없다. |
| Set.prototype.add | Set 객체에 요소를 추가할 때 사용한다.새로운 요소가 추가된 Set 객체를 반환한다. 따라서 메서드 체이닝이 가능하다.중복된 요소의 추가는 불가능하다. 에러는 발생하지 않는다.NaN과 NaN, +0과 -0을 같다고 평가하여 중복 추가하지 않는다.자바스크립트의 모든 값을 요소로 저장할 수 있다. |
| Set.prototype.has | Set 객체에 특정 요소의 존재 여부를 확인할 때 사용한다.불리언 값을 반환한다. |
| Set.prototype.delete | Set 객체의 특정 요소를 삭제할 때 사용한다.불리언 값을 반환한다. 따라서 메서드 체이닝할 수 없다.존재하지 않는 요소를 삭제하려 하면 에러 없이 무시된다. |
| Set.prototype.clear | Set 객체의 모든 요소를 일괄 삭제할 때 사용한다.항상 undefined를 반환한다. |
| Set.prototype.forEach | Set 객체의 요소를 순회할 때 사용한다.첫번째 인자와 두번째 인자는 모두 현재 순회 중인 요소값을 의미하며 같은 값이다. 이는 Array.prototype.forEach와 인터페이스를 통일하기 위함이다.Set 객체는 요소의 순서에 의미가 없지만 순회할 때 요소가 추가된 순서를 따른다. 다른 이터러블의 순회와 호환성을 유지하기 위함이다. |

Set 객체로 교집합, 합집합, 차집합 등을 구현할 수 있다.

### Map

키와 값의 쌍으로 이루어진 컬렉션이다. 객체와 유사하지만 키로 객체를 포함한 모든 값이 가능하며, 이터러블이다.

Map 생성자 함수는 이터러블을 인수로 전달받아 Map 객체를 생성한다. 이터러블은 키와 값의 쌍으로 이루어진 요소로 구성되어야 한다. 이터러블에 중복된 키를 갖는 요소가 존재하면 값이 덮어써진다. 따라서 중복된 키를 갖는 요소가 존재할 수 없다.

| **메서드와 프로퍼티** | **설명** |
| --- | --- |
| Map.prototype.size | Map 객체의 요소 개수를 확인할 때 사용한다.getter 함수만 존재하는 접근자 프로퍼티다. 따라서 요소 개수는 변경할 수 없다. |
| Map.prototype.set | Map 객체에 요소를 추가할 때 사용한다.새로운 요소가 추가된 Map 객체를 반환한다. 따라서 메서드 체이닝이 가능하다.중복된 요소를 추가하면 값이 덮어써진다. 에러는 발생하지 않는다.NaN과 NaN, +0과 -0을 같다고 평가하여 중복 추가하지 않는다.객체를 포함한 모든 값을 키로 사용할 수 있다. |
| Map.prototype.get | Map 객체에서 특정 요소를 취득할 때 사용한다.인자로 전달한 키를 갖는 값을 반환한다. 존재하지 않으면 undefined를 반환한다. |
| Map.prototype.has | Map 객체에 특정 요소의 존재 여부를 확인할 때 사용한다.불리언 값을 반환한다. |
| Map.prototype.delete | Map 객체의 특정 요소를 삭제할 때 사용한다.불리언 값을 반환한다. 따라서 메서드 체이닝할 수 없다.존재하지 않는 요소를 삭제하려 하면 에러 없이 무시된다. |
| Map.prototype.clear | Map 객체의 모든 요소를 일괄 삭제할 때 사용한다.항상 undefined를 반환한다. |
| Map.prototype.forEach | Map 객체의 요소를 순회할 때 사용한다.첫번째 인자는 현재 순회 중인 요소값, 두번째 인자는 현재 순회 중인 요소키를 의미한다.Map 객체는 요소의 순서에 의미가 없지만 순회할 때 요소가 추가된 순서를 따른다. 다른 이터러블의 순회와 호환성을 유지하기 위함이다. |
| Map.prototype.keys | Map 객체에서 요소키를 값으로 갖는 이터러블이면서 이터레이터인 객체를 반환한다. |
| Map.prototype.values | Map 객체에서 요소값을 값으로 갖는 이터러블이면서 이터레이터인 객체를 반환한다. |
| Map.prototype.entries | Map 객체에서 요소키와 요소값을 값으로 갖는 이터러블이면서 이터레이터인 객체를 반환한다. |

# 35장 스프레드 문법

하나로 뭉쳐 있는 여러 값들의 집합을 펼쳐서 개별적인 값들의 목록으로 만든다

Array, String, Map, Set, DOM 컬렉션, arguments와 같이 for...of문으로 순회할 수 있는 이터러블에 한정되어 사용 가능

스프레드 문법의 결과는 값이 아니며 변수에 할당 불가

## 함수 호출문의 인수 목록에서 사용하는 경우

배열을 펼쳐서 개별적인 값들의 목록으로 만든 후, 이를 함수의 인수 목록으로 전달해야하는 경우

```jsx
const arr = [1, 2, 3];

const max = Math.max(arr); // NaN
const max = Math.max(...arr); // 3
```

Rest 파라미터 -> 함수에 전달된 인수들의 목록을 배열로 전달받기 위해 매개변수 이름 앞에 ...을 붙이는 것

스프레드 문법 -> 여러 개 값이 하나로 뭉쳐 있는 배열과 같은 이터러블을 펼쳐서 개별적인 값들의 목록을 만드는 것

## 배열 리터럴 내부에서 사용하는 경우

### concat

```jsx
const arr = [...[1, 2], ...[3, 4]];
console.log(arr); // [1, 2, 3, 4]
```

### splice

```jsx
const arr1 = [1, 4];
const arr2 = [2, 3];

arr1.splic(1, 0, ...arr2);
console.log(arr1); // [1, 2, 3, 4]
```

### 배열 복사

```jsx
const origin = [1, 2];
const copy = [...origin];

console.log(copy); // [1, 2];
console.log(copy === origin); // false
```

원본 배열의 각 요소를 얕은 복사하여 새로운 복사본 생성

### 이터러블을 배열로 변환

```jsx
// ES5
function sum() {
  var args = Array.prototype.slice.call(arguments);

  return args.reduce(function (pre, cur) {
    return pre + cur;
  }, 0);
}

console.log(sum(1, 2, 3)); // 6
```

```jsx
function sum() {
  return [...arguments].reduce((pre, cur) => pre + cur, 0);
}

console.log(sum(1, 2, 3)); // 6
```

이터러블이 아닌 유사 배열 객체는 스프레드 문법의 대상이 될 수 없다

## 객체 리터럴 내부에서 사용하는 경우

스프레드 문법의 대상은 이터러블이어야 하지만 스프레드 프로퍼티 제안은 일반 객체를 대상으로도 스프레드 문법의 사용을 허용한다

```jsx
// 스프레드 프로퍼티
// 객체 복사
const obj = { x: 1, y: 2 };
const copy = { ...obj };
console.log(copy); // { x: 1, y: 2 }
console.log(obj === copy); // false

// 객체 병합
const merged = { x: 1, y: 2, ...{ a: 3, b: 4 } };
console.log(merged); // { x: 1, y: 2, a: 3, b: 4 }
```

스프레드 프로퍼티는 Object.assign 메서드를 대체할 수 있는 간편한 문법이다

```jsx
// 객체 병합, 프로퍼티가 중복되는 경우 뒤에 위치한 프로퍼티가 우선권을 갖는다
const merged = { ...{ x: 1, y: 2 }, ...{ y: 10, z: 3 } };
console.log(merged); // { x: 1, y: 10, z: 3 }

// 특정 프로퍼티 변경
const changed = { ...{ x: 1, y: 2 }, y: 100 };
console.log(changed); // { x: 1, y: 100 }

// 프로퍼티 추가
const added = { ...{ x: 1, y: 2 }, z: 0 };
console.log(added); // { x: 1, y: 2, z: 0 }
```

# 36장 디스트럭처링 할당

# 36.1 배열 디스트럭처링 할당

- 배열의 각 요소를 배열로부터 추출하여 1개 이상의 변수에 할당한다.
- 이때 **배열 디스트럭처링 할당의 대상(할당문의 우변)은 이터러블이어야하며, 할당 기준은 배열의 인덱스**다. 즉 순서대로 할당된다.

```jsx
const arr = [1, 2, 3];

const [one, two, three] = arr;

console.log(one, two, three); // 1 2 3
```

- 우변에 배열 리터럴 형태이어야 하며, 할당하지 않으면 에러가 발생한다.

```jsx
const [x, y] = [1, 2];

const [x, y]; // SyntaxError

const [a, b] = {}; // TypeError
```

- 배열 디스트럭처링 할당의 기준은 배열의 인덱스다. 즉, 순서대로 할당된다.

```jsx
const [a, b] = [1, 2];
console.log(a, b) // 1 2

const [c, d] = [1];
console.log(c, d); // 1 undefined

const [e, f] = [1, 2, 3];
console.log(e, f); // 1 2

const [g, , h] = [1, 2, 3];
console.log(g, h); // 1 3
```

- 배열 디스트럭처링 할당을 위한 변수에 기본값을 설정할 수 있다.

```jsx
// 기본값
const [a, b, c = 3] = [1, 2];
console.log(a, b, c); // 1 2 3

// 기본값보다 할당된 값이 우선한다.
const [e, f = 10, g = 3] = [1, 2];
console.log(e, f, g); //  1 2 3
```

- 배열 디스트럭처링 할당을 위한 변수에 Rest 파라미터와 유사하게 **Rest 요소**를 사용할 수 있다.Rest 요소는 Rest 파라미터와 마찬가지로 반드시 마지막에 위치해야 한다.

```jsx
// Rest 요소
const [x, ...y] = [1, 2, 3];
console.log(x, y); // 1 [2, 3]
```

---

# 36.2 객체 디스트럭처링 할당

- 객체의 각 프로퍼티를 객체로부터 추출하여 1개 이상의 변수에 할당한다.
- 이때 객체 디스트럭처림 할당의 대상(할당문의 우변)은 객체이어야하며, **할당 기준은 프로퍼티 키**다.
- 즉, 순서는 의미 없으며 선언된 변수 이름과 프로퍼티 키가 일치하면 할당된다.

```jsx
const user = {
	firstName: 'Ungmo',
	lastName: 'Lee',
};

// 변수 lastName, firstName을 선언하고 user 객체를 디스트럭처링하여 할당한다.
// 이때 프로퍼티 키를 기준으로 디스트럭처링 할당이 이루어진다. 순서는 의미가 없다.
const { lastName, firstName } = user;

console.log(firstName, lastName); // Ungmo Lee
```

- 객체 디스트럭처링 할당을 위해서는 할당 연산자 왼쪽에 프로퍼티 값을 할당받을 변수를 선언해야 한다. 이때 변수를 객체 리터럴 형태로 선언한다.

```jsx
const { lastName, firstName } = { firstName: 'Ungmo', lastName: 'Lee' };
```

- 우변에 객체 또는 객체로 평가될 수 있는 표현식(문자열, 숫자, 배열 등)을 할당하지 않으면 에러가 발생한다.

```jsx
const {lastName, firstName}; // SyntaxError

const {lastName, firstName} = null; // TypeError
```

- 위 예제에서 객체 리터럴 형태로 선언한 변구 lastName, firstName이다. 프로퍼티 축약 표현을 통해 선언한 것이다.

```jsx
const { lastName, firstName } = user;
// 위와 아래는 동치다.
const { lastName: lastName, firstName: firstName } = user;
```

- 객체의 프로퍼티 키와 다른 변수 이름으로 프로퍼티 값을 할당받으려면 다음과 같이 변수를 선언한다.

```jsx
const user = {
  firstName: 'Ungmo',
  lastName: 'Lee',
};

// 프로퍼티 키를 기준으로 디스트럭처링 할당이 이루어진다.
const { lastName: ln, firstName: fn } = user;

console.log(fn, ln); // Ungmo Lee
```

- 객체 디스트럭처링 할당을 위한 변수에 기본값을 설정할 수 있다.

```jsx
const { firstName = 'Ungmo', lastName } = { lastName: 'Lee' };
console.log(firstName, lastName); // Ungmo Lee

const { lastName: ln, firstName: fn = 'Ungmo' } = { lastName: 'Lee' };
console.log(fn, ln); // Ungmo Lee
```

- 객체 디스트럭처링 할당은 객체에서 프로퍼티 키로 필요한 프로퍼티 값만 추출하여 변수에 할당하고 싶을 때 유용하다.

```jsx
const str = 'Hello';
// String 래퍼 객체로부터 length 프로퍼티만 추출한다.
const { length } = str;
console.log(length); // 5

const todo = { id: 1, content: 'HTML', completed: true };
// todo 객체로부터 id 프로퍼티만 추출한다.
const { id } = todo;
console.log(id); // 1
```

- 객체 디스트럭처링 할당은 객체를 인수로 전달받은 함수의 매개변수에도 사용할 수 있다.

```jsx
function printTodo({content, completed}) {
  console.log(`할일 ${content}은 ${completed ? '완료' : '비완료'} 상태입니다.`);
}

printTodo({ id: 1, content: 'HTML', completed: true }); // 할일 HTML은 완료 상태입니다.
```

- 배열의 요소가 객체인 경우 배열 디스트럭처링 할당과 객체 디스트럭처링 할당을 혼용할 수 있다.

```jsx
const todos = [
  { id: 1, content: 'HTML', completed: true },
  { id: 2, content: 'CSS', completed: false },
  { id: 3, content: 'JS', completed: false },
];

// todos 배열의 두 번째 요소인 객체로부터 id 프로퍼티만 추출한다.
const [, { id }] = todos;
console.log(id); // 2
```

- 중첩 객체의 경우는 다음과 같이 사용한다.

```jsx
const user = {
  name: 'Lee',
  address: {
    zipCode: '03068',
    city: 'Seoul',
  },
};

// address 프로퍼티 키로 객체를 추출하고 이 객체의 city 프로퍼티 키로 값을 추출한다.
const { address: { city } } = user;
console.log(city); // 'Seoul'
```

- 객체 디스트럭처링 할당을 위한 Rest 파라미터나 Rest 요소와 유사하게 **Rest 프로퍼티 `...`** 을 사용할 수 있다.
- 반드시 마지막에 위치해야 한다.

```jsx
// Rest 프로퍼티
const { x, ...rest } = { x: 1, y: 2, z: 3 };
console.log(x, rest); // 1 {y: 2, z: 3}
```

# 37장 Set과 Map

**37.1.5 요소 삭제**

- Set.prototype.delete 메서드를 이용한다.
- 존재하지 않는 Set 객체의 요소를 삭제하려 하면 에러 없이 무시된다.
- delete 메서드는 삭제 성공 여부를 나타내는 **불리언 값을 반환한다.** 따라서 Set.prototype.add 메서드와 달리 **연속적으로 호출할 수 없다.**

```jsx
const set = new Set([1, 2, 3]);

set.delete(0); // Set(3) {1, 2, 3}

set.delete(1).delete(2); // TypeError
```

**37.1.6 요소 일괄 삭제**

- Set.prototype.clear 메서드를 이용한다.
- 언제나 undefined를 반환한다.

```jsx
const set = new Set([1, 2, 3]);

set.clear();
console.log(set); // Set(0) {}
```

**37.1.7 요소 순회**

- Set.prototype.forEach 메서드를 이용한다.
- Set.prototype.forEach 메서드는 Array.prototype.forEach 메서드와 유사하게 forEach 메서드의 콜백 함수 내부에서 this로 사용될 객체를 인수로 전달한다.
    - 첫 번째 인수: 현재 순회 중인 요소값
    - 두 번째 인수: 현재 순회 중인 요소값
    - 세 번째 인수: 현재 순회 중인 Set 객체 자체
- 첫 번째 인수와 두 번째 인수는 같은 값이다. 이처럼 동작하는 이유는 Array.prototype.forEach 메서드와 인터페이스를 통일하기 위함이며 다른 의미는 없다.

```jsx
const set = new Set([1, 2, 3]);

set.forEach((v, v2, set) => console.log(v, v2, set));
/*
1 1 Set(3) {1, 2, 3}
2 2 Set(3) {1, 2, 3}
3 3 Set(3) {1, 2, 3}
*/
```

- Set 객체는 **이터러블**이다. 따라서 for…of 문으로 순회할 수 있으며 스프레드 문법과 배열 디스트럭처링의 대상이 될 수 있다.

```jsx
const set = new Set([1, 2, 3]);

console.log(Symbol.iterator in set); //true

// 1. for...of 순회
for (const value of set) {
  console.log(value); // 1 2 3
}

// 2. 스프레드 문법
console.log([...set]); // [1 2 3]

// 3. 배열 디스트럭처링
const [a, ...rest] = set;
console.log(a, rest); // 1, [2, 3]
```

**37.1.8 집합 연산**

- Set 객체는 **수학적 집합**을 구현하기 위한 자료구조다.
- Set 객체를 통해 **교집합, 합집합, 차집합** 등을 구현할 수 있다.

**교집합**

- 집합 A와 집합 B의 공통 요소

```jsx
Set.prototype.intersection = function (set) {
  const result = new Set();

  for (const value of set) {
    if (this.has(value)) result.add(value);
  }
  return result;
};

const setA = new Set([1, 2, 3, 4]);
const setB = new Set([2, 4]);

console.log(setA.intersection(setB)); // Set(2) {2, 4}
console.log(setB.intersection(setA)); // Set(2) {2, 4}
```

또는 다음 같은 방법으로도 가능하다.

```jsx
Set.prototype.intersection = function (set) {
  return new Set([...this].filter((v) => set.has(v)));
};

const setA = new Set([1, 2, 3, 4]);
const setB = new Set([2, 4]);

console.log(setA.intersection(setB)); // Set(2) {2, 4}
console.log(setB.intersection(setA)); // Set(2) {2, 4}
```

**합집합**

- 집합 A와 집합 B의 중복 없는 모든 요소

```jsx
Set.prototype.union = function (set) {
  const result = new Set(this);

  for (const value of set) {
    result.add(value);
  }

  return result;
};

const setA = new Set([1, 2, 3, 4]);
const setB = new Set([2, 4]);

console.log(setA.union(setB)); // Set(4) {1, 2, 3, 4}
console.log(setB.union(setA)); // Set(4) {2, 4, 1, 3}
```

또는 다음 같은 방법으로도 가능하다.

```jsx
Set.prototype.union = function (set) {
  return new Set([...this, ...set]);
};

const setA = new Set([1, 2, 3, 4]);
const setB = new Set([2, 4]);

console.log(setA.union(setB)); // Set(4) {1, 2, 3, 4}
console.log(setB.union(setA)); // Set(4) {2, 4, 1, 3}
```

**차집합**

- 집합 A에는 존재하지만 집합 B에는 존재하지 않는 요소

```jsx
Set.prototype.difference = function (set) {
  const result = new Set(this);

  for (const value of set) {
    result.delete(value);
  }

  return result;
};

const setA = new Set([1, 2, 3, 4]);
const setB = new Set([2, 4]);

console.log(setA.difference(setB)); // Set(2) {1, 3}
console.log(setB.difference(setA)); // Set(0) {}
```

또는 다음 같은 방법으로도 가능하다.

```jsx
Set.prototype.difference = function (set) {
		return new Set([...this.filter(v => !set.has(v)));
}

const setA = new Set([1, 2, 3, 4]);
const setB = new Set([2, 4]);

console.log(setA.difference(setB)); // Set(2) {1, 3}
console.log(setB.difference(setA)); // Set(0) {}
```

**부분 집합과 상위 집합**

- 집합 A가 집합 B에 포함되는 경우 집합 A는 집합 B의 부분 집합이며, 집합 B는 집합 A의 상위 집합이다.

```jsx
Set.prototype.isSuperset = function (subset) {
  for (const value of subset) {
    if (!this.has(value)) return false;
  }

  return result;
};

const setA = new Set([1, 2, 3, 4]);
const setB = new Set([2, 4]);

console.log(setA.difference(setB)); // Set(2) {1, 3}
console.log(setB.difference(setA)); // Set(0) {}
```

또는 다음 같은 방법으로도 가능하다.

```jsx
Set.prototype.isSuperset = function (subset) {
  const supersetArr = [...this];
  return [...subset].every((v) => supersetArr.includes(v));
};

const setA = new Set([1, 2, 3, 4]);
const setB = new Set([2, 4]);

console.log(setA.isSuperset(setB)); // true
console.log(setB.isSuperset(setA)); // false
```
