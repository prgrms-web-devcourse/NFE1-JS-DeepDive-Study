# CH8 제어문

제어문이란? 조건에 따라 코드 블록을 실행 하거나 반복실행(반복문) 할 때 사용.

- 위에서 아래 방향으로 순차적으로 실행

## 8.1 블록문

- 0개 이상의 문을 중괄호로 묶은 것
- 코드 블록으로 부르기도 함
- 블록문 끝에는 세미콜론(;)을 붙이지 않음. → 자체 종결성을 갖고 있기 때문!

## 8.2 조건문

- 조건문은 주어진 조건식의 평가 결과에 따라 코드 블록(블록문)의 실행을 결정함
- 불리언 값으로 평가될 수 있는 표현식
    - if…else 문
    - switch 문

### 8.2.1 if … else 문

- 주어진 조건식의 평가 결과, 즉 논리적 참 또는 거짓에 따라 실행할 코드 블록을 결정
- 평가 결과
    - true : if 문의 코드 블록이 실행됨
    - false : else 문의 코드 블록 실행됨
- if문의 조건식은 불리언 값으로 평가되어야 함
    - 그렇지 않을 경우 → “암묵적 타입 변환” (9장)
- else if , else 문은 옵션.
- if, else 문은 한 번만 사용 가능
- else if 문은 여러번 사용 가능
- 코드 내의 블록이 하나 뿐이라면 중괄호 생략 가능
- 대부분의 if … else 문은 삼항 조건 연산자로 바꿔 쓸 수 있다.

### 8.2.2 switch 문

- 주어진 표현식을 평가하여 그 값과 일치하는 표현식을 갖는 case 문으로 실행 흐름을 옮김
- case : 상황을 의미하는 표현식을 지정, 콜론으로 마침.
- switch 문의 표현식과 일치한느 case 문 없으면 실행 순서는 defalut 문으로 이동 (선택사항)
- 불리언 값으로 평가되는 if … else 문과는 다르게 switch 문은 문자열이나 숫자 값인 경우가 많음
- 참, 거짓의 논리 보다는 다양한 상황(case)에 따라 힐생할 코드의 블록 결정할때 사용
- break 문 : 코드 블록에서 탈출. case문에 꼭 필요함
    - defalut 문에는 break 문 생략하는 것이 일반적.

**그래서 둘 중 뭐가 더 좋은가?**

if … else 문으로 해결할 수 있다면 이게 좋다. 

그치만 가독성이 switch문이 더 좋다면 이것 쓰는게 좋다.

## 8.3 반복문

- 조건식의 평가 결과가 참인 경우 코드 블록 실행
- for 문, while 문, do … while 문

### 8.3.1 for 문

- 거짓으로 평가될 때까지 코드 블록을 반복 실행함
- 매우 중요하다고 한다…
- 변수 선언문, 조건식, 증감식은 모두 옵션, 반드시 사용할 필요는 없음
    - 단, 어떤 식도 선언 안하면 **무한루프** 가 됨
- 중첩 사용할 수 있음

### 8.3.2 while 문

- 주어진 조건식의 평가 결과가 참이면 코드 블록을 계속해서 반복 실행
- for 문 : 반복 횟수가 명확할 때 가용
- whild 문 : 반복횟수가 불명확할 때 사용
- 조건문 평가 결과 거짓이 되면 코드 블록 실행하지 않고 종료.
- 평가 결과가 불리언 값이 아니면? ➡️ 불리언 값으로 강제 변환 후 논리적 참, 거짓 구별
- 무한루프 탈출하기 위해 코드 블록 내에 if 문 탈출조건 만들고 break 문으로 코드 블록 탈출

### 8.3.3 do … while 문

- 코드 블록을 먼저 실행하고 조건식을 평가함 → 무조건 한 번 이상 실행됨

## 8.4 break 문

- 코드 블록을 탈출한다.
- 레이블 문, 반복문, switch 문의 코드 블록 외에 break 문을 사용하면? ➡️ SyntaxError
- 레이블 문이란? **식별자가 붙은 문**
    - 중첩된 for 문 외부로 탈출에 유용
    - 그 밖에 경우에는 권장 X → 가독성 나빠지고 오류 발생 가능성 높아짐
- 반복문, switch 문에서도 불필요한 부분에선 사용 지양하는게 좋음

## 8.5 continue 문

- 반복문의 코드 블록 실행을 현 지점에서 중단, 반복문의 증감식으로 실행 흐름을 이동시킴
- break 문처럼 반복문 탈출은 X

---

# CH9 타입 변환과 단축 평가

## 9.1 타입 변환이란?

- 개발자가 의도적으로 타입을 변환하는 것 ➡️ **명시적 타입 변환** 또는 **타입 캐스팅**이라고 함
- 개발자 의도와 다르게 JS 엔진에 의해 암묵적으로 타입 작동이 변환됨 ➡️ **암묵적 타입 변환** 또는 **타입 강제 변환**

**암묵적 타입 변환**

- 기존 변수 값을 재할당 하는 것이 아님
- 코드에 의미가 명백히 드러나지 않음

**명시적 타입 변환**

- 타입을 변경하겠다는 개발자의 의지가 코드에 명백히 드러남

## 9.2 암묵적 타입 변환

- 코드의 문맥이 부합하지 않는 다양한 상황에서 JS 자체적으로 타입 변환
- 문자열, 숫자, 불리언과 같은 원시 타입 중 하나로 타입 자동변환

## 9.3 명시적 타입 변환

- 개발자의 의도에 따라 명시적으로 타입 변경하는 방법은 다양함
- 문자열 타입으로 변환
- 숫자 타입으로 변환
- 불리언 타입으로 변환

## 9.4 단축 평가

**표현식을 평가하는 도중에 평가 결과가 확정된 경우나머지 평가 과정을 생략하는 것**

### 9.4.1 논리 연산자를 사용한 단축 평가

- 논리곱(&&) 연산자는 두 개의 피연산자가 모두 true 로 평가될 때 true 반환
- 논리합(||) 연산자는 두 개의 피연산자 중 하나만 true 로 평가되도 true 반환
- 이처럼 논리 연산의 결과를 결정하는 피연산자를 타입 변환하지 않고 그대로 반환 → **단축평가**

### 9.4.2 옵셔널 체이닝 연산자

- ES11 에서 도입됨 ?.
- 좌상의 피연산자가 null 또는 undefind 인 경우 undefind 반환
- 그렇지 않으면 우항의 프로퍼티 참조를 이어간다.

### 9.4.3 null 병합 연산자

- ??
- 좌상의 피연산자가 null 또는 undefind 인 경우 우항의 피연산자 반환
- 그렇지 않으면 좌항의 피연산자 반환

---

# CH10 객체 리터럴

## 10.1 객체란?

- 자바스크립트는 객체 기반의 프로그래밍 언어이며, 자바스크립트를 구성하는 거의 “모든 것”이 객체
- 원시 값을 제외한 나머지 값은(함수, 배열, 정규표현식 등) 모두 객체
- 객체 타입의 값 : 변경 가능한 값 (mutable value)
- 원시 타입의 값 : 변경 불가능 한 값 (immutable value)
- 객체는 0개 이상의 프로퍼티로 구성된 집합, 프로퍼티는 키 key , 와 값 value로 구성되어 있음
- 함수도 프로퍼티 값으로 사용할 수 있음.
    - 프로퍼티 값이 함수일 경우, 일반 함수와 구분하기 위해 매서드(method)라 부른다.

## 10.2 객체 리터럴에 의한 객체 생성

- 사전에 정의하고 필요한 시점에 new 연산자와 함께 생성자를 호출하여 인스턴스를 생성하는 방식으로 객체 생성
- 클래스 기반 객체지향 언어와 달리 **다양한 객체지생성 방법 지원**
    - 객체 리터럴
    - Object 생성자 함수
    - 생성자 함수
    - Object.create  메서드
    - 클래스(ES6)
- 리터럴을 사용하는 방법 : 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용하여 값 생성하는 표기법
    - 객체 리터럴 : 중괄호 ({…}) 내에 0개 이상의 프로퍼티 정의

## 10.3 프로퍼티

**객체는 프로퍼티의 집합이며, 프로퍼티는 키와 값으로 구성된다**

## 10.4 메서드

- 프로퍼티 값이 함수일 경우, 일반 함수와 구분하기 위해 메서드라 부른다.
- **객체에 묶여 있는 함수**
- 매서드 내부에서 사용한 **this 키워드** : **객체 자신을 가리키는 참조변수**

## 10.5 프로퍼티 접근

두 가지 방법

1. **마침표 표기법** : 마침표 프로퍼티 접근 연산자(.)를 사용 (dot notation)
2. **대괄효 표기법** : 대괄호 프로퍼티 접근 연산자 ([…])를 사용 (bracket notation)

## 10.6 프로퍼티 값 갱신

이미 존재하는 프로퍼티에 값을 할당하면 프로퍼티 값이 **갱신**됨

- 프로퍼티 동적 생성 : 존재하지 않는 프로퍼티 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 프로퍼티 값이 할당 됨
- 프로퍼티 삭제 : delete 연산자는 객체의 프로퍼티를 삭제.

---

# CH11 원시 값과 객체의 비교

JS를 원시 타입과 객체 타입으로 구분하는 이유는 뭘까?

크게 세 가지 측면에서 다름

1. **원시 타입의 값은 변경 불가능한 값**이다. but 객체(참조)타입의 값, **객체는 변경 가능한 값임**
2. 원시 값을 변수에 할당하면 변수(확보된 메모리 공간)에는 실제 값 저장됨  but 객체를 변수에 할당하면? 변수(확보된 메모리 공간)에는 참조 값이 저장 됨
3. 원시 값을 갖는 변수를 다른 변수에 할당하면? 원시 값이 복사되어 전달됨 → **값에 의한 전달**
객체를 가리키는 변수를 다른 변수에 할당하면? 원본의 참조 값이 복사되어 전달 → **참조에 의한 전달**

(나중에 표로 정리해봐야 겠다!)

## 11.1 원시 값

- 변경 불가능한 값
- 읽기 전용(read only) 값, 변경할 수 없음
- 변경 불가능 한 것 : 값에 대한 진술 (O) 변수 (X)
- 데이터의 신뢰성을 보장해줌
- 불변성
- 재할당 외에 변수 값 변경할 수 있는 방법 없음

## 11.2 객체

- 프로퍼티의 개수가 정해져 있지 않음
- 동적으로 추가, 삭제 가능, 프로퍼티 값에 제약 없음
- 확보해야 할 메모리 공간 사전에 정해둘 필요 없음
- 복합적인 자료구조 : 객체 관리 방식 복잡, 브라우저마다 구현 방식 다름
- 변경 가능한 값
- 메모리 공간에 접근하면 참조 값에 접근할 수 있다.
- 참조 값 : 객체를 할당한 변수엔 생성된 객체가 실제로 저장된 메모리 공간의 주소가 저장됨
    - 이 참조값으로 객체에 접근
- 재할당 없이 객체를 직접 변경할 수 있다
    - 프로퍼티 값 갱신, 프로퍼티 자체 삭제 가능

---

# CH12 함수

## 12.1 함수란?

- JS에거 가장 중요한 핵심 개념!
- 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것
- **매개변수** : 함수 내부로 입력을 전달받는 별수
- **인수** : 입력
- **반환값** : 출력
- 함수는 값이며, 여러 개 존재할 수 있으므로 특정 함수를 구별하기 위해 식별자인 함수 이름을 사용할 수 있음
- **함수 정의**를 통해 생성. 다양하게 정의할 수 있음 (function definition)
- 함수 호출 : 인수(argument)를 매개변수를 통해 함수에 전달하면서 함수의 실행을 명시적으로 지시

## 12.2 함수를 사용하는 이유

- 필요할 때 여러번 호출 가능
- 실행 시점 개발자가 결정할 수 있고, 재사용 가능
- **코드의 재사용 측면**에서 매우 유용
- 유지보수의 편의성, 코드의 신뢰성 증대, 코드의 가독성 향상
- 좋은 코드란? 사람이 이해할 수 있는 코드. 즉 가독성이 좋은 코드!

## 12.3 함수 리터럴

- 숫자 값을 숫자 리터럴로 생성하고, 객체를 객체 리터럴로 생성하는 것처럼 → 함수도 함수 리터럴로 생성할 수 있다!!
- function 키워드, 함수 이름, 매개변수 목록, 함수 몸체로 구성
- **함수는 객체다! 함수 리터럴도 평가되어 값을 생성하며, 이 값은 객체이기 때문**
- But 함수 객체는 일반 객체와 다름. **일반 객체는 호출할 수 없지만 함수는 호출할 수 있다.**
    - 함수 객체만의 고유한 프로퍼티를 가짐(일반 객체는 X)
    - 함수가 객체라는 사실은 다른 프로그래밍 언어와 구분되는 매우 중요한 특징!

## 12.4 함수 정의

- 함수를 호출하기 이전에 인수를 전달받을 매개변수와 실행할 문들, 반환할 값을 지정하는 것
    - 정의된 함수 → JS엔진에 의해 평가되어 함수 객체가 됨
- 함수 정의하는 방법 4가지
    - 함수 선언문 : 함수 이름 생략 X, 표현식이 아닌 문
    - 함수 표현식 : 일급 객체
    - Functioin 생성자 함수 : new 연산자와 함께 호출하면 함수 객체를 생성해서 반환
    - 화살표 함수(ES6) : function 대신 화살표 사용, 간략, 항상 익명함수

## 12.5 함수 호출

- 값을 함수 외부 → 내부로 전달할 필요 없는 경우 : 매개변수를 통해 인수를 전달
- 매개변수 : 함수 정의할 떄 선언
- 인수 확인
- 매개변수의 최대 개수
    - 순서에 의미 있음
    - 적을수록 좋음 (0개가 이상적인 갯수), 3개 이상 넘지 않는 것을 추천.
    - 이상적인 함수 : 한 가지 일만 해야 하고 가급적 작게 만들어야 한다.
- 반환문 : return
    - 함수 호출 = 표현식
    - 반환문은 return 키워드 뒤에 오는 표현식을 평가해 반영 (명시적 지정 안해놓으면 undefind 반환)

## 12.7 다양한 함수의 형태

1. 즉시 실행 함수 : 정의와 동시에 즉시 실행
2. 재귀 함수 : 자기 자신을 호출
3. 중첩 함수 
    1. 중첩함수 : 내부에 정의된 함수
    2. 외부함수 : 중첩 함수를 포함하는 함수
    3. 헬퍼함수 : 중첩함수 중 자신을 포함하는 외부 함수
4. 콜백 함수 : repeat 함수, 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수.
5. 순수 함수와 비순수 함수
    1. 순수함수 : 어떤 외부 상태에 의존, 변경하지 않는 함수
    2. 비순수 함수 : 외부 상태에 의존, 외부 상태 변경하는 함수

---

# CH13 스코프

## 13.1 스코프란?

- 식별자가 유효한 범위
    - 스코프 : 모든 식별자는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 우효 범위가 결정됨.
    - JS 엔진이 식별자를 검색할 때 사용하는 규칙

## 13.2 스코프의 종류

코드는 크게 2로 나뉜다.

| 구분 | 설명 | 스코프 | 변수 |
| --- | --- | --- | --- |
| 전역 | 코드의 가장 바깥 영역 | 전역 스코프 | 전역 변수 |
| 지역 | 함수 몸체 내부 | 지역 스코프 | 지역 변수 |
- 전역 변수
    - 어디서든지 참조 가능
    - 전역 스코프를 만듦
- 지역 변수
    - 지역 : 함수 몸체 내부
    - 자신의 지역 스코프와 하위 지역 스코프에서 유효

## 13.3 스코프 체인

- 스코프가 함수의 중첩에 의해 계층적 구조를 갖는다는 의미
- 스코프 체인 : 스코프가 계층적으로 연결된 것
- 변수 참조할 때, JS 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색 (inner 지역 스코프 → outer 지역 스코프 → 전역 스코프)
- 상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조 가능
- But 하위 스코프에서 유효한 변수를 상위 스코프에서 참조할 수 없음

## 13.4 함수 레벨 스코프

- 코드 블록이 아닌 함수에 의해서만 지역 스코프가 생성
- 블록 레벨 스코프 : 대부분의 프로그래밍 언어는 함수 몸체만이 아니라 모든 코드 블록이 지역 스코프를 만듦
- **var 키워드 : 선언된 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정**
- 함수 레벨 스코프

## 13.5 렉시컬 스코프

- JS 비롯한 대부분의 프로그래밍 언어는 렉시컬 스코프를 따름
- JS는?
    - 렉시컬 스코프를 따르므로, 함수를 어디서 호출했는제 X 어디서 정의했는지 따라 상위 스코프 결정.
    - 함수가 호출된 위치는 상위 스코프 결정에 어떠한 영향도 주지 않는다. (상위 스코프는 언제가 자신이 정의된 스코프)
    - 상의 스코프 : 함수 정의사 실행될 때 정적으로 결정됨

---

# CH14 전역 변수의 문제점

## 14.1 변수의 생명 주기

- 지역 변수의 생명 주기 == 함수의 생명 주기
- 호이스팅 : 스코프 단위로 동작
    - 변수 선언이 스코프의 선두로 끌어 올려진 것처럼 동작하는 JS 고유의 특징
- var 키워드로 선언한 전역 변수 생명주기 == 전역 객체 생명주기

## 14.2 전역 변수의 문제점

- 암묵적 결합 : 모든 코드가 전역 변수를 참조하고 변경할 수 있다, 위험성 up
- 긴 생명 주기 : 메모리 리소스 오랜 기간 소비, 전역 변수의 상태를 변경할 수 있는 시간과 기회 많음
- 스코프 체인 상에서 종점에 좀재 : 전역 변수의 검색 속도가 가장 느림
- 네임스페이스 오염 : 다른 파일 내에서 동일한 이름으로 망명된 전역 변수, 전역 함수가 같은 스코프 내에 존재할 경우 → 예상치 못한 결과

## 14.3 전역 변수의 사용을 억제하는 방법

- 전역 변수 사용할 이유 없으면 지역 변수 사용해야 함
- 변수의 스코프는 좁을수록 좋음