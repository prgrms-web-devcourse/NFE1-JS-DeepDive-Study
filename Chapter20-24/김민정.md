# 모던 자바스크립트 딥다이브 스터디 4회

## 목차

- 20
- 21
- 22
- 23
- 24

## 질문

## 20장: strict mode

### 20.1 strict mode란?

- strict mode를 사용하지 않았을 때 발생하는 문제
  - 암묵적 전역
- strict mode를 추가하는 경우
  - 문제 일으킬 수 있는 코드에 대해 명시적 에러 발생
- strict mode 대체
  - ESLint와 같은 린트 도구
  - 정적 분석 기능을 활용

### 20.3 전역에 strict mode를 적용하는 것은 피하자

- 이유
  - 외부 서드파티 라이브러리가 non-strict mode일 수 있음
- 방법
  1. 즉시 실행 함수로 스크립트 전체를 감싸기
  2. 스코프 구분하기
  3. 즉시 실행 함수 선두에 strict mode 적용하기

### 20.6 strict mode 적용에 의한 변화

- 일반 함수 this
  - undefined가 바인딩
- 생성자 함수 this
  - 생성자 함수가 바인딩
- arguments 객체
  - 매개변수에 전달된 인수를 내부에서 재할당해도 반영X

## 21장: 빌트인 객체

### 21.1 자바스크립트 객체 분류

- 표준 빌트인 객체
  - ECMAScript 사양에 정의된 객체
- 호스트 객체
  - 자바스크립트 실행 환경(브라우저, Node.js)에서 추가로 제공하는 객체
  - 브라우저: Web API
  - Node.js: Node.js 고유의 API
- 사용자 정의 객체

### 21.2 표준 빌트인 객체

- 표준 빌트인 객체
  - 인스턴스 생성할 수 있는 생성자 함수 객체(Math, Reflect, JSON 제외)
  - 인스턴스에 프로토타입 메서드 제공
  - 인스턴스 없이 호출 가능한 정적 메서드 제공
- 과정
  1. 표준 빌트인 객체 String을 생성자 함수로 호출
  2. String 인스턴스 생성
     1. String 인스턴스의 프로토타입===String.prototype

### 21.3 원시값과 래퍼 객체

- 원시값이 있는데 표준 빌트인 생성자 함수 존재하는 이유
  - 원시값: 객체가 아니기에, 프로퍼티+메서드 사용 불가능
  - 원시값을 객체처럼 작동하게 하기 위해 존재!
- 원시값 객체처럼 작동하게 하는 방법
  - 자바스크립트 엔진이 일시적으로 원시값을 연관된 객체로 변환
  - 프로퍼티에 접근하거나 메서드를 호출하고 다시 원시값으로 되돌림
- 래퍼 객체
  - 원시값을 객체처럼 접근하면 생성되는 임시 객체
- 과정
  1. 문자열 마침표 표기법 접근
  2. 래퍼 객체인 String 생성자 함수 인스턴스 생성
  3. 문자열 래퍼 객체의 [[StringData]] 내부 슬롯에 할당
  4. 래퍼 객체 처리 종료
  5. 래퍼 객체의 [[StringData]] 내부 슬롯에 할당된 원시값으로 원래의 값 되돌림
     1. 이때, 3-4번 사이에 추가로 생성한 속성이 있어도 래퍼 객체에 저장이 되나 해당 객체가 종료되기에 값도 사라지게 됨
     2. 원시값을 출력하면 추가한 속성은 존재하지 않음!
  6. 래퍼 객체 가비지 컬렉션 대상이 됨

### 21.4 전역 객체

- 전역 객체
  - 브라우저: window
  - Node.js: global
  - 프로퍼티
    - 표준 빌트인 객체
    - 호스트 객체
    - 전역 변수, 전역 함수
- 전역 객체: 주의점
  - 상속
    - 프로토타입 상속 관계에서 최상위X
    - 프로퍼티로 소유O
  - var
    - 전역 객체 프로퍼티O
  - let, const
    - 전역 객체 프로퍼티X
    - 보이지 않는 개념적 블록 내에 존재
  - 여러 script
    - 하나의 window 공유
- 빌트인 전역 프로퍼티
  - 전역 객체의 프로퍼티
- 빌트인 전역 함수
  - 전역 객체의 메서드
  - eval
    - ⚠️ 사용을 금지하는 것이 좋음
    - 표현식 여부
      - 표현식: 문자열 코드 런타임에 평가 > 값 생성
      - 표현식X: 무자열 코드 런타임에 실행
    - 여러개로 구성되면 마지막 결과값 반환
    - strict mode 여부
      - strict mode X: 호출된 함수 스코프에서 실행
      - strict mode O: 자신의 자체적 스코프 생성
    - let, const
      - 암묵적 strict mode 실행, 자체적 스코프 생성
  - isFinite
    - 정상적인 유한수인지 검사
      - 무한수, NaN: false return
      - null: 0으로 반환해 true return
  - isNaN
    - new Date(): number
    - new Date().toString(): NaN
  - parseFloat
    - 공백으로 구분된 문자열은 첫 번째 문자열만 변환
    - 공백으로 구분된 문자열은 첫 번째 문자열이 숫자로 변환하지 못하면: NaN return
  - parseInt
    - parseInt(A, B)
      - A: B에 해당하는 인수의 형태라고 생각하고, 10진수로 변경
      - B: 해당하는 인수
    - parseInt(A.toString(B), B)
      - A.toString(B): A를 B의 형태로 바꾼 후, 10진수로 변경, A return!
      - B: 해당하는 인수
- encodeURI, decodeURI
  - URL: 아스키 문자 set으로만 구성되어야 하기에, 이스케이프 처리 필요
- encodeURIComponent, decodeURIComponent
  - encodeURI
    - 매개변수로 전달된 문자열: 완전한 URI 전체
    - =?& 인코딩X
  - encodeURIComponent
    - 매개변수로 전달된 문자열: URI 구성 요소인 쿼리 스트링의 일부
    - =?& 인코딩O
- 암묵적 전역
  - 선언하지 않은 식별자에 값을 할당하면 전역 객체의 프로퍼티가 됨
  - 단, 전역 객체의 프로퍼티이지 변수가 아니기에 변수 호이스팅 발생X
  - 전역 변수 VS 암묵적 전역
    - 전역 변수: delete로 삭제 불가능
    - 프로퍼티: delete로 삭제 가능

## 23장

- 현재 진행중

## 24장

- 진행 예정
