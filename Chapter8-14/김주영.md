# CH8 제어문

제어문이란? 조건에 따라 코드 블록을 실행 하거나 반복실행(반복문) 할 때 사용.

- 위에서 아래 방향으로 순차적으로 실행

## 8.1 블록문

- 0개 이상의 문을 중괄호로 묶은 것
- 코드 블록으로 부르기도 함
- 블록문 끝에는 세미콜론(;)을 붙이지 않음. → 자체 종결성을 갖고 있기 때문

## 8.2 조건문

- 조건문은 주어진 조건식의 평가 결과에 따라 코드 블록(블록문)의 실행을 결정함
- 불리언 값으로 평가될 수 있는 표현식
    - if…else 문
    - switch 문

### 8.2.1 if … else 문

- 주어진 조건식의 평가 결과, 즉 논리적 참 또는 거짓에 따라 실행할 코드 블록을 결정
- 평가 결과
    - true : if 문의 코드 블록이 실행됨
    - false : else 문의 코드 블록 실행됨
- if문의 조건식은 불리언 값으로 평가되어야 함
    - 그렇지 않을 경우 → “암묵적 타입 변환” (9장)
- else if , else 문은 옵션.
- if, else 문은 한 번만 사용 가능
- else if 문은 여러번 사용 가능
- 코드 내의 블록이 하나 뿐이라면 중괄호 생략 가능
- 대부분의 if … else 문은 삼항 조건 연산자로 바꿔 쓸 수 있다.

### 8.2.2 switch 문

- 주어진 표현식을 평가하여 그 값과 일치하는 표현식을 갖는 case 문으로 실행 흐름을 옮김
- case : 상황을 의미하는 표현식을 지정, 콜론으로 마침.
- switch 문의 표현식과 일치한느 case 문 없으면 실행 순서는 defalut 문으로 이동 (선택사항)
- 불리언 값으로 평가되는 if … else 문과는 다르게 switch 문은 문자열이나 숫자 값인 경우가 많음
- 참, 거짓의 논리 보다는 다양한 상황(case)에 따라 힐생할 코드의 블록 결정할때 사용
- break 문 : 코드 블록에서 탈출. case문에 꼭 필요함
    - defalut 문에는 break 문 생략하는 것이 일반적.

**그래서 둘 중 뭐가 더 좋은가?**

if … else 문으로 해결할 수 있다면 이게 좋다. 

그치만 가독성이 switch문이 더 좋다면 이것 쓰는게 좋다.

## 8.3 반복문

- 조건식의 평가 결과가 참인 경우 코드 블록 실행
- for 문, while 문, do … while 문

### 8.3.1 for 문

- 거짓으로 평가될 때까지 코드 블록을 반복 실행함
- 매우 중요하다고 한다…
- 변수 선언문, 조건식, 증감식은 모두 옵션, 반드시 사용할 필요는 없음
    - 단, 어떤 식도 선언 안하면 **무한루프** 가 됨
- 중첩 사용할 수 있음

### 8.3.2 while 문

- 주어진 조건식의 평가 결과가 참이면 코드 블록을 계속해서 반복 실행
- for 문 : 반복 횟수가 명확할 때 가용
- whild 문 : 반복횟수가 불명확할 때 사용
- 조건문 평가 결과 거짓이 되면 코드 블록 실행하지 않고 종료.
- 평가 결과가 불리언 값이 아니면? ➡️ 불리언 값으로 강제 변환 후 논리적 참, 거짓 구별
- 무한루프 탈출하기 위해 코드 블록 내에 if 문 탈출조건 만들고 break 문으로 코드 블록 탈출

### 8.3.3 do … while 문

- 코드 블록을 먼저 실행하고 조건식을 평가함 → 무조건 한 번 이상 실행됨

## 8.4 break 문

- 코드 블록을 탈출한다.
- 레이블 문, 반복문, switch 문의 코드 블록 외에 break 문을 사용하면? ➡️ SyntaxError
- 레이블 문이란? **식별자가 붙은 문**
    - 중첩된 for 문 외부로 탈출에 유용
    - 그 밖에 경우에는 권장 X → 가독성 나빠지고 오류 발생 가능성 높아짐
- 반복문, switch 문에서도 불필요한 부분에선 사용 지양하는게 좋음

## 8.5 continue 문

- 반복문의 코드 블록 실행을 현 지점에서 중단, 반복문의 증감식으로 실행 흐름을 이동시킴
- break 문처럼 반복문 탈출은 X

---

# CH9 타입 변환과 단축 평가

## 9.1 타입 변환이란?

- 개발자가 의도적으로 타입을 변환하는 것 ➡️ **명시적 타입 변환** 또는 **타입 캐스팅**이라고 함
- 개발자 의도와 다르게 JS 엔진에 의해 암묵적으로 타입 작동이 변환됨 ➡️ **암묵적 타입 변환** 또는 **타입 강제 변환**

**암묵적 타입 변환**

- 기존 변수 값을 재할당 하는 것이 아님
- 코드에 의미가 명백히 드러나지 않음

**명시적 타입 변환**

- 타입을 변경하겠다는 개발자의 의지가 코드에 명백히 드러남

## 9.2 암묵적 타입 변환

- 코드의 문맥이 부합하지 않는 다양한 상황에서 JS 자체적으로 타입 변환
- 문자열, 숫자, 불리언과 같은 원시 타입 중 하나로 타입 자동변환

## 9.3 명시적 타입 변환

- 개발자의 의도에 따라 명시적으로 타입 변경하는 방법은 다양함
- 문자열 타입으로 변환
- 숫자 타입으로 변환
- 불리언 타입으로 변환

## 9.4 단축 평가

**표현식을 평가하는 도중에 평가 결과가 확정된 경우나머지 평가 과정을 생략하는 것**

### 9.4.1 논리 연산자를 사용한 단축 평가

- 논리곱(&&) 연산자는 두 개의 피연산자가 모두 true 로 평가될 때 true 반환
- 논리합(||) 연산자는 두 개의 피연산자 중 하나만 true 로 평가되도 true 반환
- 이처럼 논리 연산의 결과를 결정하는 피연산자를 타입 변환하지 않고 그대로 반환 → **단축평가**

### 9.4.2 옵셔널 체이닝 연산자

- ES11 에서 도입됨 ?.
- 좌상의 피연산자가 null 또는 undefind 인 경우 undefind 반환
- 그렇지 않으면 우항의 프로퍼티 참조를 이어간다.

### 9.4.3 null 평합 연산자

- ??
- 좌상의 피연산자가 null 또는 undefind 인 경우 우항의 피연산자 반환
- 그렇지 않으면 좌항의 피연산자 반환

---

# CH10 객체 리터럴

## 10.1 객체란?

- 자바스크립트는 객체 기반의 프로그래밍 언어이며, 자바스크립트를 구성하는 거의 “모든 것”이 객체
- 원시 값을 제외한 나머지 값은(함수, 배열, 정규표현식 등) 모두 객체
- 객체 타입의 값 : 변경 가능한 값 (mutable value)
- 원시 타입의 값 : 변경 불가능 한 값 (immutable value)
- 객체는 0개 이상의 프로퍼티로 구성된 집합, 프로퍼티는 키 key , 와 값 value로 구성되어 있음
- 함수도 프로퍼티 값으로 사용할 수 있음.
    - 프로퍼티 값이 함수일 경우, 일반 함수와 구분하기 위해 매서드(method)라 부른다.

## 10.2 객체 리터럴에 의한 객체 생성

- 사전에 정의하고 필요한 시점에 new 연산자와 함께 생성자를 호출하여 인스턴스를 생성하는 방식으로 객체 생성
- 클래스 기반 객체지향 언어와 달리 **다양한 객체지생성 방법 지원**
    - 객체 리터럴
    - Object 생성자 함수
    - 생성자 함수
    - Object.create  메서드
    - 클래스(ES6)
- 리터럴을 사용하는 방법 : 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용하여 값 생성하는 표기법
    - 객체 리터럴 : 중괄호 ({…}) 내에 0개 이상의 프로퍼티 정의

## 10.3 프로퍼티

**객체는 프로퍼티의 집합이며, 프로퍼티는 키와 값으로 구성된다**

## 10.4 메서드

- 프로퍼티 값이 함수일 경우, 일반 함수와 구분하기 위해 메서드라 부른다.
- **객체에 묶여 있는 함수**
- 매서드 내부에서 사용한 **this 키워드** : **객체 자신을 가리키는 참조변수**

## 10.5 프로퍼티 접근

두 가지 방법

1. **마침표 표기법** : 마침표 프로퍼티 접근 연산자(.)를 사용 (dot notation)
2. **대괄효 표기법** : 대괄호 프로퍼티 접근 연산자 ([…])를 사용 (bracket notation)

## 10.6 프로퍼티 값 갱신

이미 존재하는 프로퍼티에 값을 할당하면 프로퍼티 값이 **갱신**됨

- 프로퍼티 동적 생성 : 존재하지 않는 프로퍼티 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 프로퍼티 값이 할당 됨
- 프로퍼티 삭제 : delete 연산자는 객체의 프로퍼티를 삭제.

---

# CH11 원시 값과 객체의 비교

JS를 원시 타입과 객체 타입으로 구분하는 이유는 뭘까?

크게 세 가지 측면에서 다름

1. **원시 타입의 값은 변경 불가능한 값**이다. but 객체(참조)타입의 값, **객체는 변경 가능한 값임**
2. 원시 값을 변수에 할당하면 변수(확보된 메모리 공간)에는 실제 값 저장됨  but 객체를 변수에 할당하면? 변수(확보된 메모리 공간)에는 참조 값이 저장 됨
3. 원시 값을 갖는 변수를 다른 변수에 할당하면? 원시 값이 복사되어 전달됨 → **값에 의한 전달**
객체를 가리키는 변수를 다른 변수에 할당하면? 원본의 참조 값이 복사되어 전달 → **참조에 의한 전달**

(나중에 표로 정리해봐야 겠다!)

## 11.1 원시 값

- 변경 불가능한 값
- 읽기 전용(read only) 값, 변경할 수 없음
- 변경 불가능 한 것 : 값에 대한 진술 (O) 변수 (X)
- 데이터의 신뢰성을 보장해줌
- 불변성
- 재할당 외에 변수 값 변경할 수 있는 방법 없음

## 11.2 객체

- 프로퍼티의 개수가 정해져 있지 않음
- 동적으로 추가, 삭제 가능, 프로퍼티 값에 제약 없음
- 확보해야 할 메모리 공간 사전에 정해둘 필요 없음
- 복합적인 자료구조 : 객체 관리 방식 복잡, 브라우저마다 구현 방식 다름
- 변경 가능한 값
- 메모리 공간에 접근하면 참조 값에 접근할 수 있다.
- 참조 값 : 객체를 할당한 변수엔 생성된 객체가 실제로 저장된 메모리 공간의 주소가 저장됨
    - 이 참조값으로 객체에 접근
- 재할당 없이 객체를 직접 변경할 수 있다
    - 프로퍼티 값 갱신, 프로퍼티 자체 삭제 가능

---

# CH12 함수

## 12.1 함수란?