# 모던 자바스크립트 딥다이브 스터디 8회

## 질문

### 46장

- p.884, 비동기 콜백에서 발생한 에러를 처리할 수 없는 이유는 무엇인가? (김민정)
  - 비동기 함수의 콜백 함수를 호출한 것이 비동기 함수가 아니다!라는 부분이 이해가 되지 않습니다.

## 40장: 이벤트

### 40.1 이벤트 드리븐 프로그래밍

- 이벤트 핸들러: 이벤트가 발생했을 때 호출될 함수
- 이벤트 핸들러 등록: 브라우저에게 이벤트 핸들러의 호출을 위임
  - 사용자가 언제 함수를 사용하는지 알 수 없기에, 브라우저에게 위임함
- 이벤트 드리븐 프로그래밍: 프로그램 흐름을 이벤트 중심으로 제어하는 것

### 40.3 이트 핸들러 등록

- 이벤트 핸들러 어트리뷰트 방식
  - 함수 호출문 등의 문을 할당
  - 함수가 아닌 값을 반환하는 함수를 등록하면 브라우저가 이벤트 핸들로 호출 불가능
- 이벤트 핸들러 프로퍼티 방식
  - 이벤트 타깃 또는 전파된 이벤트를 캐치할 DOM 노드에 바인딩
- addEventListener 메서드 방식
  - 하나 이상 이벤트 핸들러 등록 가능

### 40.4 이벤트 핸들러 제거

- 이벤트 핸들러를 제거하려면 이벤트 핸들러의 참조를 변수나 자료구조에 저장해야 함
- 이벤트 핸들러로 등록할 수 없다면 함수 자신을 가리키는 arguments.callee 사용 가능
  - 단, strict mode 사용 금지

### 40.5 이벤트 객체

- 이벤트 핸들러 어트리뷰트 방식
  - event가 아닌 다른 이름으로는 이벤트 객체 전달받지 못함
  - 어트리뷰트는 파싱되어 함수를 암묵적으로 생성함
  ```jsx
  function onclick(event) {
    showCoords(event);
  }
  ```
- 이벤트 객체 공통 프로퍼티
  - target: 이벤트 발생 객체
  - currentTarget: 이벤트 바인딩 객체
- 마우스 정보 취득
  - clientX, clientY: 웹페이지의 가시 영역
  - translate3d: GPU를 사용해 top, left보다 빠름
- 키보드 정보 획득
  - keydown 이벤트 캐치가 더 좋음(keyup은 2번 호출됨)

### 40.6 이벤트 전파

- 이벤트 타깃을 중심으로 DOM 트리를 통해 전파
  - 캡처링: 이벤트 상위 → 하위
  - 타깃: 이벤트 타깃에 도달
  - 버블링: 이벤트 하위 → 상위
- 캡처링 단계 이벤트 캐치를 위해선 3번째 인수로 true를 전달해야 함

### 40.7 이벤트 위임

- 하나의 상위 DOM 요소에 이벤트 핸들러 등록함

### 40.8 DOM 요소의 기본 동작 조작

- e.preventDefault(): DOM 요소 기본 동작 조작
- e.stopPropagation(): 이벤트 전파 방지

### 40.9 이벤트 핸들러 내부 this

- 일반 함수: 이벤트 바인딩한 DOM 요소=currentTarget
- 화살표 함수 내부: 상위 스코프의 this
- class 내부: 클래스가 생성할 인스턴스

### 40.11 커스텀 이벤트

- 이베트 생성자 함수로 생성한 커스텀 이벤트: isTrusted 프로퍼티는 false임
- 등록: addEventListener
- 실행: dispatchEvent: 생성한 커스텀 이벤트 실행하는 부분
  - 동기 처리 방식으로 호출

## 41장: 타이머

### 41.1 호출 스케줄링

- 타이머 함수: setTimeout, setInterval
- 타이머 만료되면 콜백 함수 호출
  - setTimeout: 만료된 후 한 번만 호출
  - setInterval: 만료될 때마다 반복적 호출, 타이머 취소될 때까지 반복됨
- 자바스크립트는 싱글 스레드로 동작하며, 타이머 함수는 비동기 처리 방식으로 동작함

### 41.2 타이머 함수

- func
- delay
  - 즉시 호출되는 것이 보장되지 않음
  - delay시간은 태스크 큐에 콜백 함수를 등록하는 시간을 지연할 뿐임
- param,…

### 41.3 디바운스와 스로틀

- 짧은 시간 간격으로 연속해서 발생하는 이벤트는 이벤트 핸들러가 과하게 호출되어 성능 문제 발생함
- 고로 이벤트를 그룹화하여 과도한 이벤트 핸들로 호출을 방지함
- 디바운스
  - 짧은 시간 간격으로 발생하는 이벤트를 그룹화하여, 마지막 한 번만 이벤트 핸들러가 호출됨
  - 시간 전 이벤트 발생
    - delay 경과 이전에 이벤트 발생하면 이전 타이머 취소하고, 새로운 타이머 재설정
    - delay보다 짧은 간격으로 이벤트가 발생하면 callback 호출X
  - 시간 경과
    - delay동안 이벤트 더 발생 안하면 이벤트 핸들러 단 한 번만 호출됨
- 스로틀
  - 일정 시간 단위로 이벤트 핸들러가 호출되도록 호출 주기를 만듦
  - 시간 전 이벤트 발생
    - delay 경과 이전에 이벤트 발생하면 callback 호출X
  - 시간 경과
    - delay가 경과했을 때 이벤트 발생하면 새로운 타이머 재설정

## 42장: 비동기 프로그래밍

- 실행 컨텍스트 스택=콜 스택
- 자바스크립트는 단 하나의 실행 컨텍스트를 가짐
  - 동시에 2개 이상 함수 실행 불가능
  - 시간이 걸리는 태스크를 실행하면 블로킹(작업 중단)이 발생
  - 이러한 문제를 비동기 처리로 극복!
- 비동기 처리
  - 블로킹 발생하지 않음
  - 단, 태스크 실행 순서가 보장되지 않음
  - 전통적으로 콜백 패턴을 사용함

### 42.2 이벤트 루프와 태스크 큐

- 이벤트 루프: 자바스립트의 동시성 지원!
- 자바스크립트 엔진: 콜백함수 평가 및 실행
  - 콜 스택: 함수 실행 컨텍스트가 순차적으로 푸시되어 실행
  - 힙: 실행 컨텍스트는 힙에 저장된 구조 참조하며, 객체는 런타임에 메모리 공간 크기 결정이 필요해서 힙은 구조화되어 있지 않음
- 브라우저 엔진: 타이머 설정, 콜백 함수 등록
  - 태스크 큐: 이벤트 핸들러 보관되는 부분이며, 마이크로태스크 큐도 존재함
  - 이벤트 루프: 현재 실행 중 실행 컨텍스트 ↔ 태스크 튜 대기 중인 함수을 모니터링하며, 콜 스택이 비어있고 태스크 큐 대기 중 함수 있다면 태스크 큐 대기 중인 함수를 콜 스택으로 이동함
- 싱글 스레드 방식: 자바스크립트 엔진에 의해 동작
- 멀티 스레드 동작: 브라우저에 의해 동작!
  - 이것 덕분에 자바스크립트가 비동기로 동작할 수 있음

## 43장: Ajax

### 43.1 Ajax란?

- 브라우저가 서버에게 비동기 방식으로 데이터를 요청하고, 서버가 응답한 데이터를 수신하여 웹페이지를 동적으로 갱신하는 방식
- XMLHttpRequest 객체 기반으로 동작
- 전통적 방식
  - 완전한 HTML 받아 불필요한 데이터 통신 발생
  - 변경할 필요 없는 부분부터 다시 렌더링
  - 클라이언트 ↔ 서버 동기적 통신
- Ajax
  - 변경 필요한 부분만 갱신 받아 불필요한 데이터 통신X
  - 변경 필요 없는 부분 다시 렌더링X
  - 클라이언트 ↔ 서버 비동기적 통신

### 43.2 JSON

- 클라이언트 ↔ 서버 HTTP 통신을 위한 텍스트 데ㅣ터 포맷
- 표기 방식
  - 키, 값으로 구성된 순수한 텍스트
- 클라이언트 → 서버: 문자열로 전송, stringfy 사용
- 서버 → 클라이언트: 객체로 변환, parse

### 43.3 XMLHttpRequest

- 브라우저에서만 정상적 실행
- 이벤트 핸들러
  - onreadystatechange, onload, onerror
  - 이벤트를 캐치하여 HTTP 응답 처리
- readyStatechange VS load
  - readyState: XMLHttpRequest.DONE으로 완료됨 확인 필요
  - load: HTTP 성공적으로 완료된 경우 발생

## 44장: REST API

- 포인트
  - URI는 리소스 표현에 집중
  - HTTP 요청 메서드로 행위 정의
- 구성
  - 자원: URI endpoint
  - 행위: HTTP 요청 메서드
  - 표현: 페이로드(데이터)

## 45장: 프로미스

### 45.1 비동기 처리를 위한 콜백 패턴의 단점

- 비동기 함수 내부의 비동기로 동작하는 코드
  - 처리
    - 처리 결과를 외부로 반환하거나
    - 상위 스코프 변수에 할당하면
  - !!동작하지 않음!!
    - 콜백 함수에서 값을 반환하는 것은 무의미함
    - 콜백 함수의 반환은 함수의 반환이 아님
- 비동기 함수에 비동기 처리 결과에 대한 후속 처리를 콜백 함수에 선언
  - 해당 후속 처리를 가지고 또 다시 호출을 해야 하면 호출 중첩되어 복잡도 가 높아짐
  - 이것이 `콜백 헬`!
- 콜백 패턴의 문제점
  - 에러 처리 곤란함
  - 콜백 함수가 실행될 때 이미 함수의 실행은 완료되었음
  - 이 문제 프로미스가 해결!

### 45.2 프로미스의 생성

- ECMAScript에 정의된 표준 빌트인 객체이며, 비동기 처리 상태와 처리 결과를 관리하는 객체임!
- Promise 생성자 함수
  - 비동기 처리를 수행할 함수를 인수로 전달받음
  - 콜백 함수는 resolve, reject를 인수로 전달받음
- 비동기 처리
  - 성공: resolve 함수 호출해 프로미스를 fulfilled 상태로 변경
  - 실패: reject 함수 호출해 프로미스를 rejected 상태로 변경

### 45.3 프로미스의 후속 처리 메서드

- 비동기 처리 상태가 변화하면 후속 처리 메서드에 인수로 전달한 콜백 함수가 선택적으로 호출됨

```jsx
promiseGet()
	.then(res => ...)
	.catch(err => ...)
	.finally(()=>...)
```

### 45.4 프로미스의 에러 처리

- catch에서 하는 것을 권장함

```jsx
promiseGet()
	.then(res => ...)
	.catch(err => ...)
```

### 45.5 프로미스 체이닝

- then, catch, finally 후속 처리 메서드는 언제나 프로미스를 반환하여 연속적으로 호출 가능
- 콜백 패턴에서 발생하던 콜백 헬 발생하지 않음

### 45.6 프로미스의 정적 메서드

- all
  - 모든 프로미스가 fulfilled 상태가 되면 종료
  - resolve한 처리 결과부터 배열에 저장해 처리 순서 보장됨
  - 하나라도 reject가 되면 즉시 종료함
- race
  - 가장 먼저 fulfiled 상태가 된 프로미스 처리 결과를 resolve
  - 하나라도 reject가 되면 즉시 종료함
- allSettled
  - 모두 fulfilled 또는 rejected가 되면 결과를 배열로 반환

### 45.7 마이크로태스크 큐

- 프로미스 후속 처리 메서드의 콜백함수
  - 태스크 큐에 저장 X
  - 마이크로태스크 큐에 저장O
- 태스크 큐 VS 마이크로태스크 큐
  - 태스크 큐: 비동기 함수 콜백 함수, 이벤트 핸들러
  - 마이크로태스크큐: 프로미스의 후속 처리 메서드의 콜백 함수
  - 우선순위: 마이크로태스크 큐 > 태스크 큐

### 45.8 fetch

- 클라이언트 사이드 Web API
- HTTP 응답 나타내는 Response 객체를 래핑한 프로미스를 반환함
- 후속 처리 메서드 then을 통해 프로미스가 resolve한 Response 객체 전달받음
- Response.prototype에 HTTP 응답 몸체 존재
  - 몸체 취득하기 위해선 Response.prototype.json 사용
- fetch VS axios
  - fetch: HTTP 에러 발생해도 reject하지 않음, 네트워크 장애 또는 CORS 에러에만 reject
    - !response.ok 진행 필수
  - axios: 모든 HTTP 에러 reject

## 46장: 제너레이터와 async/await

### 46.1 제너레이터란?

- 제너레이터: 코드 블록 일시 중단했다가 필요한 시점에 재개하는 함수
- 특징
  - 함수 호출자에게 함수 실행 제어권 넘김
  - 함수 호출자와 함수가 양방향으로 상태 주고 받기 가능
  - 함수 호출하면 제너레이터 객체 반환

### 46.2 제너레이터 함수 정의

- function\*
- yield
- 단, 화살표 함수로 정의 불가능!
- new 연산자와 함께 생성자 함수로 사용 불가능!

### 46.3 제너레이터 객체

- Symbol.iterator 상속받는 이터러블
- next 메서드 소유하는 이터레이터
- 동작
  - next 호출하면 함수 yield 표현식까지 코드 실행, yield된 값 제너레이터 객체로 반환
  - return 호출하면 {value:인수, done:true} 이터레이터 리저트 객체 반환하며 종료!
  - throw 호출하면 {value:undefined, done:true} 반환하며 종료

### 46.4 제너레이터 일시 중지와 재개

- 일반 함수 VS 제너레이터 함수
  - 일반 함수: 코드 끝까지 실행
  - 제너레이터 함수: yield 표현식까지만 실행
- 과정
  - next 메서드 호출 > yield 표현식까지 실행되고 일시 중지 > 이터레이터 리절트 객체 반환
  - 호출자로 제어권 양도
- 제너레이터의 반환값은 의미가 없으며, return은 종료의 의미로만 사용
- 처음 호출하는 next에는 인수 전달하지 않음

### 46.6 async/await

- await
  - 프로미스가 settled 상태가 될 때가지 대기하다가 settled 상태가 되면 resolve한 결과 return
- 에러 처리
  - 에러는 호출자 방향으로 전파된다
  - 콜 스택의 아래 방향으로 푸시된다
  - 실행 컨텍스트가 푸시되기 직전에 푸시된 실행 컨텍스트 방향으로 전파된다
  - 비동기 함수
    - 하지만 비동기 함수의 콜백을 호출한 것은 비동기 함수가 아니기에 try-catch로 에러 캐치할 수 없다
  - async/await
    - try-catch로 에러 처리 가능하다
    - 호출자가 명확하다
    - async 내에서 catch로 에러를 잡지 않는다면, 후속 처리 메서드 사용해 에러 캐치도 가다
