# 모던 자바스크립트 딥다이브 스터디 4회

## 목차

- 20: strict mode
- 21: 빌트인 객체
- 22: this
- 23: 실행 컨텍스트
- 24: 클로저

## 20장: strict mode

### 20.1 strict mode란?

- strict mode를 사용하지 않았을 때 발생하는 문제
  - 암묵적 전역
- strict mode를 추가하는 경우
  - 문제 일으킬 수 있는 코드에 대해 명시적 에러 발생
- strict mode 대체
  - ESLint와 같은 린트 도구
  - 정적 분석 기능을 활용

### 20.3 전역에 strict mode를 적용하는 것은 피하자

- 이유
  - 외부 서드파티 라이브러리가 non-strict mode일 수 있음
- 방법
  1. 즉시 실행 함수로 스크립트 전체를 감싸기
  2. 스코프 구분하기
  3. 즉시 실행 함수 선두에 strict mode 적용하기

### 20.6 strict mode 적용에 의한 변화

- 일반 함수 this
  - undefined가 바인딩
- 생성자 함수 this
  - 생성자 함수가 바인딩
- arguments 객체
  - 매개변수에 전달된 인수를 내부에서 재할당해도 반영X

## 21장: 빌트인 객체

### 21.1 자바스크립트 객체 분류

- 표준 빌트인 객체
  - ECMAScript 사양에 정의된 객체
- 호스트 객체
  - 자바스크립트 실행 환경(브라우저, Node.js)에서 추가로 제공하는 객체
  - 브라우저: Web API
  - Node.js: Node.js 고유의 API
- 사용자 정의 객체

### 21.2 표준 빌트인 객체

- 표준 빌트인 객체
  - 인스턴스 생성할 수 있는 생성자 함수 객체(Math, Reflect, JSON 제외)
  - 인스턴스에 프로토타입 메서드 제공
  - 인스턴스 없이 호출 가능한 정적 메서드 제공
- 과정
  1. 표준 빌트인 객체 String을 생성자 함수로 호출
  2. String 인스턴스 생성
     1. String 인스턴스의 프로토타입===String.prototype

### 21.3 원시값과 래퍼 객체

- 원시값이 있는데 표준 빌트인 생성자 함수 존재하는 이유
  - 원시값: 객체가 아니기에, 프로퍼티+메서드 사용 불가능
  - 원시값을 객체처럼 작동하게 하기 위해 존재!
- 원시값 객체처럼 작동하게 하는 방법
  - 자바스크립트 엔진이 일시적으로 원시값을 연관된 객체로 변환
  - 프로퍼티에 접근하거나 메서드를 호출하고 다시 원시값으로 되돌림
- 래퍼 객체
  - 원시값을 객체처럼 접근하면 생성되는 임시 객체
- 과정
  1. 문자열 마침표 표기법 접근
  2. 래퍼 객체인 String 생성자 함수 인스턴스 생성
  3. 문자열 래퍼 객체의 [[StringData]] 내부 슬롯에 할당
  4. 래퍼 객체 처리 종료
  5. 래퍼 객체의 [[StringData]] 내부 슬롯에 할당된 원시값으로 원래의 값 되돌림
     1. 이때, 3-4번 사이에 추가로 생성한 속성이 있어도 래퍼 객체에 저장이 되나 해당 객체가 종료되기에 값도 사라지게 됨
     2. 원시값을 출력하면 추가한 속성은 존재하지 않음!
  6. 래퍼 객체 가비지 컬렉션 대상이 됨

### 21.4 전역 객체

- 전역 객체
  - 브라우저: window
  - Node.js: global
  - 프로퍼티
    - 표준 빌트인 객체
    - 호스트 객체
    - 전역 변수, 전역 함수
- 전역 객체: 주의점
  - 상속
    - 프로토타입 상속 관계에서 최상위X
    - 프로퍼티로 소유O
  - var
    - 전역 객체 프로퍼티O
  - let, const
    - 전역 객체 프로퍼티X
    - 보이지 않는 개념적 블록 내에 존재
  - 여러 script
    - 하나의 window 공유
- 빌트인 전역 프로퍼티
  - 전역 객체의 프로퍼티
- 빌트인 전역 함수
  - 전역 객체의 메서드
  - eval
    - ⚠️ 사용을 금지하는 것이 좋음
    - 표현식 여부
      - 표현식: 문자열 코드 런타임에 평가 > 값 생성
      - 표현식X: 무자열 코드 런타임에 실행
    - 여러개로 구성되면 마지막 결과값 반환
    - strict mode 여부
      - strict mode X: 호출된 함수 스코프에서 실행
      - strict mode O: 자신의 자체적 스코프 생성
    - let, const
      - 암묵적 strict mode 실행, 자체적 스코프 생성
  - isFinite
    - 정상적인 유한수인지 검사
      - 무한수, NaN: false return
      - null: 0으로 반환해 true return
  - isNaN
    - new Date(): number
    - new Date().toString(): NaN
  - parseFloat
    - 공백으로 구분된 문자열은 첫 번째 문자열만 변환
    - 공백으로 구분된 문자열은 첫 번째 문자열이 숫자로 변환하지 못하면: NaN return
  - parseInt
    - parseInt(A, B)
      - A: B에 해당하는 인수의 형태라고 생각하고, 10진수로 변경
      - B: 해당하는 인수
    - parseInt(A.toString(B), B)
      - A.toString(B): A를 B의 형태로 바꾼 후, 10진수로 변경, A return!
      - B: 해당하는 인수
- encodeURI, decodeURI
  - URL: 아스키 문자 set으로만 구성되어야 하기에, 이스케이프 처리 필요
- encodeURIComponent, decodeURIComponent
  - encodeURI
    - 매개변수로 전달된 문자열: 완전한 URI 전체
    - =?& 인코딩X
  - encodeURIComponent
    - 매개변수로 전달된 문자열: URI 구성 요소인 쿼리 스트링의 일부
    - =?& 인코딩O
- 암묵적 전역
  - 선언하지 않은 식별자에 값을 할당하면 전역 객체의 프로퍼티가 됨
  - 단, 전역 객체의 프로퍼티이지 변수가 아니기에 변수 호이스팅 발생X
  - 전역 변수 VS 암묵적 전역
    - 전역 변수: delete로 삭제 불가능
    - 프로퍼티: delete로 삭제 가능

## 23장: 실행 컨텍스트

### 23.1 소스코드의 타입

> 코드 > 스코프 생성 > 평가 > 컨텍스트 생성

- 전역 코드
  - 전역 스코프 생성
  - 전역 코드가 평가되면 전역 실행 컨텍스트 생성
- 함수 코드
  - 지역 스코프 생성
  - 함수 코드가 평가되면 함수 실행 컨텍스트 생성
- eval 코드
  - 자신만의 독자적 스코프 생성
  - eval 실행 컨텍스트 생성
- 모듈 코드
  - 모듈별로 독자적인 모듈 스코프 생성
  - 모듈 실행 컨텍스트 생성

### 23.2 소스코드의 평가와 실행

- 자바스크립트 엔진 처리 과정
  - 소스코드 평가
    - 실행 컨텍스트 생성
    - 함수 선언문 실행
    - 생성된 변수나 함수 식별자를 키로 실행 컨텍스트가 관리하는 스코프에 등록
  - 소스코드 실행
    - 변수나 함수에 대한 참조를 실행 컨텍스트가 관리하는 스코프에서 취득
    - 소스코드 실행 결과 실행 컨텍스트가 관리하는 스코프에 등록

### 23.3 실행 컨텍스트의 역할

- 코드 실행을 위해선 스코프, 식별자, 코드 실행 순서 관리 필요
  - 스코프: 스코프 체인 형성
  - 식별자: 식별자 지속적 관리
  - 코드 실행 순서: 변경 가능하도록 설정
- 위의 모든 것을 관리하는 것이 `실행 컨텍스트`

### 23.4 실행 컨텍스트 스택

- 실행 컨텍스트는 스택 자료구조로 관리됨
- 과정
  1. 전역 코드 평가 및 실행
     - 전역 변수, 함수: 전역 실행 컨텍스트에 등록
  2. 함수 코드 평가 및 실행
     - 지역 변수, 중첩 함수: 함수 실행 컨텍스트에 등록
  3. 중첩 함수 코드 평가 및 실행
     - 지역 변수: 중첩 함수 실행 컨텍스트에 등록
  4. 함수로 복귀
  5. 전역 코드로 복귀

### 23.5 렉시컬 환경

- 렉시컬 환경
  - 스코프의 식별자를 관리
  - 키-값 가지는 객체 형태의 스코프 생성 > 식별자로 키 등록, 식별자에 바인딩된 값 관리
  - 구성
    - 환경 레코드
      - 식별자 등록
      - 식별자에 바인딩된 값 관리
    - 외부 렉시컬 환경에 대한 참조
      - 상위 스코프 가리킴
      - 단방향 링크드 리스트인 스코프 체인 구현

### 23.6 실행 컨텍스트의 생성과 식별자 검색 과정

- 전역 코드 평가
  1. 전역 실행 컨텍스트 생성
  2. 전역 렉시컬 환경 생성
     1. 전역 환경 레코드 생성
        1. 객체 환경 레코드=BindingObject(전역 객체): var
        2. 선언적 환경 레코드: let, const
     2. this 바인딩
     3. 외부 렉시컬 환경에 대한 참조 결정
- 전역 코드 실행
  - 실행 중인 실행 컨텍스트에서 어떤 스코프의 식별자를 참조하면 되는 것인지 결정하는 과정을 시작
- 함수 코드 평가
  1. 함수 실행 컨텍스트 생성
  2. 함수 렉시컬 환경 생성
  3. this 바인딩
     1. 함수 환경 레코드 [[ThisValue]]에 this 바인딩
     2. this는 함수 호출 방식에 의해 결정
     3. 외부 렉시컬 환경에 대한 참조 결정
        1. 함수의 상위 스코프를 함수 객체 내부 슬롯[[Environment]]에 저장

### 23.7 실행 컨텍스트와 블록 레벨 스코프

- 함수 레벨 스코프: var 키워드
- 블록 레벨 스코프: let, const 키워드, 모든 코드 블록
  - 블록 실행이 종료되면 이전 렉시컬 환경으로 되돌리게 됨

## 24장

### 24.1 렉시컬 스코프

- 렉시컬 스코프
  - 함수를 어디에 정의했는지에 따라 결정되는 상위 스코프
  - 실행 컨텍스트의 환경

### 24.2 함수 객체의 내부 슬롯[[Environment]]

- 함수 객체 내부 슬롯 [[Environment]]에 상위 스코프의 참조 저장
- 함수 객체를 생성하는 시점은 정의된 환경이기에, 상위 함수가 평가 또는 실행이 되는 중임
- 이때, 실행 컨텍스트는 상위 함수의 컨텍스틑임

### 24.3 클로저와 렉시컬 환경

- 클로저
  - 외부 함수보다 중첩 함수가 더 오래 유지되어, 생명 주기가 종료한 외부 함수의 변수를 참조할 수 있음
  - 이때의 중첩 함수를 클로저라고 함!
  - 조건
    - 중첩 함수가 상위 스코프의 식별자(자유 변수) 참조(
    - 중첩 함수가 외부 함수보다 더 오래 유지
- 클로저 인정되지 않는 경우
  - 중첩 함수가 외부 함수보다 더 오래 유지되지만, 상위 스코프의 어떤 식별자도 참조하지 않는 경우
  - 이때 상위 스코프를 기억하지 않음!
- 클로저 과정
  ```jsx
  function outer() {
    const x = 10;
    const inner = function () {
      console.log(x);
    };
    return inner;
  }
  const innerFun = outer();
  innerFun();
  ```
  1. outer 호출
  2. inner return & outer 종료
  3. innerFunc에서 inner 활용
  4. inner 종료
     즉, 중첩 함수인 inner가 outer보다 더 오래 생존

### 24.4 클로저의 활용

- 상태 안전하게 변경, 유지
  - 정보 은닉
  - 특정 상태에게만 상태 변경 허용
- 예시
  - 함수 공유되지 않음
    ```jsx
    function makeCounter(aux) {
      let counter = 0;
      return function () {
        counter = aux(counter);
        return counter;
      };
    }
    function increase(n) {
      return n++;
    }
    function decrease(n) {
      return n--;
    }
    const increaser = makeCounter(increase);
    console.log(increaser());
    const decreaser = makeCounter(decrease);
    console.log(decreaser());
    ```
  - 함수 공유됨
    ```jsx
    const counter = (function () {
      let counter = 0;
      return function () {
        counter = aux(counter);
        return counter;
      };
    })();
    function increase(n) {
      return n++;
    }
    function decrease(n) {
      return n--;
    }
    console.log(counter(increase));
    console.log(counter(decrease));
    ```

### 24.5 캡슐화와 정보 은닉

- 캡슐화
  - 객체 상태를 나타내는 프로퍼티와 메서드를 하나로 묶는 것
  - 이는 프로퍼티나 메서드를 감출 목적으로 사용될 때 정보 은닉을 진행함
- 메서드 중복 생성
- 메서드 중복 생성 방지
  - 단, 메서드가 즉시 실행 함수의 실행 컨텍스트의 렉시컬 환경을 저장하여, 하나의 동일한 상위 스코프를 사용해 연동되는 문제 존재
  - 즉, 완벽한 정보 은닉 지원하지는 않음

### 24.6 자주 발생하는 실수

- for문 반복 실행
  - i가 증가할 때마다 새로운 렉시컬 환경이 생성됨
