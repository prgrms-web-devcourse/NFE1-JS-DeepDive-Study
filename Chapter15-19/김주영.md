# CH15 **let, const 키워드와 블록 레벨 스코프**

## 15.1 var 키워드로 선언한 변수의 문제점

- ES5까지는 var 모두 키워드를 사용
- var 키워드 특징 3가지

### 1. 변수 중복 선언 허용

- 변수를 중복 선언하면 초기화문 유무에 따라 다르게 동작
- 부작용 : 이미 선언되었는지 모르고 중복 선언, 값 할당하면 변수값 의도치 않게 변경되는 문제 발생

### 2. 함수 레벨 스코프

- var 키워드로 선언한 변수는 오로지 **함수의 코드 블록만을 지역 스코프로 인정**
- 함수 회부에서 var 키워드로 선언한 변수는 **코드 블록 내에서 선언해도 모두 전역변수가 됨**
    - for문의 변수 선언문에서 var 키워드로 선언한 변수도 →  전역 변수
    - 함수 레벨 스코프 → 전역변수 남발 가능성 UP, 의도치 않게 전역 변수 중복 선언되는 경우 발생

### 3. 변수 호이스팅

- 변수 호이스팅에 의해 var 키워드로 선언한 변수 → 변수 선언문 이전에 참조할 수 있음
    - 할당문 이전에 변수 참조 → 언제나 undefind 반환 (하지막 가독성 떨아짐)

## 15.2 let 키워드

### 1. 변수 중복 선언 금지

- 이름 같은 변수 중복 선언 ➡️ syntaxError 발생

### 2. 블록 레벨 스코프

- let 키워드로 선언한 변수 ➡️ **블록 레벨 스코프**(모든 코드 블록을 지역 스코프로 인정)

### 3. 변수 호이스팅

### 15.2.4 전역 객체와 let

## 15.3 const 키워드

### 15.3.1 선언과 초기화

### 15.3.2 재할당 금지

### 15.3.3 상수

### 15.3.4 const 키워드와 객체

## 15.4 var vs. let vs. const

---

# CH16 **프로퍼티 어트리뷰트**

## 16.1 내부 슬롯과 내부 메서드

## 16.2 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체

## 16.3 데이터 프로퍼티와 접근자 프로퍼티

### 16.3.1 데이터 프로퍼티

### 16.3.2 접근자 프로퍼티

## 16.4 프로퍼티 정의

## 16.5 객체 변경 방지

### 16.5.1 객체 확장 금지

### 16.5.2 객체 밀봉

### 16.5.3 객체 동결

### 16.5.4 불변 객체

---

# CH17 **생성자 함수에 의한 객체 생성**

## 17.1 Object 생성자 함수

## 17.2 생성자 함수

### 17.2.1 객체 리터럴에 의한 객체 생성 방식의 문제점

### 17.2.2 생성자 함수에 의한 객체 생성 방식의 장점

### 17.2.3 생성자 함수의 인스턴스 생성 과정

### 17.2.4 내부 메서드 [[Call]]과 [[Construct]]

### 17.2.5 constructor와 non-constructor의 구분

### 17.2.6 new 연산자

### 17.2.7 new.target

---

# CH18 **함수와 일급 객체**

## 18.1 일급 객체

## 18.2 함수 객체의 프로퍼티

### 18.2.1 arguments 프로퍼티

### 18.2.2 caller 프로퍼티

### 18.2.3 length 프로퍼티

### 18.2.4 name 프로퍼티

### 18.2.5 **proto** 접근자 프로퍼티

### 18.2.6 prototype 프로퍼티

---

# CH19 **프로토타입**

## 19.1 객체지향 프로그래밍

## 19.2 상속과 프로토타입

## 19.3 프로토타입 객체

### 19.3.1 **proto** 접근자 프로퍼티

### 19.3.2 함수 객체의 prototype 프로퍼티

### 19.3.3 프로토타입의 constructor 프로퍼티와 생성자 함수

## 19.4 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입

## 19.5 프로토타입의 생성 시점

### 19.5.1 사용자 정의 생성자 함수와 프로토타입 생성 시점

### 19.5.2 빌트인 생성자 함수와 프로토타입 생성 시점

## 19.6 객체 생성 방식과 프로토타입의 결정

### 19.6.1 객체 리터럴에 의해 생성된 객체의 프로토타입

### 19.6.2 Object 생성자 함수에 의해 생성된 객체의 프로토타입

### 19.6.3 생성자 함수에 의해 생성된 객체의 프로토타입

## 19.7 프로토타입 체인

## 19.8 오버라이딩과 프로퍼티 섀도잉

## 19.9 프로토타입의 교체

### 19.9.1 생성자 함수에 의한 프로토타입의 교체

### 19.9.2 인스턴스에 의한 프로토타입의 교체

## 19.10 instanceof 연산자

## 19.11 직접 상속

### 19.11.1 Object.create에 의한 직접 상속

### 19.11.2 객체 리터럴 내부에서 __proto__에 의한 직접 상속

## 19.12 정적 프로퍼티/메서드

## 19.13 프로퍼티 존재 확인

## 19.14 프로퍼티 열거

### 19.14.1 for...in 문

### 19.14.2 Object.keys/values/entries 메서드