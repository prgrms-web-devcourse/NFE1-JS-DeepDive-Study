# 모던 자바스크립트 딥다이브 스터디 5회

## 목차

- 25: 클래스
- 26: ES6 함수의 추가 기능
- 27: 배열

## 질문

### 25장

- 정적 메서드를 사용하는 이유와 실제 사례는 무엇이 있는가?

## Chapter25: 클래스

### 25.1 클래스는 프로토타입의 문법적 설탕인가?

- 프로토타입 기반 객체 지향 언어
  - 클래스가 필요 없는 객체지향 프로그래밍 언어
  - 생성자 함수, 클래스는 프로토타입 기반의 객체 지향 언어를 구현한 것임
  - 고로 클래스는 단순 문법적 설탕보단, 새로운 객체 생성 메커니즘임

### 25.2 클래스 정의

- 메서드
  - constructor
  - 프로토타입 메서드
  - 정적 메서드

### 25.3 클래스 호이스팅

- 클래스 호이스팅 일어남
  - 모든 선언문은 런타임 이전에 실행
  - 선언문 이전: 일시적 사각지대 발생

### 25.5 메서드

- constructor
  - 인스턴스 생성, 초기화
  - 메서드로 해석X, 함수 객체 코드의 일부가 됨
  - 즉, constructor의 기술된 동작을 하는 함수 객체가 생성됨
  - 암묵적으로 this(인스턴스)를 반환
    - 명시적 객체 반환: this 반환 무시
    - 명시적 원시값 반환: 암묵적 this 반환
- 정적 메서드
  - 인스턴스를 호출하지 않아도 호출할 수 있는 메서드
  - 인스턴스 프로토타입 체인 상에 클래스가 존재하지 않아, 인스턴스로 호출 불가능
- 정적 메서드 VS 프로토타입 메서드
  - 자신이 속한 프로토타입 체인이 다름
  - 호출
    - 정적 메서드: 클래스로 호출
    - 프로토타입 메서드: 인스턴스로 호출
  - this
    - 정적 메서드: 클래스
    - 프로토타입 메서드: 인스턴스

### 25.6 클래스 인스턴스 생성 과정

1. 인스턴스 생성, this 바인딩
   - 인스턴스 프로토타입: 클래스 prototype 프로퍼티가 가리키는 객체
   - 인스턴스 this에 바인딩
2. 인스턴스 초기화
3. 인스턴스 반환
   - 인스턴스가 바인딩된 this가 암묵적으로 반환

### 25.7 프로퍼티

- 접근자 프로퍼티
  - 접근자 함수로 구성된 프로퍼티
- this
  - 클래스의 constructor와 메서드 내에서만 유효함
- private
  - 선두에 #를 붙이기
    ```jsx
    #name;
    ```
  - private 필드를 직접 constructor에 정의하면 에러 발생함

### 25.8 상속에 의한 클래스 확장

- 클래스
  - 수퍼 클래스=부모 클래스
    - 내부 슬롯[[ConstructorKind]]: base
  - 서브 클래스=자식 클래스
    - 내부 슬롯[[ConstructorKind]]: derived
- 서브 클래스
  - constructor 암묵적으로 정의
  - super()는 수퍼클래스의 constructor를 호출하여, 인스턴스 생성
    ```jsx
    constructor(...args){super(...args);}
    ```
- 상속 클래스 인스턴스 생성 과정
  1. 서브클래스 super 호출
     - 내부 슬롯[[ConstructorKind]]이 derived인 것 확인
     - 자신이 직접 인스턴스 생성하지 않고, 수퍼클래스에게 인스턴스 생성 위임
  2. 수퍼클래스의 인스턴스 생성과 this 바인딩
     - new.target은 서브클래스를 가리킴
  3. 수퍼클래스의 인스턴스 초기화
  4. 서브클래스 constructor로의 복귀와 this 바인딩
     - super 호출 종료 > 제어 흐름이 서브 클래스 constructor로 돌아옴
     - super가 반환한 인스턴스가 this에 바인딩
  5. 서브클래스의 인스턴스 초기화
  6. 인스턴스 반환
- extends에 모든 표현식 사용 가능
  - Array 가능
  - 이를 통해 메서드 체이닝 가능
  - 서브클래스가 아닌 Array 인스턴스 반환을 희망한다면 정적 접근자 프로퍼티 추가하면 됨

## Chapter26: ES6 함수의 추가 기능

### 26.1 함수의 구분

- ES6 이전: 함수 사용 목적에 따라 명확히 구분되지 않음
- ES6 이후
  - 일반 함수: constructor
  - 메서드: non-constructor
  - 화살표 함수: non-constructor

### 26.2 메서드

- 메서드 축약 표현으로 정의된 함수
  - 올바른 예시
    ```jsx
    const obj = {
      foo() {},
    };
    ```
  - 올바르지 않은 예시: 일반 함수
    ```jsx
    const obj = {
      foo: function () {},
    };
    ```
- 자신을 바인딩한 객체를 가리키는 내부 슬롯[[HomeObject]]를 가짐
  - 해당 내부 슬롯에 의해 메서드만 super 가질 수 있음

### 26.3 화살표 함수

- 콜백 함수 내부에서 this가 전역 객체를 가리키는 문제 해결
- 함수 몸체 정의
  - 중괄호 생략시 표현식 아닌 문 반환 불가능
  - 객체 리터럴 반환시 소괄호로 감싸주기 필요
- this
  - 고차 함수 내부 콜백 함수를 일반 함수로 호출
  - 일반 함수로 호출되는 경우, this는 전역 객체임
  - 해당 문제 해결하는 방법
    - this 회피: that 사용
    - 화살표 함수 사용
  - 화살표 함수는 함수 자체의 this 바인딩을 갖지 않아, 상위 스코프의 this를 그대로 참조함
- 메서드
  - 메서드를 화살표 함수로 정의하는 것은 피해야 함
- 프로퍼티 동적 추가
  - 프로퍼티를 화살표 함수로 정의하는 것은 피해야 함
  - 일반 함수 할당을 해야 함
  - 만일 메서드로 추가하고 싶다면, 연결 재설정 필요
    ```jsx
    Person.prototype = {
      constructor: Person,
      sayHi() {},
    };
    ```
- 클래스
  - constructor 내부 this: 클래스가 생성한 인스턴스
  - 화살표 내부 함수 this: 클래스가 생성한 인스턴스
  - 클래스 필드 화살표 함수: 프로토타입 메서드X, 인스턴스 메서드O

### 26.4 Rest 파라미터

- 매개변수 개수 나타내는 함수 객체의 length 프로퍼티에 영향X
- arguments 객체
  - 유사배열 객체임
  - 배열처럼 사용 가능하도록 Rest 파라미터 활용함

### 26.5 매개변수 기본값

- 기본값 활용
  - 인수 체크, 초기화 간소화 가능
  - 매개변수 전달하지 않은 경우, undefined 전달한 경우에만 유효함
- Rest 파라미터
  - 기본값 지정 불가능

## Chapter27: 배열

### 27.1 배열이란?

- 배열
  - 객체 타입
- 생성자 함수
  - Array
- 프로토타입 객체
  - Array.prototype
- 일반 객체 VS 배열
  - 일반 객체: 값의 순서 X, length 프로퍼티 X
  - 배열: 값의 순서 O, length 프로퍼티 O

### 27.2 자바스크립트 배열은 배열이 아니다

- 밀집 배열
  - 서로 연속적으로 인접
  - 요소에 빠르게 접근
  - 요소 삽입, 삭제 효율적X
- 희소 배열
  - 서로 연속적 이어짐X
  - length는 실제 요소 개수보다 언제나 큼
  - 요소에 느리게 접근
  - 요소 삽입, 삭제 효율적O
- 자바스크립트 배열
  - 밀집 배열X
  - 희소 배열O
    - 각각 메모리 공간 동일한 크기 가짐X
    - 연속적 이어짐X
  - 배열의 요소: 프로퍼티값

### 27.3 length 프로퍼티와 희소 배열

- length 프로퍼티
  - 자동 갱신
  - 임의의 숫자값 명시적 할당 가능
    - 현재 length보다 작으면 배열이 잘림
    - 현재 length보다 크면 empty가 할당

### 27.4 배열 생성

- Array 생성자 함수
  - 초기화 없다면 empty 할당
  - 전달된 인수가 범위를 벗어나면 RangeError 발생
  - 일반 함수로 호출해도 생성자 함수로 동작
- Array.of
  - 전달된 인수를 요소로 갖는 배열 생성
- Array.from
  - 유사 배열 객체, 이터러블 객체 > 베열로 변환

### 27.6 배열 요소의 추가와 갱신

- 프로퍼티는 배열 length에 영향을 미치지 않음
  ```jsx
  const arr = [];
  arr[0] = 1;
  arr.bar = 4;
  arr.foo = 2;
  console.log(arr.length); //1, bar과 foo는 반영X
  ```

### 27.8 배열 메서드

- 배열 요소 존재 확인
  - indexOf
  - includes
    - (value, start)
      - value: 확인할 값
      - start: 검색 시작하는 인덱스
- 배열 요소 추가
  - push
    - length 프로퍼티 사용해, 배열 마지막 요소 직접 추가 가능
    - ⚠️ 스프레드 문법 사용하면, push 없이 사용 가능
  - unshift
    - 원본 배열 앞에 요소로 추가
    - ⚠️ 스프레드 문법 사용하면, unshift 없이 사용 가능
- 배열 요소 연결
  - concat
    - 인수로 전달된 값을 원본 배열의 마지막 요소로 추가하고, 해당 새로운 배열 반환
    - 원본 배열 변경X
  - join
    - 구분자로 배열 연결
- 배열 요소 뒤집기
  - reverse
    - 원본 배열 변경O
- 배열 요소 채우기
  - fill
    - 원본 배열 변경O
    - (value, start, end)
      - value: 채울 값
      - start: 시작하는 인덱스
      - end: 끝나는 인덱스
- 배열 요소 뽑아내기
  - splice
    - 원본 배열 변경O
    - (start, deleteCount, items)
      - start: 시작하는 인덱스
      - deleteCount: 뽑아낼 요소의 개수
      - items: 뽑아낸 자리에 추가할 요소
  - slice
    - 원본 배열 변경X
    - (start, end)
      - start: 시작하는 인덱스
      - end: 끝나는 인덱스
    - 뽑아낸 요소는 얕은 복사로 생성됨
- 배열 평탄화
  - flat
- 유사 배열 객체 > 배열로 변환
  - slice.call()
  - Array.from()
  - Spread 연산자

### 27.9 배열 고차 함수

- 고차 함수
  - 함수를 인수로 전달받거나, 함수를 반환하는 함수
  - 불변성 지향
  - 순수 함수를 통해 부수 효과 최대한 억제
- 배열 요소 확인
  - find
    - 배열이 아닌 요소 반환
  - findIndex
- 배열 정렬
  - sort
    - 숫자 요소 정렬할 때, 비교 함수 인수로 전달
    - 객체 요소 정렬할 때, 비교 함수 인수로 전달
      ```jsx
      function compare(key) {
        return (a, b) => (a[key] > b[key] ? 1 : a[key] < b[key] ? -1 : 0);
      }
      ```
- 배열 순회
  - forEach
    - for은 함수형 프로그래밍이 추구하는 방향과 맞지 않음
    - 수행해야 할 처리를 콜백 함수로 받아 반복 호출
    - 원본 배열 변경X
      - 단, 콜백 함수로 원본 배열 변경 가능
        ```jsx
        numbers.forEach((item, index, arr) => {
          arr[index] = item ** 2;
        });
        ```
    - (요소값, 인덱스, forEach 메서드를 호출한 배열(this))
    - 반환값
      - undefined
    - 콜백 함수 내부 this
      - 일반 함수: undefined
      - 화살표 함수: 메서드 내부 this 참조
    - 원리
      - 내부에선 for을 통해 배열을 순회함
      - 단, 반복문을 메서드 내부로 은닉해 복잡성 해결
      - for에 비해 성능은 안좋아도 가독성 좋음
  - map
    - 수행해야 할 처리를 콜백 함수로 받아 반복 호출하고, 콜백 함수 반환값들로 구성된 배열 반환
    - 원본 배열 변경X
    - 반환값
      - 콜백 함수 반환값들로 구성된 배열 반환
- 배열 변경
  - filter
    - 콜백 함수의 반환값이 true인 요소로만 구성된 배열 반환
    - 원본 배열 변경X
  - reduce
    - 원본 배열 변경X
    - (콜백 함수, 초기값, 인덱스, 전체 배열)
    - 하나의 결과값을 반환
    - 요소 중복 횟수 구하기
      ```jsx
      const count = fruits.reduce((acc, curr) => {
        acc[curr] = (acc[curr] || 0) + 1;
        return acc;
      }, {});
      ```
    - 중복 요소 제거
      - reduce
      - filter
      - Set
    - 초기값 전달하는 것이 안함
- 배열 평탄화
  - flatMap
    - flat과 다르게, 1단계만 평탄화 가능
