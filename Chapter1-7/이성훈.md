## Node.js

1. 자바스크립트 엔진을 브라우저에서 독립시킨 자바스크립트 실행 환경
2. 서버 사이드 애플리케이션에 주로 사용

## 자바스크립트의 특징

1. 인터프리터 언어이다

# 4장 변수

# 변수

메모리 공간에서 값의 위치를 가리키는 상징적인 이름이다.

하나의 값을 저장하기 위해 확보한 `메모리 공간 자체` 또는 그 메모리 공간을 식별하기 위해 붙인 `이름`을 말한다.

흔히 변수가 변수 이름을 의미하는 경우가 많으며, 변수 이름을 `식별자`라고도 한다.

변수에 값을 저장하는 것을 `할당`이라 하고, 변수에 저장된 값을 읽어 들이는 것을 `참조`라고 한다.

모든 식별자는 실행 컨텍스트에 `객체 형태`로 등록되어 관리된다.

# 런타임

소스코드가 한 줄씩 순차적으로 실행되는 시점이다.

# 호이스팅(hoisting)

변수 선언은 런타임 이전에 실행된다.

자바스크립트 엔진은 런타임 이전에 소스코드의 평가 과정을 거치면서 소스코드가 실행되기 위한 준비를 한다. 이 과정에서 모든 선언문을 소스코드에서 찾아내 먼저 실행하는데, 이를 호이스팅이라 한다. 소스코드의 평가 과정이 끝나고 나면 변수 선언을 포함한 모든 선언문을 제외하고 소스코드를 한 줄씩 순차적으로 실행한다.

> 모든 선언문을 제외한다고 되어 있는데, var x = 0 같은 경우는 선언문 var x와 할당문 x = 0의 단축 형태이므로, 할당문 x = 0만 남게 되는 것 같은데, 이게 맞는 지가 의문이다.

# 호이스팅 예제

```jsx
console.log(a); // undefined. Reference error가 아님에 유의.
a = 10;
var a; // 변수 선언
console.log(a); // 10
```

# var

변수의 선언과 초기화가 동시에 진행되며, 해당 변수를 undefined로 초기화한다.

주의할 점은 var의 관점에서는 초기화와 할당을 구분해야 한다는 것이다. 할당은 할당문이 따로 있어 런타임에 실행되지만, 초기화는 선언과 동시에 일어나므로 런타임 이전에 일어난다.

# let

선언과 초기화가 따로 진행된다. 초기화도 할당과 마찬가지로 런타임에 발생하므로, 초기화를 `최초의 할당`으로 이해해도 괜찮다. 선언과 초기화 사이에 TDZ(Temporal Dead Zone, 임시 사각 지대)가 존재하여, TDZ에서 해당 변수 참조 시 ReferenceError가 발생한다.

```jsx
console.log(a); // ReferenceError: Cannot access 'a' before initialization
let a;
```

참고로, 위 코드에서 선언문을 없애면 `ReferenceError: a is not defined` 로 에러 내용이 다르다.

# var과 let의 또다른 차이점

var 키워드로 선언한 전역 변수와 전역 함수, 그리고 선언하지 않은 변수에 값을 할당한 암묵적 전역은 전역 객체 window의 프로퍼티가 된다. 전역 객체의 프로퍼티를 참조할 때 window를 생략할 수 있다. let 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다.

# 예제

```jsx
var x = 1; // 전역 변수
y = 2; // 암묵적 전역
function foo() {} // 전역 함수
console.log(window.x);
console.log(x);
console.log(window.y);
console.log(y);
console.log(window.foo);
console.log(foo);
```

!https://velog.velcdn.com/images/codee/post/f1c1dc6e-23a3-46c0-b6ff-c5500e7e079d/image.png

# const

const 키워드는 let 키워드와 거의 동일하게 동작한다.

하지만 `선언과 동시에 초기화` 해야 하며 `값의 재할당이 금지`된다는 차이가 있다.

# 변수의 재할당

변수에 값을 재할당하면 새로운 메모리 공간을 확보하고 그 메모리 공간에 값을 저장한다.

즉, 주솟값이 바뀌며 재할당 이전의 값은 메모리에서 `가비지 콜렉터`에 의해 자동 해제된다.

# 5장 표현식과 문

# 리터럴

리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법을 말한다. 사람이 이해할 수 있는 문자 또는 미리 약속된 기호로 표기한 코드다. 자바스크립트 엔진은 코드가 실행되는 시점인 런타임에 리터럴을 평가해 값을 생성한다.

즉, 리터럴은 값을 생성하기 위해 미리 약속한 표기법이라고 할 수 있다.

## 객체 리터럴

객체 리터럴은 객체를 생성화기 위한 표기법으로 중괄호({}) 내에 `0개 이상`의 프로퍼티를 정의한다. 객체 리터럴 외의 객체 생성 방식은 모두 함수를 사용해야 한다.

## 문

프로그램을 구성하는 기본 단위이자 최소 실행 단위이다.

변수에 할당이 가능한 문은 표현식인 문, 불가능한 문은 표현식이 아닌 문이다.

## 토큰

문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소

토큰이 모여 문이 된다. ex) 키워드, 식별자, 연산자, 리터럴, 세미콜론, 마침표 등

# 표현식

표현식은 값으로 평가될 수 있는 문이다.

값으로 평가될 수 있는 문은 모두 표현식이다.

# 6장 데이터 타입

# 데이터 타입 7가지

1. number - NaN, Infinity, -Infinity
2. string -
   1. 템플릿 리터럴 `` -> 줄바꿈이 허용된다
   2. 이스케이프 시퀀스 - \n, \b, \t, \', \" 등
3. boolean - !!로 boolean 타입으로 변환
4. undefined
5. null
   1. 변수에 값이 없다는 것을 의도적으로 명시할 때 사용
   2. 이전에 참조하던 값을 더 이상 참조하지 않겠다는 의미
   3. document.querySelector 메서드는 조건에 부합하는 HTML 요소를 검색할 수 없는 경우 null을 반환함
6. symbol
   1. 다른 값과 중복되지 않는 유일무이한 값
   2. 객체의 유일한 프로퍼티 키를 만들기 위해 사용
   3. 원시값이지만 유일하게 리터럴을 통해 생성할 수 없으며, Symbol 함수를 호출해 생성
   4. 생성된 심벌 값은 외부에 노출되지 않는다.
7. object

# 7장 연산자

1. 이항 산술 연산자(+,-,\*,/,%)
   1. 부수 효과가 없다
2. NaN

   1. 자신과 일치하지 않는 유일한 값

   ```jsx
   NaN === NaN; // false
   ```

   1. Number.isNaN

3. 쉼표 연산자

   1. 쉼표 연산자는 왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 `마지막 피연산자의 평가 결과를 반환`한다.

   ```jsx
   var x, y, z;
   (x = 1), (y = 2), (z = 3); // 3
   ```

4. 연산자 우선순위
   1. 연산자는 종류가 많아서 연산자 우선순위를 모두 기억하기 어렵고 실수하기도 쉽다.
      따라서 기억에 의존하기보다는 연산자 우선순위가 가장 높은 그룹 연산자를 사용하여 우선순위를 명시적으로 조절하는 것을 권장한다.
