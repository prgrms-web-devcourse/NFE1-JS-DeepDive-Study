## 1주차 질문

변수에 값을 할당할 때는 이전 값 undefined가 저장된 메모리 공간을 지우고 그 공간에 할당 값을 새롭게 저장하는 것이 아니라 새로운 메모리 공간을 확보하고 그곳에 할당 값을 저장한다. <- 이유는? (CH04)

자바스크립트가 동적타입언어를 사용하는 이유는? (CH06)

---

# CH 01 프로그래밍

---

### 프로그래밍이란?

프로그래밍 : **컴퓨터와의 커뮤니케이션** | **기계가 알아들을 수 있도록 정확하고 상세한 요구사항 설명**

- 컴퓨팅 사고와 문제해결능력이 요구 됨

### 프로그래밍 언어

프로그래밍 언어 : 사람의 명령을 컴퓨터가 이해할 수 있는 언어(기계어)로 전환하기 위한 표현 수단으로, 모두가 이해할 수 있는 약속된 형태의 인공어

- 컴파일러(또는 인터프리터) : 프로그래밍 언어를 컴퓨터가 이해할 수 있는 기계어로 변환하는 일종의 변역기

### 구문과 의미

프로그래밍을 잘하기 위해서는 구문과 의미를 지켜 문제해결을 할 수 있는 코드를 작성해야 한다.

# CH 02 자바스크립트란?

---

#### 자바스크립트

1995년 웹페이지의 보조적인 기능을 수행하기 위해 브라우저에서 동작하는 경량 프로그래밍 언어로 개발 -> 현재 모든 브라우저의 표준 프로그래밍 언어로 자리잡음

> 초창기 자바스크립트는 서버로부터 전달받은 HTML과 CSS를 단순히 렌더링 하는, 웹페이지의 보조적인 기능을 수행하는 한정적인 언어였음.

#### Ajax

자바스크립트를 이용한 서버와 브라우저의 비동기적 데이터 교환 통신 기능

Ajax의 등장으로 화면 전환 시 전체 HTML코드를 받아 렌더링하는 방식에서 변경할 필요가 없는 부분은 제외하고 필요한 부분만 렝더링하는 방식으로 변경됨. -> 빠른 성능과 부드러운 화면 전환 가능

#### Node.js

구글 V8 자바스크립트 엔진으로 빌드 된 자바스크립트 런타임 환경

- 자바스크립트 엔진을 브라우저에서 독립시킴
- 서버사이드 애플리케이션 개발에 주로 사용
- 비동기 I/O 지원 및 단일 스레드 이벤트 루프 기반으로 동작 -> SPA에 적합

#### ECMAScript

자바스크립트 표준 사양으로 프로그래밍 언어의 값, 타입, 객체와 프로퍼티, 함수, 표준 빌트인 객체 등 핵심 문법 규정

**자바스크립트 특징**

- 웹 브라우저에서 동작하는 유일한 프로그래밍 언어
- 개발자가 별도의 컴파일 작업을 수행하지 않는 인터프리터 언어
- 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어

# CH 03 자바스크립트 개발 환경과 실행 방법

---

#### 실행환경

- **브라우저** : HTML, CSS, JavaScript를 실행해 웹페이지를 브라우저 화면에 렌더링하는 것이 주 목적
- **Node.js** : 브라우저 외부에서 JavaScript를 실행하는 것이 주 목적

**웹 크롤링** : 서버에서 웹사이트의 콘텐츠를 수집하기 위해 웹사이트에서 HTML 문서를 가져온 다음, 가공해서 필요한 데이터만 추출하는 것

#### 실행방법

- 브라우저의 단축키로 개발자 도구의 콘솔창 사용
- VS Code등의 코드 에디터에 Node.js 설치 후 사용 or Live Server 확장 플러그인 사용

# CH 04 변수

---

#### 변수

하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름 (값을 담는 공간)

> 변수는 프로그래밍 언어에서 값을 저장하고 참조하는 메커니즘으로, 값의 위치를 가리키는 상징적인 이름이다.

**메모리** : 데이터를 저장할 수 있는 메모리 셀의 집합체 / 1바이트 단위로 데이터를 저장하거나 읽어들인다.

#### 변수 이름(식별자)

메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름

#### 변수 값

변수에 저장된 값

#### 변수 선언

변수를 생성하는 것으로, 값을 저장하기 위한 메모리 공간을 확보하고, 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수 있게 준비하는 것

#### 변수를 사용하기 위해서는 반드시 선언이 필요하다.

**var, let, const 키워드를 사용하여 선언**

#### var || let, const

**var의 단점** : 블록 레벨 스코프를 지원하지 않고 함수 레벨 스코프 지원 -> 의도치 않은 전역 변수 선언 문제

```js
var score; // 변수 선언 (변수 선언문)
```

위의 변수 선언문은 변수 이름(score)을 등록하고 값을 저장할 메모리 공간을 확보함 / 확보된 메모리 값에는 undefined 할당

#### undefined

자바스크립트에서 제공하는 원시 타입의 값

#### 변수 선언 단계 (선언과 초기화 단계 동시 실행)

- **선언 단계** : 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알림
- **초기화 단계** : 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화 한다.

#### 선언하지 않은 식별자에 접근 시 참조에러 (ReferenceError)발생

> 변수 이름을 포함한 모든 식별자는 **실행 컨텍스트** 에 등록된다. <br> > **실행 컨텍스트** 는 자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다

#### 변수 선언의 실행 시점

변수 선언이 소스 코드의 어디에 있든 관계없이 다른 코드보다 먼저 실행한다. (_변수 호이스팅_)

- #### 모든 선언문은 런타임 이전 단계에서 먼저 실행

```js
console.log(score); //undefined
var score; // 변수 선언
```

변수에 값을 할당할 때는 할당 연산자 =를 사용 / 우변의 값을 좌변에 할당

#### 값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임 시 실행

변수에 값을 할당할 때는 이전 값 undefined가 저장된 메모리 공간을 지우고 그 공간에 할당 값을 새롭게 저장하는 것이 아니라 새로운 메모리 공간을 확보하고 그곳에 할당 값을 저장한다.

#### 재할당

변수에 저장된 값을 다른 값으로 변경 <br>
값을 재할당 할 수 없다면 변수가 아닌 상수(한 번 정해지면 변하지 않는 값)임

#### const

const 키워드를 사용해 선언한 변수는 재할당이 금지된다. -> 상수 표현 가능

#### 가비지 콜렉터

애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더이상 사용되지 않는 메모리를 해제하는 기능 -> 메모리 누수 방지

#### 언매니지드 언어와 매니지드 언어

- **언매니지드 언어** : 개발자가 명시적으로 메모리를 할당하고 해제 ex) C언어의 malloc(), free() 함수
- **매니지드 언어** : 메모리 할당 및 해제를 위한 메모리 관리 기능을 언어 차원에서 담당 ex) 가비지 콜렉터

#### 식별자 네이밍 규칙

- 식별자는 특수문자를 제외한 문자,숫자,언더스코어(\_), 달러기호($)를 포함할 수 있다
- 단, 식별자는 특수문자를 제외한 문자, 언더스코어(\_), 달러 기호($)로 시작해야 한다. 숫자로 시작하는 것은 허용하지 않는다.
- 예약어는 식별자로 사용 불가
- 변수 여러개를 한 번에 선언할 수 있으나 가독성이 나빠지므로 권장하지 않는다.
- 대소문자를 구별한다
- 변수의 의미를 명확히 표현해야 한다.

#### 네이밍 컨벤션

- **카멜케이스** ex) firstName; //변수나 함수
- **스네이크 케이스** ex) first_name;
- **파스칼 케이스** ex) FirstName; // 생성자 함수, 클래스
- **헝가리언 케이스** ex) strFirstName; $elem; observable$;

# CH 05 표현식과 문

---

#### 값

식이 평가되어 생성된 결과 / 변수에 할당되는 값

```javascript
// 10 + 20은 평가되어 숫자 값 30을 생성한다
10 + 20; // 30
```

#### 모든 값은 데이터 타입을 가지며, 메모리에 2진수, 즉 비트의 나열로 저장된다.

```javascript
// 변수에는 10 + 20이 평가되어 생성된 숫자 값 30이 할당된다.
var sum = 10 + 20;
```

#### 리터럴

사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법

<p align = "center">
<img src = "./literal.png" width="500" height="300">

#### 표현식

값으로 평가될 수 있는 문 / 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다.

표현식은 리터럴, 식별자, 연산자, 함수 호출 등의 조합으로 이뤄질 수 있다. <br>

값으로 평가될 수 있는 값 = 표현식

#### 문

프로그램을 구성하는 기본 단위이자 최소 실행 단위

문의 집합 = 프로그래밍

#### 토큰

문을 이루는 구성 단위 / 문법적인 의미를 가지며 더이상 나눌 수 없는 코드의 기본 요소

#### 표현식과 문을 구별하는 방법

- 표현식인 문 : 값으로 평가될 수 있는 문 ex) 할당문
- 표현식이 아닌 문 : 값으로 평가될 수 없는 문 ex) 변수 선언문

**변수에 값을 할당해 보는 것**

#### 완료값

크롬 개발자에서 표현식이 아닌 문을 실행하면 항상 undefined 출력 <br>
표현식의 평가 결과가 아니므로 다른 값과 같이 변수에 할당할 수 없고 참조할 수도 없다.

# CH 06 데이터 타입

---

#### 데이터 타입 = 값의 종류 : 원시타입 | 객체타입

<p align = "center">
<img src="./datatype.png" width = "500" height = "200">

#### 숫자 타입

자바스크립트에서는 모든 수를 실수로 처리하며 정수만 표현하기 위한 데이터 타입이 별도로 존재하지 않음

정수, 실수, 2진수, 8진수, 16진수 리터럴은 모두 메모리에 배정밀도 64비트 부동소수점 형식의 2진수로 저장된다.

모든 수를 실수로 처리하기 때문에 정수로 표시되는 수끼리 나누더라도 실수가 나올 수 있다.

**숫자 타입이 표현 가능한 세 가지 특별한 값**

- Infinity : 양의 무한대
- -Infinity : 음의 무한대
- NaN : 산술 연산 불가 (not a number)

#### 문자열 타입

텍스트 데이터를 나타내는 데 사용되는 0개 이상의 16비트 유니코드 문자의 집합

문자열은 작은 따옴표, 큰따옴표 또는 백틱으로 텍스트를 감싼다.

```javascript
// 문자열 타입
var string;
string = '문자열'; // 작은 따옴표
string = '문자열'; // 큰 따옴표
string = `문자열`; // 백틱(ES6)

string = '작은따옴표로 감싼 문자열 내의 "큰따옴표"는 문자열로 인식한다';
string = "큰따옴표로 감싼 문자열 내의 '작은따옴표'는 문자열로 인식한다";
```

만약 따옴표로 문자를 감싸지 않는다면 스페이스와 같은 공백 문자도 포함시킬 수 없다.

#### 템플릿 리터럴

멀티라인 문자열, 표현식 삽입, 태그드 템플릿 등 편리한 문자열 처리기능을 제공 / 백틱을 사용해 표현

#### 멀티라인 문자열

일반 문자열 내에서 줄바꿈 등의 공백을 표현하려면 백슬래시(\\) 로 시작하는 이스케이프 시퀀스를 사용해야 함

<p align="center">
<img src="./escape.png" width="400" height="300">

**일반 문자열과 달리 템플릿 리터럴 내에서는 이스케이프 시퀀스를 사요하지 않고도 줄바꿈과 공백 적용**

**피연산자 중 하나 이상이 문자열인 경우 +연산자를 사용해 문자열을 연결할 수 있다**

```javascript
var first = 'Ung-mo';
var last = 'Lee';

// ES6: 표현식 삽입
console.log(`My name is ${first} ${last}`); // My name is Ung-mo Lee.
```

#### 불리언 타입

논리적 참 거짓을 나타내는 true와 false 값

#### undefined

변수가 선언되면 값이 할당되기 전까지 undefined로 초기화 된다.

#### null

변수에 값이 없다는 것을 의도적으로 명시할 때 사용한다. <br>
변수가 이전에 참조하던 값을 더 이상 참조하지 않겠다는 의미하며 함수가 유효한 값을 반환할 수 없는 경우 명시적으로 null을 반환하기도 한다.

#### 심벌 타입

ES6에서 추가된 타입으로, 변경 불가능한 원시 타입의 값이다. 다른 값과 중복되지 않는 유일무이한 값이다. <br>

주로 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용한다.

#### 데이터 타입의 필요성

- 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해
- 값을 참조할 때 한 번에 읽어 들어야 할 메모리 공간의 크기를 결정하기 위해
- 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해

#### 동적 타입 언어와 정적 타입 언어

- **정적 타입 언어** : 변수를 선언할 때 데이터 타입을 사전에 선언(명시적 타입 선언)

  - 변수의 타입을 변경할 수 없으며 변수에 선언한 타입에 맞는 값만 할당할 수 있다.
  - 컴파일 시점에 타입체크를 수행한다

- **동적 타입 언어** : 변수 선언 시 타입을 선언하지 않고 자유롭게 어떤 데이터 값을 할당할 수 있다.

  - 할당에 의해 타입이 결정
  - 재할당에 의해 언제든지 타입이 변할 수 있다.

> 변수는 타입을 갖지 않는다. 하지만 값은 타입을 가진다. 따라서 현재 변수에 할당되어 있는 값에 의해 변수의 타입이 동적으로 결정된다.

#### 동적 타입 언어의 단점

- 변수 값이 언제든 변경될 수 있기 때문에 변화하는 변수 값을 추적하기 어려울 수 있다.
- 값을 확인하기 전에는 타입을 확신할 수 없다.
- 유연성은 높지만 신뢰성은 떨어진다.

#### 변수 사용 시 주의사항

- 변수는 꼭 필요한 경우에 제한적으로 사용한다.
- 변수의 유효범위(스코프)는 최대한 좁게 만들어 변수의 부작용을 억제해야 한다.
- 전역변수는 최대한 사용을 줄인다,
- 변수보다는 상수를 사용해 값의 변경을 억제한다.
- 변수 이름은 변수의 목적이나 의미를 파악할 수 있도록 네이밍한다.

# CH 07 연산자

#### 연산자

연산자는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행하여 하나의 값을 만든다. <br>

이때 연산의 대상을 **피연산자** 라고 한다.

#### 산술 연산자 : 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만든다. <br>

산술 연산이 불가능한 경우 NaN을 반환한다.

- 이항 산술 연산자 : 2개의 피연산자를 산술 연산하여 숫자 값을 만든다.

<p align="center">
<img src="./operator.png">

- 단항 산술 연산자 : 1개의 피연산자를 산술 연산하여 숫자 값을 만든다.

<p align="center">
<img src="./single-op.png">

#### 증감 연산자 : 피연산자의 값을 변경하는 부수효과가 있다.

- 피연산자 앞에 위치한 전위 증가/감소 연산자는 먼저 피연산자의 값을 증가/감소 시킨 후, 다른 연산을 수행한다.
- 피연산자 뒤에 위치한 후위 증가/감소 연산자는 먼저 다른 연산을 수행한 후, 피연산자의 값을 증가/감소 시킨다.

#### 문자열 연결 연산자 : 피연산자 중 하나 이상이 문자열인 경우 문자열을 연결한다.

#### 할당 연산자 : 우항에 잇는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다. (부수 효과 O)

<p align="center">
<img src="./operator2.png">

#### 비교 연산자

좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값으로 반환한다.

#### 동등/일치 비교 연산자

좌항과 우항의 피연산자가 같은 값으로 평가되는 지 비교해 불리언 값을 반환한다.

<p align="center">
<img src="./comp-op.png" width="400">

**동등 비교 연산자는 좌항과 우항의 피연산자를 비교할 때 먼저 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값인지 비교한다.**

**일치 비교 연산자는 좌항과 우항의 피연산자가 타입도 같고 값도 같은 경우에 한하여 true를 반환한다.**

#### NaN

자신과 일치하지 않는 유일한 값 (Number.isNaN) 함수 사용

#### Object is

예측 가능한 정확한 비교 결과 반환

```javascript
-0 === +0; // -> true
Object.is(-0, +0); // -> false

NaN === NaN; // -> false
Object.is(NaN, NaN); // -> true
```

#### 대소 관계 비교 연산자

피연산자의 크기를 비교하여 불리언 값을 반환한다.

<p align="center">
<img src="./op3.jpeg">

#### 삼항 조건 연산자

조건식의 평과 결과에 따라 반환할 값을 결정한다. (부수효과 x)

**조건식 ? 조건식이 true일 때 반환할 값 : 조건식이 false일 때 반환할 값**

**삼항 조건 연산자 표현식은 값으로 평가할 수 있는 표현식인 문이다.**

#### 논리 연산자

우항과 좌항의 피연산자를 논리 연산한다.

<p align="center">
<img src="./op4.png">

#### 쉼표 연산자

왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환한다.

#### 그룹 연산자

- 자신의 피연산자인 표현식을 가장 먼저 평가한다. <br>
  따라서 그룹 연산자를 사용하면 연산자의 우선순위를 조절할 수 있다.

#### typeof 연산자

피연산자의 데이터 타입을 문자열로 반환한다. <br>
7가지 문자열 "string", "number", "boolean", "undefined", "symbol", "object", "function" 중 하나를 반환한다. 함수의 경우 "function"을 반환한다.

\*\*타입이 null 타입인지 확인할 때는 typeof 연산자 대신 일치연산자 사용

#### 지수 연산자 (ES7 도입)

좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭 제곱하여 숫자 값 반환

음수를 거듭제곱의 밑으로 사용해 계산하려면 괄호로 묶어야 함

다른 산술 연산자와 마찬가지로 할당 연산자와 함께 사용할 수 있다.

> 지수 연산자는 이항 연산자 중에서 우선순위가 가장 높다.

#### 부수 효과가 있는 연산자

할당 연산자(=), 증가.감소 연산자(++/--) delete 연산자

#### 연산자 우선순위

<p align="center">
<img src="./op5.png">

#### 연산자 결합 순서

<p align="center">
<img src="./op6.png">
