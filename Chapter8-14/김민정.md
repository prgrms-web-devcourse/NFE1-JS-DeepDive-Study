# 모던 자바스크립트 딥다이브 스터디 2회

## 분량

- 8장: 제어문
- 9장: 타입 변환과 단축 평가
- 10장: 객체 리터럴
- 11장: 원시 값과 객체 비교
- 12장: 함수
- 13장: 스코프
- 14장: 전역 변수의 문제점

# 질문

### 8장

- 132 page, person.last-name을 출력할 때 자바스크립트 엔진이 평가하는 과정은 어떻게 구성되는가?

### 11장

- 150 page, 얕은 복사를 진행했을 때 c1과 o의 === 비교 결과가 false인 이유가 이해되지 않는다.
  - 원시값 === 비교하는 과정
  - 객체 === 비교하는 과정
  - 위의 과정에 대한 이해를 다시 해야 한다.
  ***
  - 원시값은 원시값만을 비교하면 되기에, 실제 값이 일치하는지를 보면 된다.
  - 객체는 참조값을 비교하면 되기에, 참조한 주소가 동일한지를 보면 된다?
    - 객체 내부 1차원 프로퍼티는 원시값이기에 원시값 비교 방식을 선택하면 된다?

### 13장

- 멀티 패러다임 언어란 무엇인가?

# 정리

## 8장: 제어문

### 8.2 조건문

- 폴스루: break문을 생략하며, 여러 개의 case문을 하나의 조건으로 사용 가능
  ```jsx
  switch (day) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      result = "평일";
      break;
    case 6:
    case 7:
      result = "주말";
      break;
    default:
      console.log("END");
  }
  ```

### 8.4 break문

- 레이블문: 식별자가 붙은 문이며, 외부 for문을 탈출할 때 유용함
  ```jsx
  outer: for (let i = 0; i < 2; i++) {
    for (let j = 0; j < 3; j++) {
      if (i + j === 3) break outer;
    }
  }
  ```

## 9장: 타입 변환과 단축 평가

### 9.1 타입 변환이란?

- 명시적 타입 변환, 타입 캐스팅: 개발자가 의도적으로 값의 타입 변환
- 암묵적 타입 변환, 타입 강제 변환: 자바스크립트 엔진에 의해 암묵적으로 값의 타입 변환

### 9.2 암묵적 타입 변환

- 문자열 타입으로 변환
  ```jsx
  Symbol() + ""; //TypeError
  ```
- 숫자 타입으로 변환
  - 산술 연산자의 피연산자를 숫자 타입으로 변환
  ```jsx
  +null + //0
    undefined + //NaN
    Symbol(); //TypeError
  ```
- 불리언 타입으로 변환
  - !: true > false, false > true로 변경
  - !!: true면 true, false면 false 확인
  ```jsx
  !false; //true
  !!false; //false
  ```

### 9.3 명시적 타입 변환

- 표준 빌트인 생성자 함수 사용
  - String
  - Number
  - Boolean
- 빌트인 메서드 사용
  - toString
  - parseInt, parseFloat
- 암묵적 타입 변환 활용
  - - “”
  - -
  - !!

### 9.4 단축 평가

- 논리합(||) 또는 논리곱(&&) 연산자 표현식은 2개의 피연산자 중 하나로 평가됨
  ```jsx
  "cat" || "dog"; //"cat"
  "cat" && "dog"; //"dog"
  ```
- 활용
  - 변수 초기화
  - 함수 매개변수로 기본값 설정
- null 병합 연산자(??)
  ```jsx
  var value = elem?.value;
  ```
  - 반환
    - 좌항: 좌항이 null 또는 undefined인 경우
    - 우항: 좌항이 null 또는 undefined가 아닌 경우
  - || 연산자의 상위 버전
    - ||: 좌항이 Falsy한 경우, 우항을 반환
    - ??: 좌항이 Falsy함과 상관없음
- 옵셔널 체이닝 연산자(?.)
  ```jsx
  var value = "" ?? "default string";
  ```
  - 반환
    - undefined: 좌항이 null 또는 undefined인 경우
    - 우항: 좌항이 null 또는 undefine가 아닌 경우
  - && 연산자의 상위 버전
    - &&: 좌항이 Falsy한 경우, 좌항을 반환
    - ?.: 좌항이 Falsy함과 상관 없음

## 10장: 객체 리터럴

### 10.1 객체란?

- 원시값: 변경 불가능한 값
- 객체: 변경 가능한 값
  - 프로퍼티: 객체 상태값
  - 메서드: 객체 안에 있는 함수

### 10.2 객체 리터럴에 의한 객체 생성

- 클래스 기반 객체지향 언어
  1. 클래스(템플릿) 정의
  2. 생성자 호출로 인스턴스(실존) 생성
- 프로토타입 기반 객체지향 언어
  - 객체 리터럴로 생성
  - Object 생성자 함수로 생성
  - 생성자 함수로 생성
  - Object.create 메서드로 생성
  - 클래스로 생성

### 10.3 프로퍼티

- 프로퍼티 키
  - 문자열 또는 심벌 값 이외의 값은 암묵적 타입 변환에 의해 문자열이 됨
  - 식별자 네이밍 규칙 준수
    - 따옴표 선택
    ```jsx
    var person = {
      firstName: "kim",
    };
    ```
  - 식별자 네이밍 규칙 준수X
    - 따옴표 필수
    ```jsx
    var person = {
      "first-name": "kim",
    };
    ```

### 10.5 프로퍼티 접근

- 마침표
  - 프로퍼티 키 따옴표로 감싸기 필요X
    ```jsx
    person.firstName;
    ```
- 대괄호
  - 프로퍼티 키 따옴표로 감싸기 필요O
  ```jsx
  person["first-name"];
  ```
- 단, 객체 존재하지 않는 프로퍼티 접근하면 undefined 반환

### 10.9 ES6에서 추가된 객체 리터럴의 확장 기능

- 프로퍼티 축약 표현

  - 프로퍼티 값으로 변수를 사용할 때, 변수 이름과 프로퍼티 키가 동일하면 프로퍼티 키 생략 가능

  ```jsx
  var obj = {
    x: x,
    y: y,
  };

  var obj2 = { x, y };
  ```

- 메서드 축약 표현

  ```jsx
  var obj = {
    sayHi: function () {},
  };

  var obj2 = {
    sayHi() {},
  };
  ```

## 11장: 원시 값과 객체의 비교

- 변수에 할당
  - 원시값: 변수에 실제 값 저장
  - 객체: 변수에 참조값 저장
- 다른 변수에 할당
  - 원시값: 원본의 원시 값 복사되어 전달, pass by value 방식
  - 객체: 원본의 참조 값 복사되어 전달, pass by reference 방식

### 11.1 원시값

### 11.1.1 변경 불가능한 값

- 변경 불가능하다는 것은 변수가 아닌 값에 대한 진술!
- 불변성
  - 원시 값은 변경 불가능한 값이기에, 직접 변경 불가능
  - 재할당할 때, 새로운 메모리 공간 참조
  - 즉, 재할당 이외에 변수 값 변경하는 방법 없음
  - 만약, 원시 값 변경이 가능하다면 불변성 충족하지 못하고 상태 변경 추적 어려워짐

### 11.1.2 문자열과 불변성

- 원시값
  - 원시 타입별로 메모리 공간 크기 미리 정해져 있음
  - 문자열 타입: 1개 문자 2바이트
    - 문자의 개수에 \*2바이트를 진행함
  - 숫자 타입: 8바이트
- 문자열
  - 원시 값이나, 유사 배열 객체+이터러블임
  - 유사 배열 객체이기에 배열처럼 인덱스 사용해 각 문자 접근 가능
  - 단, 원시 값이기에 변경 불가능

### 11.1.3 값에 의한 전달

- 다른 메모리 공간에 저장됨
- 동일한 숫자 값 가짐

### 11.2 객체

- 객체
  - 확보할 메모리 공간 크기 미리 정할 수 없음
  - 해시 테이블과 유사
- 자바스크립트 객체 관리 방식
  - 클래스 기반: 사전 정의된 클래스 기반으로 객체 생성, 프로퍼티 추가-삭제 불가능
  - 자바스크립트: 객체 생성 이후, 프로퍼티 추가-삭제 가능
  - 단, 자바스크립트 방식이 객체 생성 및 프로퍼티 접근에 비용이 많이 드는 비효율적 방식
  - 고로, V8 자바스크립트 엔진에선 히든 클래스 방식을 통해 고정된 객체 레이아웃처럼 동작
- 원시 값 VS 객체
  - 원시 값
    - 적은 메모리 소비
    - 원시 값 자체를 값으로 가짐
    - 값을 변경하려면 재할당만 가능
  - 객체
    - 많은 메모리 소비
    - 참조 값을 값으로 가짐
    - 값을 변경하려면 재할당 없이 메모리에 저장된 객체를 직접 수정해 변경 가능

### 11.2.1 변경 가능한 값

- 객체에서 재할당 방식 사용하지 않는 이유
  - 재할당 방식을 사용하면 명확하고 신뢰성 보장O
  - 단, 객체는 크기 크고 일정하지 않고 프로퍼티 값이 객체일 수 있어 복사 비용이 많이 들게 됨
  - 즉, 재할당 방식을 사용하면 메모리 효율적 소비가 어렵고 성능이 나빠짐
  - 고로, 메모리 효율적 사용, 객체 복사 생성 비용 절약, 성능 향상을 위해 재할당하지 않음
- 객체에서 메모리 직접 수정하면 얻는 단점
  - 여러 식별자가 하나의 객체를 공유함
- 얕은 복사 VS 깊은 복사

### 11.2.2 참조에 의한 전달

- 다른 메모리 공간에 저장됨
- 동일한 참조 값 가짐
- 두 개의 식별자가 하나의 객체를 공유함
- === 일치 비교 연산자
  - 원시 값 할당 한 변수 비교: 원시 값 비교
  - 객체 할당한 변수 비교: 참조 값 비교

## 12장: 함수

### 12.1 함수란?

- 매개변수=parameter
- 인수=argument

### 12.4 함수 정의

- 함수 정의 방식
  - 함수 선언문
  - 함수 표현식=함수 리터럴 활용
  - Function 생성자 함수
  - 화살표 함수
- 함수 선언문 VS 함수 리터럴 표현식: 호출법
  - 함수 선언문
    - 함수와 동일한 이름 식별자를 암묵적으로 생성하여, 함수 객체 할당
    - 함수 몸체 외부: 함수 식별자로 호출 가능
    - 이때, 함수 이름이 아닌 식별자로 호출함에 유의!
  - 함수 리터럴 표현식
    - 함수 몸체 외부: 함수 이름으로 호출 불가능
- 함수 선언문 VS 함수 리터럴 표현식: 생성 시점
  - 함수 선언문
    - 함수 호이스팅으로 인하여, 런타임 이전에 생성
  - 함수 리터럴 표현식
    - 변수 호이스팅으로 인하여, 할당문이 실행되는 시점에 평가되어 생성
- 화살표 함수
  - 생성자 함수로 사용 불가능
  - 기존 함수와 this 바인딩 방식 다름
  - prototype 프로퍼티 없음
  - atruments 객체 생성하지 않음

### 12.5 함수 호출

- 과정
  1. 함수 몸체 내 매개변수 생성
  2. 함수 몸체 내 매개변수 undefined 초기화
  3. 인수 순서대로 할당
     이때, 초과된 인수는 arguments 객체 프로퍼티에 보관됨
- 매개변수 기본값
  - 매개변수에 인자를 전달하지 않은 경우
  - undefined를 전달한 경우
    위의 두 경우에서만 유효함

### 12.7 다양한 함수의 형태

- 즉시 실행 함수
  - 다시 호출 불가능
- 콜백 함수
  - 고차 함수: 자신 내부에 매개변수로 받은 함수를 실행하도록 하는 함수
  - 콜백 함수: 고차함수에 의해 호출되어 실행되는 함수
    즉, 콜백 함수는 함수 외부에서 고차 함수 내부로 주입하기에 자유롭게 교체 가능!
- 순수 함수 VS 비순수 함수
  - 순수 함수: 인수의 불변성 유지
  - 비순수 함수: 외부 상태에 의존하거나 외부 상태를 변경
    - 외부 상태 변경하면 상태 변화 추적 어려움
      즉, 함수 형 프로그래밍은 순수 함수를 통해 최대한 부수 효과를 억제해 프로그램 안전성 높임

## 13장: 스코프

### 13.1 스코프란?

- 참조할 변수 결정하는 방법
  - 스코프를 통해 식별자를 결정함
  - 이때, 스코프는 식별자 검색에 사용되는 규칙임
- 코드 환경
  - 코드 문맥
  - 렉시컬 환경
  - 실행 컨텍스트
- 하나의 스코프 내에선 식별자 유일해야 함

### 13.2 스코프의 종류

- 지역 변수
  - 자신의 지역 스코프에서 유효
  - 하위 스코프에서 유효

### 13.3 스코프 체인

- 스코프 체인
  - 스코프는 중첩될 수 있음
  - 중첩에 의해 계층적으로 연결된 구조를 가짐
  - 참조하는 코드의 스코프에서 시작 > 상위 스코프 방향으로 이동
- 렉시컬 환경
  - 스코프 체인과 유사한 자료구조를 실제로 생성
  - 전역 렉시컬 환경
    - 코드 로드되면 바로 생성
  - 함수 렉시컬 환경
    - 함수 호출되면 바로 생성

### 13.4 함수 레벨 스코프

- 함수 레벨 스코프
  - var 키워드
  - 함수의 코드 블록만을 지역 스코프로 인정
- 블록 레벨 스코프
  - const, let 키워드
  - 함수의 몸체+모든 코드 블록(if문 등)을 지역 스코프로 인정

### 13.5 렉시컬 스코프

- 동적 스코프
  - 함수 호출되는 시점에 동적으로 상위 스코프 결정
- 렉시컬 스코프, 정적 스코프
  - 함수 정의가 평가되는 시점에 상위 스코프가 정적으로 결정
  - 자바스크립트가 따르는 방법
  - 함수를 어디서 호출했는지가 아닌, 어디서 정의했는지에 따라 상위 스코프 결정
  - 즉, 상위 스코프는 자신이 정의된 스코프

## 14장: 전역 변수의 문제점

### 14.1 변수의 생명 주기

- 변수 생명주기
  - 생성: 메모리 공간이 확보된 시점
  - 소멸: 메모리 공간이 해제되어 가용 메모리 풀에 반환되는 점
- 전역 변수
  - 생명 주기: 브라우저의 생명 주기와 동일
    - var 키워드로 생성하면 전역 객체 생명 주기일
  - 런타임 이전에 실행
- 지역 변수
  - 생명 주기: 함수의 생명 주기와 일
    - 생성: 함수 호출
    - 소멸: 함수 종료
  - 함수 호출 직후, 함수 몸체 코드 실행 전 실행
- 호이스팅
  - 스코프 단위로 동작

### 14.3 전역 변수 사용 억제하는 방법

- 네임스페이스 객체
  - 네임스페이스 역할 담당할 객체 생성하고 변수를 파라미터로 추가
- 모듈 패턴
  - 클래스를 모방해, 관련 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈 생성
  - 클로저 기반으로 동작
  - 이를 통해 캡슐화를 진행해 정보 은닉 가능
- ES6 모듈
  - 파일 자체 독자적 모듈 스코프 제공
  - 확장자 mjs 추천
