# 모던 자바스크립트 딥다이브 스터디 7회

## 목차

- 38장: 브라우저 렌더링 과정
- 39장: DOM

## 질문

### 38장

- async 어트리뷰트를 사용하는 자바스크립트 예시는 무엇이 있는가? (DOM 생성이 완료도기 이전에 실행되어도 괜찮은 예시가 궁금합니다)

### 39장

- HTML 마크업 문자 파싱함에 의해 크로스 사이트 스크립팅 공격에 취약해지는 이유는 무엇인가?

## 38장: 브라우저 렌더링 과정

- 파싱
  1. 프로그래밍 언어 문법에 맞게 작성된 텍스트 문서(바이트 > 문자)
  2. 텍스트 문서의 문자열을 토큰으로 분해(토큰)
  3. 토큰에 문법적 의미 및 구조 반영(노드)
  4. 트리 구조인 자료구조 생성(DOM)
- 브라우저 렌더링 과정
  1. 브라우저: 렌더링 필요한 리소스 서버에게 요청하고, 응답 받기
  2. 브라우저 렌더링 엔진: 서버로 받은 리소스(html, css) 파싱하여 렌더 트리 생성
  3. 브라우저 자바스크립트 엔진: 서버로 받은 자바스크립트 파싱하여 트리 생성하고, 바이트코드로 변환하여 실행
  4. 렌더링: 렌더 트리 기반으로 HTML 요소 레이아웃 계산하고, 브라우저 화면에 HTML 요소 페인팅

### 38.1 요청과 응답

- 브라우저 핵심
  - 서버에게 필요한 리소스 요청
    - 렌더링에 필요한 리소스는 모두 서버에 존재
  - 서버로부터 리소스 응답
- 상황
  - 브라우저 주소창에 엔터키 누름
  - scheme+host만으로 구성된 요청이 서버에게 전송
  - 내용이 없다면 index.html을 응답
  - 내용을 원한다면 host 뒤에 정적 파일 경로 작성하여, 서버에게 요청

### 38.2 HTTP 1.1 VS HTTP 2

- HTTP: 웹에서 브라우저와 서버가 통신하기 위한 프로토콜
- HTTP 1.1: 커넥션 당 하나의 요청과 응답 처리
  - 요청 리소스에 따라 응답 시간 증가
- HTTP 2.0: 다중 요청/응답 가능
  - HTTP 1.1보다 빠름

### 38.3 HTML 파싱과 DOM 생성

- HTML 문서: 문자열로 이루어진 순수한 텍스트
  - 렌더링을 위해선 브라우저 이해할 수 있는 자료구조(객체)로 변환 필요!
- 과정
  1. 서버가 HTML 2진수로 응답
  2. 브라우저는 2진수 HTML 받아서, meta 태그의 인코딩 방식으로 문자열 변환
  3. 문자열을 토큰으로 분해
  4. 각 코튼을 객체로 변환하여 노드 생성
  5. 노드를 기반으로 DOM(트리 자료구조) 생성

### 38.4 CSS 파싱과 CSSOM 생성

- HTML 순차적으로 파싱하며 DOM 생성 진행
- CSS link 태그나 style 태그를 만나면 DOM 생성 일시 중단
- CSS 파일 서버에 요청하여 파싱 과정을 거쳐 CSSOM 생성
  - CSSOM은 css의 상속을 반영하여 생성됨

### 38.5 렌더 트리 생성

- 렌더 트리: 렌더링을 위한 트리 구조의 자료구조
- 브라우저 화면엔 렌더링 되는 노드만으로 구성됨
- 렌더링 과정
  - 렌더 트리 생성
  - 레이아웃 계산
  - 페인트

### 38.6 자바스크립트 파싱과 실행

- DOM API: 이미 생성된 DOM 동적으로 조작 가능
- script 태그
  - script 태그 자바스크립트 코드 파싱을 위해 자바스크립트 엔진에게 제어권 넘김
  - 자바스크립트 코드 파싱
    - AST(추상적 구문 트리)를 생성
    - AST 기반으로 인터프리터가 실행할 수 있는 중간 코드인 바이트코드를 생성하여 실행
      - CPU가 이해할 수 있는 저수준 언어로 변환하여 실행
  - 자바스크립트 코드 파싱을 완료하면 렌더링 엔진으로 다시 제어권 넘김
- 과정
  1. 토크나이징
  2. 파싱
  3. 바이트코드 생성과 실행
     - 파싱 결과물로 생성된 AST는 바이트코드로 변환
     - 인터프리터에 의해 실행

### 38.7 리플로우와 리페인트

- 리플로우: 레이아웃 계산을 다시 하는 것
- 리페인팅: 재결합된 렌더 트리 기준으로 다시 페인트함
  - 단, 레이아웃 변경 없으면 리플로우 없이 리페인팅만 진행

### 38.8 자바스크립트 파싱에 의한 HTML 파싱 중단

- 직렬적으로 파싱 수행
- DOM 변경 존재하는 DOM API 사용시, DOM 또는 CSSOM 사전에 생성 필수!
- script 태그 위치 중요함
  - body 요소 가장 아래에 위치
    - 자바스크립트에 의해 HTML 요소 렌더링 지장받는 일 없어, 페이지 로딩 시간 단축
  - 헤더 내부에 생성하고, async 또는 defer attribute 붙이기
    - async
      - HTML 파싱과 외부 자바스크립트 로드 비동기적으로 동시에 실행
      - script 태그 순서와 상관없이 로드 완료된 자바스크립트 먼저 실행
    - defer
      - HTML 파싱과 외부 자바스크립트 로드 비동기적으로 동시에 실행
      - HTML 파싱 완료된 후, 자바스크립트 파싱 및 실행 진행

## 39장: DOM

- DOM: HTML 문서 계층적 구조와 정보 표현 + 제어하는 API 제공하는 트리 자료구조

### 39.1 노드

- HTML 요소: HTML 문서 구성하는 개별적 요소
  - attribute: attribute node
  - 텍스트 콘텐츠: 텍스트 node
- 트리 자료구조
  - 노드 간 계층적 구조를 표현하는 비선형(하나 자료 뒤에 하나 자료만 존재) 자료구조
- 노드 객체 타입
  - 문서 노드
    - 최상위 루트 노드
    - HTML 문서당 document 객체 유일
  - 요소 노드
    - HTML 요소 가리키는 객체
  - attribute 노드
    - HTML 요소의 attribute 가리키는 객체
    - 요소 노드에만 연결됨
  - 텍스트 노드
    - HTML 요소의 텍스트 가리키는 객체
    - 리프 노드임
- 노드 객체 상속
  - 브라우저 환경에서 추가로 제공하는 호스트 객체
  - 공통된 기능일수록 프로토타입 체인의 상위
  - 개별적 고유일수록 프로토타입 체인의 하위

### 39.2 요소 노드 취득

- HTML 요소에 id attribute 부여하면 id값과 동일한 전역 변수가 암묵적으로 선언
- getElementByTagsName
  - 여러 개 노드 객체 가지는 DOM 컬렉션 객체인 HTMLCollection return
- HTMLCollection
  - 유사 배열 객체이며 이터러블임
  - 모든 요소 취득하려면 \* 전달
- NodeList 객체
  - 유사 배열 객체이며 이터러블임
- HTMLCollection VS NodeList
  - 유사 배열 객체이며 이터러블임
  - 순회 및 스프레드 문법 사용 가능, 배열로 변환 가능
  - HTMLCollection: 언제나 live 객체로 동작
  - NodeList: non-live 객체로 동작하나, childNodes 프로퍼티 반환하는 경우엔 live 객체로 동작
  - 단! live 객체로 동작하는 경우 배열로 변환하여 사용함을 권장
- 선택자
  - 후손 선택자: div p
  - 자식 선택자: div > p
  - 인접 형제 선택자: p + ul
    - 바로 뒤만 선택
  - 일반 형제 선택자: p ~ ul
    - 모두 선택
  - 가상 클래스 선택자: :hover
  - 가상 요소 선택자: ::before
- querySelector VS getElementBy\*\*
  - querySelector가 더 느림
  - 단, CSS 선택자 문법 사용해 구체적 조건으로 취득하고 일관된 방식으로 취득 가능
- 공백 텍스트 노드
  - HTML 요소 사이의 공백 문자로 인해 생성되는 노드
- 자식 요소 확인
  - childNodes: 요소 노드+텍스트 노드
  - children: 텍스트 노드만

### 39.4 노드 정보 취득

- nodeType: 노드 타입 나타내는 상수 return

### 39.5 요소 노드 텍스트 조작

- nodeValue
  - setter, getter 모두 존재
  - 노드 객체란 텍스트 노드의 텍스트이기에, 텍스트인 것들만 return
- textContent
  - HTML 마크업 무시됨
- nodeValue VS textContent
  - nodeValue: 디테일하게 끝까지 들어가야 해서 코드가 더 복잡함

### 39.6 DOM 조작

- innerHTML
  - HTML 마크업 포함됨
  - 크로스 사이트 스크립팅 공격에 취약해 위험함(\*HTML 마크업 문자 파싱)
    - HTML 새니티제이션으로 위험 제거
  - 기존의 자식 모두 제거하고, 처음부터 새롭게 자식 노드 생성해 DOM에 반영
- insertAdjacentHTML
  - 기존의 자식 제거하지 않고, 위치 지정해 새로운 요소 삽입
  - 크로스 사이트 스크립팅 공격에 취약해 위험함(\*HTML 마크업 문자 파싱)
- 요소 추가할 때 효율적인 방법
  - 여러 번 DOM에 추가하면 여러 번 리플로우+리페인트 발생
  - 컨테이너 요소 생성해, 한 번의 리플로우+리페인트 발생하도록!
    - createElement: 불필요한 요소가 DOM에 추가됨
    - ceateDocumentFragment: 불필요한 요소 없이 DOM에 추가됨
- 노드 이동
  - DOM에 이미 존재하는 노드를 DOM에 다시 추가하면, 현재 위치에서 노드 제거하고 새로운 위치에 노드를 추가함
- 노드 복사
  - 얕은 복사로 생성된 요소 노드는 텍스트 노드가 없음
    - 자손 노드를 복사하지 않기 때문임
  - 깊은 복사로 생성된 요소 노드는 텍스트 노드 존재함

### 39.7 어트리뷰트

- 종류
  - 글로벌 어트리뷰트
  - 이벤트 핸들러 어트리뷰트
- HTML 문서가 파싱될 때 HTML 요소의 어트리뷰트는 어트리뷰트 노드로 변환됨
- HTML 어트리뷰트 조작
  - getAttribute, setAttriute 사용시, attributes 프로퍼티 없이 직접 값 취득 가능
- HTML 어트리뷰트 VS DOM 프로퍼티
  - HTML 어트리뷰트: 초기 상태 관리
    - setAttribute로 초기 상태 변경 가능
  - DOM 프로퍼티: 요소 노드 최신 상태 관리
    - 사용자 입력과 관련된 DOM 프로퍼티만 최신 상태 관리
    - 사용자 입력과 상관없는 DOM 프로퍼티는 변경 없음(id와 같은 것)
- data 어트리뷰트, dataset 프로퍼티
  - 사용자 정의 어트리뷰트 ↔ 자바스크립트: 데이터 교환 가능

### 39.8 스타일

- 인라인 스타일 조작
  - style 프로퍼티
- 클래스 조작
  - class 어트리뷰트 ↔ DOM 프로퍼티(className, classList)
    - class는 자바스크립트 예약어이기에 피함
- 모든 CSS 스타일 참조하는 경우
  - getComputedStyle 메서드 사용
